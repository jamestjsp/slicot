{
  "ab01md": "Controllable realization for single-input systems.\n\nFinds a controllable realization for the linear time-invariant\nsingle-input system dX/dt = A*X + B*U, reducing to orthogonal\ncanonical form using orthogonal similarity transformations.\n\nParameters:\n  jobz (str): 'N' (no Z), 'F' (factored form), 'I' (identity init)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input vector B (n,), F-order\n  tol (float): Tolerance (0 for default)\n\nReturns:\n  (a, b, ncont, z, tau, info): Transformed matrices, controllable order,\n                               transformation matrix, reflectors, exit code\n\nExamples:\n\n>>> from slicot import ab01md\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([\n...     [1.0, 2.0, 0.0],\n...     [4.0, -1.0, 0.0],\n...     [0.0, 0.0, 1.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([1.0, 0.0, 1.0], dtype=float, order='F')\n>>> tol = 0.0\n>>> a_out, b_out, ncont, z, tau, info = ab01md('I', a, b, tol)\n>>> info\n0",
  "ab01nd": "Controllable realization for multi-input systems.\n\nFinds a controllable realization for the linear time-invariant\nmulti-input system dX/dt = A*X + B*U, reducing (A,B) to orthogonal\ncanonical form with upper block Hessenberg structure.\n\nParameters:\n  jobz (str): 'N' (no Z), 'F' (factored form), 'I' (identity init)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  tol (float): Tolerance (0 for default)\n\nReturns:\n  (a, b, ncont, indcon, nblk, z, tau, info):\n    - a: Transformed A (block Hessenberg)\n    - b: Transformed B\n    - ncont: Order of controllable part\n    - indcon: Controllability index\n    - nblk: Block sizes (first indcon elements)\n    - z: Transformation matrix\n    - tau: Elementary reflector factors\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ab01nd\n>>> import numpy as np\n>>> n, m = 3, 2\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0],\n...     [-2.0, -2.0, -2.0],\n...     [-1.0,  0.0, -3.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 2.0],\n...     [0.0, 1.0]\n...     ], dtype=float, order='F')\n>>> tol = 0.0\n>>> a_out, b_out, ncont, indcon, nblk, z, tau, info = ab01nd('I', a, b, tol)\n>>> info\n0",
  "ab01od": "Staircase form for multi-input systems.\n\nReduces (A,B) to upper staircase form using orthogonal state-space\nand input-space transformations U and V.\n\nParameters:\n  stages (str): 'F' (forward), 'B' (backward), 'A' (all)\n  jobu (str): 'N' (no U), 'I' (return U)\n  jobv (str): 'N' (no V), 'I' (return V)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  tol (float): Tolerance (0 for default)\n\nReturns:\n  (a, b, u, v, ncont, indcon, kstair, info):\n    - a: Transformed A (U'*A*U)\n    - b: Transformed B (U'*B*V or U'*B)\n    - u: State transformation matrix\n    - v: Input transformation matrix\n    - ncont: Order of controllable part\n    - indcon: Controllability index\n    - kstair: Block sizes (first indcon elements)\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ab01od\n>>> import numpy as np\n>>> n, m = 5, 2\n>>> a = np.array([\n...     [17.0, 24.0,  1.0,  8.0, 15.0],\n...     [23.0,  5.0,  7.0, 14.0, 16.0],\n...     [ 4.0,  6.0, 13.0, 20.0, 22.0],\n...     [10.0, 12.0, 19.0, 21.0,  3.0],\n...     [11.0, 18.0, 25.0,  2.0,  9.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [ -1.0,  -4.0],\n...     [  4.0,   9.0],\n...     [ -9.0, -16.0],\n...     [ 16.0,  25.0],\n...     [-25.0, -36.0]\n...     ], dtype=float, order='F')\n>>> tol = 0.0\n>>> a_out, b_out, u, v, ncont, indcon, kstair, info = ab01od(\n...     'F', 'I', 'N', a, b, tol\n...     )\n>>> b_zeros = b_out[kstair[0]:, :]\n>>> utu = u.T @ u\n>>> info\n0",
  "ab04md": "Bilinear transformation of state-space system.\n\nPerforms discrete-time <-> continuous-time conversion via bilinear\ntransformation of the state-space matrices (A,B,C,D).\n\nParameters:\n  type (str): 'D' for discrete->continuous, 'C' for continuous->discrete\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  alpha (float, optional): Transformation parameter (default 1.0)\n  beta (float, optional): Transformation parameter (default 1.0)\n\nReturns:\n  (a, b, c, d, info): Transformed matrices and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab04md\n>>> a = np.array([[1.0, 0.5],\n...     [0.5, 1.0]], order='F', dtype=float)\n>>> b = np.array([[0.0, 1.0],\n...     [-1.0, 0.0]], order='F', dtype=float)\n>>> c = np.array([[-1.0, 0.0],\n...     [0.0, 1.0]], order='F', dtype=float)\n>>> d = np.array([[1.0, 0.0],\n...     [0.0, -1.0]], order='F', dtype=float)\n>>> a_out, b_out, c_out, d_out, info = ab04md('C', a, b, c, d, alpha=1.0, beta=1.0)\n>>> info\n0",
  "ab05md": "Cascade (series) inter-connection of two state-space systems.\n\nComputes the state-space model (A,B,C,D) for the cascaded connection\nof two systems G1 and G2, where output of G1 feeds input of G2:\nY = G2(G1(U))\n\nParameters:\n  uplo (str): 'L' for lower block diagonal, 'U' for upper block diagonal\n  over (str): 'N' no overlap, 'O' overlap arrays\n  a1 (ndarray): State matrix of G1 (n1 x n1, F-order)\n  b1 (ndarray): Input matrix of G1 (n1 x m1, F-order)\n  c1 (ndarray): Output matrix of G1 (p1 x n1, F-order)\n  d1 (ndarray): Feedthrough matrix of G1 (p1 x m1, F-order)\n  a2 (ndarray): State matrix of G2 (n2 x n2, F-order)\n  b2 (ndarray): Input matrix of G2 (n2 x p1, F-order)\n  c2 (ndarray): Output matrix of G2 (p2 x n2, F-order)\n  d2 (ndarray): Feedthrough matrix of G2 (p2 x p1, F-order)\n\nReturns:\n  (a, b, c, d, n, info): Cascaded system matrices, state order, exit code\n\nExamples:\n\n>>> from slicot import ab05md\n>>> import numpy as np\n>>> a1 = np.array([\n...     [1.0, 0.0, -1.0],\n...     [0.0, -1.0, 1.0],\n...     [1.0, 1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b1 = np.array([\n...     [1.0, 2.0],\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c1 = np.array([\n...     [3.0, -2.0, 1.0],\n...     [0.0, 1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> d1 = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a2 = np.array([\n...     [-3.0, 0.0, 0.0],\n...     [1.0, 0.0, 1.0],\n...     [0.0, -1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b2 = np.array([\n...     [0.0, 1.0],\n...     [-1.0, 0.0],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> c2 = np.array([\n...     [1.0, 1.0, 0.0],\n...     [1.0, 1.0, -1.0]\n...     ], order='F', dtype=float)\n>>> d2 = np.array([\n...     [1.0, 1.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a, b, c, d, n, info = ab05md('L', 'N', a1, b1, c1, d1, a2, b2, c2, d2)\n>>> info\n0",
  "ab05nd": "Feedback inter-connection of two state-space systems.\n\nComputes the state-space model (A,B,C,D) for the feedback connection\nof two systems G1 and G2:\n  U = U1 + alpha*Y2,  Y = Y1 = U2\n  alpha = +1: positive feedback\n  alpha = -1: negative feedback\n\nParameters:\n  over (str): 'N' no overlap, 'O' overlap arrays\n  alpha (float): Feedback coefficient (+1 or -1)\n  a1 (ndarray): State matrix of G1 (n1 x n1, F-order)\n  b1 (ndarray): Input matrix of G1 (n1 x m1, F-order)\n  c1 (ndarray): Output matrix of G1 (p1 x n1, F-order)\n  d1 (ndarray): Feedthrough matrix of G1 (p1 x m1, F-order)\n  a2 (ndarray): State matrix of G2 (n2 x n2, F-order)\n  b2 (ndarray): Input matrix of G2 (n2 x p1, F-order)\n  c2 (ndarray): Output matrix of G2 (m1 x n2, F-order)\n  d2 (ndarray): Feedthrough matrix of G2 (m1 x p1, F-order)\n\nReturns:\n  (a, b, c, d, n, info): Feedback system matrices, state order, exit code\n\nExamples:\n\n>>> from slicot import ab05nd\n>>> import numpy as np\n>>> a1 = np.array([\n...     [1.0, 0.0, -1.0],\n...     [0.0, -1.0, 1.0],\n...     [1.0, 1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b1 = np.array([\n...     [1.0, 2.0],\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c1 = np.array([\n...     [3.0, -2.0, 1.0],\n...     [0.0, 1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> d1 = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a2 = np.array([\n...     [-3.0, 0.0, 0.0],\n...     [1.0, 0.0, 1.0],\n...     [0.0, -1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b2 = np.array([\n...     [0.0, 1.0],\n...     [-1.0, 0.0],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> c2 = np.array([\n...     [1.0, 1.0, 0.0],\n...     [1.0, 1.0, -1.0]\n...     ], order='F', dtype=float)\n>>> d2 = np.array([\n...     [1.0, 1.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> alpha = 1.0  # Positive feedback\n>>> a, b, c, d, n, info = ab05nd('N', alpha, a1, b1, c1, d1, a2, b2, c2, d2)\n>>> info\n0",
  "ab05od": "Rowwise concatenation of two state-space systems.\n\nComputes the state-space model (A,B,C,D) for rowwise concatenation\n(parallel inter-connection with separate inputs):\n  Y = G1*U1 + alpha*G2*U2\n\nCombined system has:\n  A = [[A1, 0], [0, A2]]  (block diagonal)\n  B = [[B1, 0], [0, B2]]  (block diagonal)\n  C = [C1, alpha*C2]      (rowwise concatenation)\n  D = [D1, alpha*D2]      (rowwise concatenation)\n\nParameters:\n  over (str): 'N' no overlap, 'O' overlap arrays\n  a1 (ndarray): State matrix of G1 (n1 x n1, F-order)\n  b1 (ndarray): Input matrix of G1 (n1 x m1, F-order)\n  c1 (ndarray): Output matrix of G1 (p1 x n1, F-order)\n  d1 (ndarray): Feedthrough matrix of G1 (p1 x m1, F-order)\n  a2 (ndarray): State matrix of G2 (n2 x n2, F-order)\n  b2 (ndarray): Input matrix of G2 (n2 x m2, F-order)\n  c2 (ndarray): Output matrix of G2 (p1 x n2, F-order)\n  d2 (ndarray): Feedthrough matrix of G2 (p1 x m2, F-order)\n  alpha (float): Coefficient multiplying second system\n\nReturns:\n  (a, b, c, d, n, m, info): Combined system matrices, state order, input count, exit code\n\nExamples:\n\n>>> from slicot import ab05od\n>>> import numpy as np\n>>> a1 = np.array([\n...     [1.0, 0.0, -1.0],\n...     [0.0, -1.0, 1.0],\n...     [1.0, 1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b1 = np.array([\n...     [1.0, 2.0],\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c1 = np.array([\n...     [3.0, -2.0, 1.0],\n...     [0.0, 1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> d1 = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a2 = np.array([\n...     [-3.0, 0.0, 0.0],\n...     [1.0, 0.0, 1.0],\n...     [0.0, -1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b2 = np.array([\n...     [0.0, 1.0],\n...     [-1.0, 0.0],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> c2 = np.array([\n...     [1.0, 1.0, 0.0],\n...     [1.0, 1.0, -1.0]\n...     ], order='F', dtype=float)\n>>> d2 = np.array([\n...     [1.0, 1.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> alpha = 1.0\n>>> a, b, c, d, n, m, info = ab05od('N', a1, b1, c1, d1, a2, b2, c2, d2, alpha)\n>>> info\n0",
  "ab05pd": "Parallel inter-connection of two state-space systems (same inputs).\n\nComputes the state-space model (A,B,C,D) for the sum G = G1 + alpha*G2\nwhere both systems share the same inputs:\n  Y = G1*U + alpha*G2*U\n\nCombined system has:\n  A = [[A1, 0], [0, A2]]    (block diagonal)\n  B = [[B1], [B2]]          (stacked vertically)\n  C = [C1, alpha*C2]        (concatenated horizontally)\n  D = D1 + alpha*D2         (matrix sum)\n\nParameters:\n  n1 (int): Number of states in first system\n  m (int): Number of inputs (same for both systems)\n  p (int): Number of outputs (same for both systems)\n  n2 (int): Number of states in second system\n  alpha (float): Coefficient multiplying second system\n  a1 (ndarray): State matrix of G1 (n1 x n1, F-order)\n  b1 (ndarray): Input matrix of G1 (n1 x m, F-order)\n  c1 (ndarray): Output matrix of G1 (p x n1, F-order)\n  d1 (ndarray): Feedthrough matrix of G1 (p x m, F-order)\n  a2 (ndarray): State matrix of G2 (n2 x n2, F-order)\n  b2 (ndarray): Input matrix of G2 (n2 x m, F-order)\n  c2 (ndarray): Output matrix of G2 (p x n2, F-order)\n  d2 (ndarray): Feedthrough matrix of G2 (p x m, F-order)\n\nReturns:\n  (n, a, b, c, d, info): State order, combined system matrices, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab05pd\n>>> n1, m, p, n2 = 3, 2, 2, 3\n>>> alpha = 1.0\n>>> a1 = np.array([\n...     [1.0, 0.0, -1.0],\n...     [0.0, -1.0, 1.0],\n...     [1.0, 1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b1 = np.array([\n...     [1.0, 2.0],\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c1 = np.array([\n...     [3.0, -2.0, 1.0],\n...     [0.0, 1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> d1 = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a2 = np.array([\n...     [-3.0, 0.0, 0.0],\n...     [1.0, 0.0, 1.0],\n...     [0.0, -1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b2 = np.array([\n...     [0.0, 1.0],\n...     [-1.0, 0.0],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> c2 = np.array([\n...     [1.0, 1.0, 0.0],\n...     [1.0, 1.0, -1.0]\n...     ], order='F', dtype=float)\n>>> d2 = np.array([\n...     [1.0, 1.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> n, a, b, c, d, info = ab05pd(n1, m, p, n2, alpha, a1, b1, c1, d1, a2, b2, c2, d2)\n>>> info\n0",
  "ab05qd": "Append two systems in state-space form (block diagonal).\n\nConstructs G = diag(G1, G2) with separate inputs and outputs:\n  A = [[A1, 0], [0, A2]]   (block diagonal)\n  B = [[B1, 0], [0, B2]]   (block diagonal)\n  C = [[C1, 0], [0, C2]]   (block diagonal)\n  D = [[D1, 0], [0, D2]]   (block diagonal)\n\nParameters:\n  over (str): 'N' no overlap, 'O' overlap arrays\n  a1 (ndarray): State matrix of G1 (n1 x n1, F-order)\n  b1 (ndarray): Input matrix of G1 (n1 x m1, F-order)\n  c1 (ndarray): Output matrix of G1 (p1 x n1, F-order)\n  d1 (ndarray): Feedthrough matrix of G1 (p1 x m1, F-order)\n  a2 (ndarray): State matrix of G2 (n2 x n2, F-order)\n  b2 (ndarray): Input matrix of G2 (n2 x m2, F-order)\n  c2 (ndarray): Output matrix of G2 (p2 x n2, F-order)\n  d2 (ndarray): Feedthrough matrix of G2 (p2 x m2, F-order)\n\nReturns:\n  (a, b, c, d, n, m, p, info): Combined system matrices,\n    state order, input count, output count, exit code\n\nExamples:\n\n>>> from slicot import ab05qd\n>>> import numpy as np\n>>> a1 = np.array([\n...     [1.0, 0.0, -1.0],\n...     [0.0, -1.0, 1.0],\n...     [1.0, 1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b1 = np.array([\n...     [1.0, 2.0],\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c1 = np.array([\n...     [3.0, -2.0, 1.0],\n...     [0.0, 1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> d1 = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a2 = np.array([\n...     [-3.0, 0.0, 0.0],\n...     [1.0, 0.0, 1.0],\n...     [0.0, -1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b2 = np.array([\n...     [0.0, 1.0],\n...     [-1.0, 0.0],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> c2 = np.array([\n...     [1.0, 1.0, 0.0],\n...     [1.0, 1.0, -1.0]\n...     ], order='F', dtype=float)\n>>> d2 = np.array([\n...     [1.0, 1.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a, b, c, d, n, m, p, info = ab05qd('N', a1, b1, c1, d1, a2, b2, c2, d2)\n>>> info\n0",
  "ab05rd": "Closed-loop system for mixed output and state feedback control law.\n\nConstructs the closed-loop system (Ac,Bc,Cc,Dc) for the control law:\n  u = alpha*F*y + beta*K*x + G*v\n  z = H*y\n\nClosed-loop matrices:\n  E = (I - alpha*D*F)^(-1)\n  A1 = A + alpha*B*F*E*C,  B1 = B + alpha*B*F*E*D\n  C1 = E*C,                D1 = E*D\n  Ac = A1 + beta*B1*K,     Bc = B1*G\n  Cc = H*(C1 + beta*D1*K), Dc = H*D1*G\n\nParameters:\n  fbtype (str): 'I' for identity feedback (F=I), 'O' for general feedback\n  jobd (str): 'D' if D is present, 'Z' if D is zero matrix\n  n (int): Order of state matrix A (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0, p=m if fbtype='I')\n  mv (int): Dimension of new input v (mv >= 0)\n  pz (int): Dimension of new output z (pz >= 0)\n  alpha (float): Coefficient in output feedback law\n  beta (float): Coefficient in state feedback law\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  f (ndarray): Feedback matrix F (m x p, F-order)\n  k (ndarray): State feedback matrix K (m x n, F-order)\n  g (ndarray): Input scaling matrix G (m x mv, F-order)\n  h (ndarray): Output scaling matrix H (pz x p, F-order)\n\nReturns:\n  (Ac, Bc, Cc, Dc, rcond, info): Closed-loop matrices,\n    reciprocal condition number, exit code (0=success, 1=singular)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab05rd\n>>> n, m, p, mv, pz = 3, 2, 2, 2, 2\n>>> alpha = 1.0\n>>> beta = 1.0\n>>> A = np.array([\n...     [1.0, 0.0, -1.0],\n...     [0.0, -1.0, 1.0],\n...     [1.0, 1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [1.0, 2.0],\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> C = np.array([\n...     [3.0, -2.0, 1.0],\n...     [0.0, 1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> D = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> F = np.array([\n...     [1.0, 2.0],\n...     [3.0, 4.0]\n...     ], order='F', dtype=float)\n>>> K = np.array([\n...     [2.0, 1.0, 0.0],\n...     [1.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> G = np.array([\n...     [1.0, 1.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> H = np.array([\n...     [4.0, 3.0],\n...     [2.0, 1.0]\n...     ], order='F', dtype=float)\n>>> Ac, Bc, Cc, Dc, rcond, info = ab05rd('O', 'D', n, m, p, mv, pz, alpha, beta,\n...     A, B, C, D, F, K, G, H)\n>>> info\n0",
  "ab05sd": "Closed-loop system for output feedback control law.\n\nConstructs the closed-loop system (Ac,Bc,Cc,Dc) for the output\nfeedback control law u = alpha*F*y + v.\n\nClosed-loop matrices:\n  E = (I - alpha*D*F)^(-1)\n  Ac = A + alpha*B*F*E*C\n  Bc = B + alpha*B*F*E*D\n  Cc = E*C\n  Dc = E*D\n\nParameters:\n  fbtype (str): 'I' for identity feedback (F=I), 'O' for general feedback\n  jobd (str): 'D' if D is present, 'Z' if D is zero matrix\n  n (int): Order of state matrix A (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0, p=m if fbtype='I')\n  alpha (float): Feedback gain coefficient\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  f (ndarray): Feedback matrix F (m x p, F-order)\n\nReturns:\n  (Ac, Bc, Cc, Dc, rcond, info): Closed-loop matrices,\n    reciprocal condition number, exit code (0=success, 1=singular)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab05sd\n>>> n, m, p = 3, 2, 2\n>>> alpha = 0.5\n>>> A = np.array([\n...     [-1.0, 0.5, 0.0],\n...     [0.0, -2.0, 0.3],\n...     [0.0, 0.0, -3.0]\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [0.5, 0.5]\n...     ], order='F', dtype=float)\n>>> C = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> D = np.array([\n...     [0.1, 0.0],\n...     [0.0, 0.1]\n...     ], order='F', dtype=float)\n>>> F = np.array([\n...     [0.2, 0.3],\n...     [0.1, 0.4]\n...     ], order='F', dtype=float)\n>>> Ac, Bc, Cc, Dc, rcond, info = ab05sd('O', 'D', n, m, p, alpha, A, B, C, D, F)\n>>> info\n0",
  "ab07md": "Dual of a state-space representation.\n\nFinds the dual of a given state-space representation (A,B,C,D).\nIf M-input/P-output, its dual is P-input/M-output (A',C',B',D').\n\nParameters:\n  jobd (str): 'D' if D is present, 'Z' if D is zero matrix\n  n (int): Order of state-space representation (n >= 0)\n  m (int): Number of system inputs (m >= 0)\n  p (int): Number of system outputs (p >= 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x max(m,p), F-order)\n  c (ndarray): Output matrix C (max(m,p) x n, F-order)\n  d (ndarray): Feedthrough matrix D (max(m,p) x max(m,p), F-order)\n\nReturns:\n  (a_dual, b_dual, c_dual, d_dual, info): Dual system matrices and exit code\n\nExamples:\n\n>>> from slicot import ab07md\n>>> import numpy as np\n>>> n, m, p = 3, 1, 2\n>>> a_in = np.array([\n...     [1.0, 2.0, 0.0],\n...     [4.0, -1.0, 0.0],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> b_in = np.array([\n...     [1.0],\n...     [0.0],\n...     [1.0]\n...     ], order='F', dtype=float)\n>>> c_in = np.array([\n...     [0.0, 1.0, -1.0],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d_in = np.array([\n...     [0.0],\n...     [1.0]\n...     ], order='F', dtype=float)\n>>> a, b, c, d = prepare_arrays(n, m, p, a_in, b_in, c_in, d_in)\n>>> a_dual, b_dual, c_dual, d_dual, info = ab07md('D', n, m, p, a, b, c, d)\n>>> info\n0",
  "ab07nd": "Compute the inverse of a linear system.\n\nComputes the inverse (Ai,Bi,Ci,Di) of a given system (A,B,C,D):\n  Ai = A - B*D^-1*C, Bi = -B*D^-1, Ci = D^-1*C, Di = D^-1.\n\nParameters:\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (m x n, F-order)\n  d (ndarray): Feedthrough matrix D (m x m, F-order)\n\nReturns:\n  (ai, bi, ci, di, rcond, info): Inverse system matrices,\n    reciprocal condition number, and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab07nd\n>>> a = np.array([[1.0, 2.0, 0.0],\n...     [4.0, -1.0, 0.0],\n...     [0.0, 0.0, 1.0]], order='F', dtype=float)\n>>> b = np.array([[1.0, 0.0],\n...     [0.0, 1.0],\n...     [1.0, 0.0]], order='F', dtype=float)\n>>> c = np.array([[0.0, 1.0, -1.0],\n...     [0.0, 0.0, 1.0]], order='F', dtype=float)\n>>> d = np.array([[4.0, 0.0],\n...     [0.0, 1.0]], order='F', dtype=float)\n>>> ai, bi, ci, di, rcond, info = ab07nd(a, b, c, d)\n>>> info\n0",
  "ab08md": "Compute normal rank of transfer-function matrix.\n\nComputes the normal rank of the transfer-function matrix of a\nstate-space model (A,B,C,D).\n\nParameters:\n  equil (str): 'S' to balance compound matrix, 'N' for no balancing\n  n (int): Number of state variables (>= 0)\n  m (int): Number of system inputs (>= 0)\n  p (int): Number of system outputs (>= 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol (float, optional): Tolerance for rank decisions (default 0)\n\nReturns:\n  (rank, info): Normal rank and exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ab08md\n>>> import numpy as np\n>>> n, m, p = 1, 1, 1\n>>> a = np.array([[-1.0]], order='F', dtype=float)\n>>> b = np.array([[1.0]], order='F', dtype=float)\n>>> c = np.array([[1.0]], order='F', dtype=float)\n>>> d = np.array([[1.0]], order='F', dtype=float)\n>>> rank, info = ab08md('N', n, m, p, a, b, c, d)\n>>> info\n0",
  "ab08mz": "Compute normal rank of transfer-function matrix (complex case).\n\nComputes the normal rank of the transfer-function matrix of a\ncomplex state-space model (A,B,C,D).\n\nParameters:\n  equil (str): 'S' to balance compound matrix, 'N' for no balancing\n  n (int): Number of state variables (>= 0)\n  m (int): Number of system inputs (>= 0)\n  p (int): Number of system outputs (>= 0)\n  a (ndarray): State matrix A (n x n, complex F-order)\n  b (ndarray): Input matrix B (n x m, complex F-order)\n  c (ndarray): Output matrix C (p x n, complex F-order)\n  d (ndarray): Feedthrough matrix D (p x m, complex F-order)\n  tol (float, optional): Tolerance for rank decisions (default 0)\n\nReturns:\n  (rank, info): Normal rank and exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ab08mz\n>>> import numpy as np\n>>> n, m, p = 1, 1, 1\n>>> a = np.array([[-1.0+0j]], order='F', dtype=np.complex128)\n>>> b = np.array([[1.0+0j]], order='F', dtype=np.complex128)\n>>> c = np.array([[1.0+0j]], order='F', dtype=np.complex128)\n>>> d = np.array([[1.0+0j]], order='F', dtype=np.complex128)\n>>> rank, info = ab08mz('N', n, m, p, a, b, c, d)\n>>> info\n0",
  "ab08nd": "Construct regular pencil for invariant zeros.\n\nConstructs a regular pencil (Af - lambda*Bf) for a state-space system\n(A,B,C,D) whose generalized eigenvalues are the invariant zeros.\nAlso computes orders of infinite zeros and Kronecker indices.\n\nParameters:\n  equil (str): 'S' to balance compound matrix, 'N' for no balancing\n  n (int): Number of state variables (>= 0)\n  m (int): Number of system inputs (>= 0)\n  p (int): Number of system outputs (>= 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol (float, optional): Tolerance for rank decisions (default 0)\n\nReturns:\n  (nu, rank, dinfz, nkror, nkrol, infz, kronr, kronl, af, bf, info):\n    - nu: Number of finite invariant zeros\n    - rank: Normal rank of transfer function matrix\n    - dinfz: Maximum degree of infinite elementary divisors\n    - nkror: Number of right Kronecker indices\n    - nkrol: Number of left Kronecker indices\n    - infz: Array of infinite zero degrees\n    - kronr: Right Kronecker (column) indices\n    - kronl: Left Kronecker (row) indices\n    - af: Coefficient matrix Af of reduced pencil\n    - bf: Coefficient matrix Bf of reduced pencil\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ab08nd\n>>> import numpy as np\n>>> n, m, p = 6, 2, 3\n>>> a = np.array([\n...     [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 3.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, -4.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, -1.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0, -1.0],\n...     [-1.0, 0.0],\n...     [1.0, -1.0],\n...     [0.0, 0.0],\n...     [0.0, 1.0],\n...     [-1.0, -1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, 0.0, 1.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0, 0.0, 1.0],\n...     [0.0, 0.0, 1.0, 0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> result = ab08nd('N', n, m, p, a, b, c, d)\n>>> nu, rank, dinfz, nkror, nkrol, infz, kronr, kronl, af, bf, info = result\n>>> ninfz = sum(infz[i] * (i + 1) for i in range(dinfz))",
  "ab08nw": "Extract regular pencil for finite Smith zeros.\n\nExtracts from the system pencil S(lambda) = (A-lambda*I, B; C, D) a\nregular pencil Af-lambda*Ef whose generalized eigenvalues are the\nfinite Smith zeros. Also computes orders of infinite Smith zeros and\nKronecker indices.\n\nParameters:\n  equil (str): 'S' to balance system matrix, 'N' for no balancing\n  n (int): Number of state variables (>= 0)\n  m (int): Number of system inputs (>= 0)\n  p (int): Number of system outputs (>= 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol (float, optional): Tolerance for rank decisions (default 0)\n\nReturns:\n  (af, e, nfz, nrank, niz, dinfz, nkror, ninfe, nkrol, infz, kronr, infe, kronl, info):\n    - af: Matrix Af of reduced pencil (n x n)\n    - e: Matrix Ef of reduced pencil (n x n)\n    - nfz: Number of finite zeros\n    - nrank: Normal rank of system pencil\n    - niz: Number of infinite zeros\n    - dinfz: Maximal multiplicity of infinite Smith zeros\n    - nkror: Number of right Kronecker indices\n    - ninfe: Number of elementary infinite blocks\n    - nkrol: Number of left Kronecker indices\n    - infz: Array of infinite zero degrees\n    - kronr: Right Kronecker (column) indices\n    - infe: Multiplicities of infinite eigenvalues\n    - kronl: Left Kronecker (row) indices\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ab08nw\n>>> import numpy as np\n>>> n, m, p = 6, 2, 3\n>>> a = np.array([\n...     [1.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 3.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, -4.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, -1.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0, -1.0],\n...     [-1.0, 0.0],\n...     [1.0, -1.0],\n...     [0.0, 0.0],\n...     [0.0, 1.0],\n...     [-1.0, -1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, 0.0, 1.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0, 0.0, 1.0],\n...     [0.0, 0.0, 1.0, 0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> result = ab08nw('N', n, m, p, a, b, c, d)\n>>> (af, e, nfz, nrank, niz, dinfz, nkror, ninfe, nkrol,\n...     infz, kronr, infe, kronl, info) = result",
  "ab08nx": "Extract reduced system with full row rank D.\n\nFrom (N+P)-by-(M+N) compound matrix [B A; D C], extracts reduced\nsystem (NU+MU)-by-(M+NU) [B' A'; D' C'] with same transmission\nzeros but D' of full row rank.\n\nParameters:\n  n (int): Number of state variables (>= 0)\n  m (int): Number of system inputs (>= 0)\n  p (int): Number of system outputs (>= 0)\n  ro (int): P for original, max(P-M,0) for pertransposed\n  sigma (int): 0 for original, M for pertransposed\n  svlmax (float): Max singular value estimate (>= 0)\n  abcd (ndarray): Compound matrix ((N+P) x (M+N), F-order)\n  ninfz (int): Current number of infinite zeros (init 0)\n  tol (float): Tolerance for rank decisions\n\nReturns:\n  (abcd, ro, sigma, ninfz, mu, nu, nkrol, infz, kronl, info)\n\nExamples:\n\n>>> from slicot import ab08nx\n>>> import numpy as np\n>>> n, m, p = 2, 1, 1\n>>> a = np.random.randn(n, n).astype(float, order='F')\n>>> b = np.random.randn(n, m).astype(float, order='F')\n>>> c = np.random.randn(p, n).astype(float, order='F')\n>>> d = np.random.randn(p, m).astype(float, order='F')\n>>> abcd = np.zeros((n + p, m + n), dtype=float, order='F')\n>>> abcd[:n, :m] = b\n>>> abcd[:n, m:] = a\n>>> abcd[n:, :m] = d\n>>> abcd[n:, m:] = c\n>>> ro = p\n>>> sigma = 0\n>>> svlmax = 0.0\n>>> ninfz = 0\n>>> tol = 1e-10\n>>> result = ab08nx(n=n, m=m, p=p, ro=ro, sigma=sigma, svlmax=svlmax,\n...     abcd=abcd.copy(order='F'), ninfz=ninfz, tol=tol)\n>>> abcd_out, ro_out, sigma_out, ninfz_out, mu, nu, nkrol, infz, kronl, info = result",
  "ab08ny": "Extract reduced system pencil with Dr of full row rank.\n\nFrom (N+P)-by-(M+N) system pencil (B, A-lambda*I; D, C), extracts\nreduced (NR+PR)-by-(M+NR) pencil (Br, Ar-lambda*I; Dr, Cr) with\nsame transmission zeros but Dr of full row rank.\n\nParameters:\n  first (bool): True for first call, False for subsequent calls\n  n (int): Number of state variables (>= 0)\n  m (int): Number of system inputs (>= 0, <= p if first=False)\n  p (int): Number of system outputs (>= 0)\n  svlmax (float): Max singular value estimate (>= 0)\n  abcd (ndarray): Compound matrix ((N+P) x (M+N), F-order)\n  ninfz (int): Current number of infinite zeros (init 0 for first=True)\n  tol (float): Tolerance for rank decisions (< 1)\n\nReturns:\n  (abcd, ninfz, nr, pr, dinfz, nkronl, infz, kronl, info)\n\nExamples:\n\n>>> from slicot import ab08ny\n>>> import numpy as np\n>>> n, m, p = 2, 1, 1\n>>> a = np.random.randn(n, n).astype(float, order='F')\n>>> b = np.random.randn(n, m).astype(float, order='F')\n>>> c = np.random.randn(p, n).astype(float, order='F')\n>>> d = np.random.randn(p, m).astype(float, order='F')\n>>> abcd = np.zeros((n + p, m + n), dtype=float, order='F')\n>>> abcd[:n, :m] = b\n>>> abcd[:n, m:] = a\n>>> abcd[n:, :m] = d\n>>> abcd[n:, m:] = c\n>>> svlmax = 0.0\n>>> ninfz = 0\n>>> tol = 1e-10\n>>> result = ab08ny(first=True, n=n, m=m, p=p, svlmax=svlmax,\n...     abcd=abcd.copy(order='F'), ninfz=ninfz, tol=tol)\n>>> abcd_out, ninfz_out, nr, pr, dinfz, nkronl, infz, kronl, info = result",
  "ab08nz": "Construct regular pencil for invariant zeros of complex system.\n\nComputes (Af-lambda*Bf) whose generalized eigenvalues are the\ninvariant zeros of the system (A,B,C,D).\n\nParameters:\n  equil (str): 'S' scale, 'N' no scaling\n  a (ndarray): N-by-N complex state matrix A (F-order)\n  b (ndarray): N-by-M complex input matrix B (F-order)\n  c (ndarray): P-by-N complex output matrix C (F-order)\n  d (ndarray): P-by-M complex feedthrough D (F-order)\n  tol (float): Tolerance for rank decisions\n\nReturns:\n  (nu, rank, dinfz, nkror, nkrol, infz, kronr, kronl, af, bf, info)\n\nExamples:\n\n>>> from slicot import ab08nz\n>>> import numpy as np\n>>> n, m, p = 6, 0, 3\n>>> tol = 0.0\n>>> a = np.array([\n...     [1.0+0j, 0.0+0j, 0.0+0j, 0.0+0j, 0.0+0j, 0.0+0j],\n...     [0.0+0j, 1.0+0j, 0.0+0j, 0.0+0j, 0.0+0j, 0.0+0j],\n...     [0.0+0j, 0.0+0j, 3.0+0j, 0.0+0j, 0.0+0j, 0.0+0j],\n...     [0.0+0j, 0.0+0j, 0.0+0j, -4.0+0j, 0.0+0j, 0.0+0j],\n...     [0.0+0j, 0.0+0j, 0.0+0j, 0.0+0j, -1.0+0j, 0.0+0j],\n...     [0.0+0j, 0.0+0j, 0.0+0j, 0.0+0j, 0.0+0j, 3.0+0j],\n...     ], order='F', dtype=np.complex128)\n>>> b = np.zeros((n, m), order='F', dtype=np.complex128)\n>>> c = np.array([\n...     [1.0+0j, 0.0+0j, 0.0+0j, 1.0+0j, 0.0+0j, 0.0+0j],\n...     [0.0+0j, 1.0+0j, 0.0+0j, 1.0+0j, 0.0+0j, 1.0+0j],\n...     [0.0+0j, 0.0+0j, 1.0+0j, 0.0+0j, 0.0+0j, 1.0+0j],\n...     ], order='F', dtype=np.complex128)\n>>> d = np.zeros((p, m), order='F', dtype=np.complex128)\n>>> nu, rank, dinfz, nkror, nkrol, infz, kronr, kronl, af, bf, info = ab08nz(\n...     'N', n, m, p, a, b, c, d, tol\n...     )\n>>> info\n0",
  "ab09ad": "Balance & Truncate model reduction for stable systems.\n\nComputes a reduced order model (Ar,Br,Cr) using either square-root\nor balancing-free square-root Balance & Truncate method.\nThe routine first reduces A to real Schur form, then performs\nmodel reduction using AB09AX.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  job (str): 'B' for square-root B&T, 'N' for balancing-free B&T\n  equil (str): 'S' to scale (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  tol (float): Tolerance for order selection (used if ordsel='A')\n\nReturns:\n  (ar, br, cr, hsv, nr, iwarn, info): Reduced system matrices,\n    Hankel singular values, actual order, warning indicator, exit code\n\nExamples:\n\n>>> from slicot import ab09ad\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> a = np.array([\n...     [-0.04165,  0.0000,  4.9200, -4.9200,  0.0000,  0.0000,  0.0000],\n...     [-5.2100, -12.500,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.0000,   3.3300, -3.3300,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.5450,   0.0000,  0.0000,  0.0000, -0.5450,  0.0000,  0.0000],\n...     [ 0.0000,   0.0000,  0.0000,  4.9200, -0.04165, 0.0000,  4.9200],\n...     [ 0.0000,   0.0000,  0.0000,  0.0000, -5.2100, -12.500,  0.0000],\n...     [ 0.0000,   0.0000,  0.0000,  0.0000,  0.0000,  3.3300, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [ 0.0000,  0.0000],\n...     [12.500,   0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000, 12.500],\n...     [ 0.0000,  0.0000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> tol = 0.1\n>>> nr_in = 0  # Not used when ordsel='A'\n>>> ar, br, cr, hsv, nr_out, iwarn, info = ab09ad(\n...     'C', 'N', 'N', 'A', n, m, p, nr_in, a, b, c, tol\n...     )\n>>> info\n0",
  "ab09ax": "Balance & Truncate model reduction for stable systems.\n\nComputes a reduced order model (Ar,Br,Cr) using either square-root\nor balancing-free square-root Balance & Truncate method.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  job (str): 'B' for square-root B&T, 'N' for balancing-free B&T\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  a (ndarray): State matrix A in Schur form (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  tol (float): Tolerance for order selection (used if ordsel='A')\n\nReturns:\n  (ar, br, cr, hsv, t, ti, nr, iwarn, info): Reduced system matrices,\n    Hankel singular values, truncation matrices, actual order,\n    warning indicator, and exit code\n\nExamples:\n\n>>> from slicot import ab09ax\n>>> import numpy as np\n>>> n, m, p = 4, 1, 1\n>>> nr = 2\n>>> a = np.array([\n...     [-1.0, 0.0, 0.0, 0.0],\n...     [0.0, -2.0, 0.0, 0.0],\n...     [0.0, 0.0, -3.0, 0.0],\n...     [0.0, 0.0, 0.0, -4.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0],\n...     [1.0],\n...     [1.0],\n...     [1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 1.0, 1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> ar, br, cr, hsv, t, ti, nr_out, iwarn, info = ab09ax(\n...     'C', 'B', 'F', n, m, p, nr, a, b, c, 0.0\n...     )\n>>> info\n0",
  "ab09bd": "SPA model reduction for stable systems.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for a stable original\nstate-space representation (A,B,C,D) using either square-root or\nbalancing-free square-root Singular Perturbation Approximation (SPA).\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  job (str): 'B' for square-root SPA, 'N' for balancing-free SPA\n  equil (str): 'S' to equilibrate (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for minimal realization order\n\nReturns:\n  (ar, br, cr, dr, nr, hsv, iwarn, info):\n    Reduced system matrices, actual order, Hankel singular values,\n    warning indicator, and exit code\n\nExamples:\n\n>>> from slicot import ab09bd\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> a = np.array([\n...     [-0.04165,  0.0000,  4.9200, -4.9200,  0.0000,  0.0000,  0.0000],\n...     [-5.2100, -12.500,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.0000,  3.3300, -3.3300,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.5450,  0.0000,  0.0000,  0.0000, -0.5450,  0.0000,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  4.9200, -0.04165, 0.0000,  4.9200],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000, -5.2100, -12.500,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  3.3300, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [ 0.0000,  0.0000],\n...     [12.500,   0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000, 12.500],\n...     [ 0.0000,  0.0000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> tol1 = 0.1\n>>> tol2 = 1e-14\n>>> nr_in = 0  # ignored for ORDSEL='A'\n>>> ar, br, cr, dr, nr, hsv, iwarn, info = ab09bd(\n...     'C', 'N', 'N', 'A', n, m, p, nr_in, a, b, c, d, tol1, tol2\n...     )\n>>> info\n0",
  "ab09bx": "Compute reduced order model using square-root SPA method.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for a stable original\nstate-space representation (A,B,C,D) using either square-root or\nbalancing-free square-root Singular Perturbation Approximation (SPA).\n\nThe state matrix A must be in real Schur canonical form.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  job (str): 'B' for square-root SPA, 'N' for balancing-free SPA\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  a (ndarray): State matrix A in Schur form (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for minimal realization order\n\nReturns:\n  (ar, br, cr, dr, nr, hsv, t, ti, nmin, iwarn, info):\n    Reduced system matrices, actual order, Hankel singular values,\n    truncation matrices, minimal order, warning, and exit code\n\nExamples:\n\n>>> from slicot import ab09bx\n>>> import numpy as np\n>>> n, m, p = 4, 2, 2\n>>> nr_desired = 2\n>>> a = np.array([\n...     [-2.0,  1.0,  0.0,  0.0],\n...     [ 0.0, -3.0,  0.0,  0.0],\n...     [ 0.0,  0.0, -1.0,  0.5],\n...     [ 0.0,  0.0, -0.5, -1.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 1.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d = np.zeros((p, m), order='F', dtype=float)\n>>> ar, br, cr, dr, nr, hsv, t, ti, nmin, iwarn, info = ab09bx(\n...     'C', 'B', 'F', n, m, p, nr_desired, a, b, c, d, 0.0, 0.0\n...     )\n...     ar_reduced = ar[:nr, :nr]\n...     eigs = np.linalg.eigvals(ar_reduced)\n>>> info\n0",
  "ab09cd": "Optimal Hankel-norm approximation based model reduction for stable systems.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for a stable original\nstate-space representation (A,B,C,D) using the optimal Hankel-norm\napproximation method in conjunction with square-root balancing.\n\nUnlike AB09CX, this routine accepts a general state matrix A (not\nnecessarily in Schur form) and optionally performs equilibration.\n\nError bound: HSV(NR) <= ||G-Gr||_inf <= 2*sum(HSV(NR+1:N))\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  equil (str): 'S' to equilibrate (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for minimal realization order\n\nReturns:\n  (ar, br, cr, dr, nr, hsv, nmin, iwarn, info):\n    Reduced system matrices, actual order, Hankel singular values,\n    minimal order, warning indicator, and exit code\n\nExamples:\n\n>>> from slicot import ab09cd\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> nr_input = 0  # Will be determined by automatic order selection\n>>> a = np.array([\n...     [-0.04165,  0.0000,  4.9200, -4.9200,  0.0000,  0.0000,  0.0000],\n...     [-5.2100, -12.500,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.0000,  3.3300, -3.3300,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.5450,  0.0000,  0.0000,  0.0000, -0.5450,  0.0000,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  4.9200, -0.04165, 0.0000,  4.9200],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000, -5.2100, -12.500,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  3.3300, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [ 0.0000,  0.0000],\n...     [12.500,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000, 12.500],\n...     [ 0.0000,  0.0000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [0.0000,  0.0000,  0.0000,  1.0000,  0.0000,  0.0000,  0.0000],\n...     [0.0000,  0.0000,  0.0000,  0.0000,  1.0000,  0.0000,  0.0000]\n...     ], order='F', dtype=float)\n>>> d = np.zeros((p, m), order='F', dtype=float)\n>>> ar, br, cr, dr, nr, hsv, nmin, iwarn, info = ab09cd(\n...     'C', 'N', 'A', n, m, p, nr_input, a, b, c, d, 0.1, 1e-14\n...     )\n>>> info\n0",
  "ab09cx": "Optimal Hankel-norm approximation model reduction for stable systems.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for a stable original\nstate-space representation (A,B,C,D) using the optimal Hankel-norm\napproximation method in conjunction with square-root balancing.\n\nThe state matrix A must be in real Schur canonical form.\n\nError bound: HSV(NR) <= ||G-Gr||_inf <= 2*sum(HSV(NR+1:N))\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  a (ndarray): State matrix A in Schur form (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for minimal realization order\n\nReturns:\n  (ar, br, cr, dr, nr, hsv, nmin, iwarn, info):\n    Reduced system matrices, actual order, Hankel singular values,\n    minimal order, warning indicator, and exit code\n\nExamples:\n\n>>> from slicot import ab09cx\n>>> import numpy as np\n>>> n, m, p = 4, 2, 2\n>>> nr_desired = 2\n>>> a = np.array([\n...     [-2.0,  1.0,  0.0,  0.0],\n...     [ 0.0, -3.0,  0.0,  0.0],\n...     [ 0.0,  0.0, -1.0,  0.5],\n...     [ 0.0,  0.0, -0.5, -1.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 1.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d = np.zeros((p, m), order='F', dtype=float)\n>>> ar, br, cr, dr, nr, hsv, nmin, iwarn, info = ab09cx(\n...     'C', 'F', n, m, p, nr_desired, a, b, c, d, 0.0, 0.0\n...     )\n...     ar_reduced = ar[:nr, :nr]\n...     eigs = np.linalg.eigvals(ar_reduced)\n>>> info\n0",
  "ab09dd": "Compute reduced order model using singular perturbation approximation.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) of order NR from a\ngiven system (A,B,C,D) using residualization formulas.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Order of reduced system (0 <= nr <= n)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n\nReturns:\n  (ar, br, cr, dr, rcond, info): Reduced system matrices,\n    reciprocal condition number, and exit code\n\nExamples:\n\n>>> from slicot import ab09dd\n>>> import numpy as np\n>>> n, m, p, nr = 7, 2, 3, 5\n>>> a = np.array([\n...     [-0.04165, 4.9200, -4.9200,  0.0,     0.0,      0.0,      0.0],\n...     [ 0.0,    -3.3300,  0.0,     0.0,     0.0,      3.3300,   0.0],\n...     [ 0.5450,  0.0,     0.0,    -0.5450,  0.0,      0.0,      0.0],\n...     [ 0.0,     0.0,     4.9200, -0.04165, 4.9200,   0.0,      0.0],\n...     [ 0.0,     0.0,     0.0,     0.0,    -3.3300,   0.0,      3.3300],\n...     [-5.2100,  0.0,     0.0,     0.0,     0.0,    -12.5000,   0.0],\n...     [ 0.0,     0.0,     0.0,    -5.2100,  0.0,      0.0,    -12.5000]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [ 0.0,     0.0],\n...     [ 0.0,     0.0],\n...     [ 0.0,     0.0],\n...     [ 0.0,     0.0],\n...     [ 0.0,     0.0],\n...     [12.5000,  0.0],\n...     [ 0.0,    12.5000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> ar, br, cr, dr, rcond, info = ab09dd('C', n, m, p, nr, a, b, c, d)\n>>> info\n0",
  "ab09ed": "Optimal Hankel-norm approximation model reduction for unstable systems.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for an original\nstate-space representation (A,B,C,D) using the optimal Hankel-norm\napproximation method in conjunction with square-root balancing for\nthe ALPHA-stable part of the system.\n\nThe system is decomposed as G = G1 + G2 where G1 has ALPHA-stable\npoles and G2 has ALPHA-unstable poles. G1 is reduced using Hankel-norm\napproximation while G2 is kept intact.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  equil (str): 'S' to equilibrate (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  alpha (float): Stability boundary. Continuous: alpha <= 0, Discrete: 0 <= alpha <= 1\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for minimal realization order\n\nReturns:\n  (ar, br, cr, dr, nr, ns, hsv, nmin, iwarn, info):\n    Reduced system matrices, actual order, dimension of stable part,\n    Hankel singular values, minimal order, warning, and exit code\n\nExamples:\n\n>>> from slicot import ab09ed\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> nr_in = 0\n>>> alpha = -0.6\n>>> tol1 = 0.1\n>>> tol2 = 1e-14\n>>> A = np.array([\n...     [-0.04165,  0.0000,  4.9200, -4.9200,  0.0000,  0.0000,  0.0000],\n...     [-5.2100, -12.500,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.0000,  3.3300, -3.3300,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.5450,  0.0000,  0.0000,  0.0000, -0.5450,  0.0000,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  4.9200, -0.04165, 0.0000,  4.9200],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000, -5.2100, -12.500,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  3.3300, -3.3300],\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [ 0.0000,  0.0000],\n...     [12.500,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000, 12.500],\n...     [ 0.0000,  0.0000],\n...     ], order='F', dtype=float)\n>>> C = np.array([\n...     [1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000],\n...     ], order='F', dtype=float)\n>>> D = np.array([\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     ], order='F', dtype=float)\n>>> Ar, Br, Cr, Dr, nr, ns, hsv, nmin, iwarn, info = ab09ed(\n...     'C', 'N', 'A', n, m, p, nr_in, alpha,\n...     A, B, C, D, tol1, tol2\n...     )\n>>> Ar_actual = Ar[:nr, :nr].copy()\n>>> Br_actual = Br[:nr, :m].copy()\n>>> Cr_actual = Cr[:p, :nr].copy()\n...     Br_actual[i, :] *= -1\n...     Cr_actual[:, i] *= -1\n>>> info\n0",
  "ab09fd": "Balance & Truncate model reduction for unstable systems using coprime factorization.\n\nComputes a reduced order model (Ar,Br,Cr) for an original\nstate-space representation (A,B,C) by using either the square-root\nor the balancing-free square-root Balance & Truncate (B&T)\nmodel reduction method in conjunction with stable coprime\nfactorization techniques.\n\nThe algorithm computes a stable coprime factorization of G:\n  G = R^{-1}*Q (left) or G = Q*R^{-1} (right)\nThen applies B&T model reduction to the extended system Ge = (Q,R)\nor Ge = [Q;R], and recovers the reduced system from reduced factors.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  jobcf (str): 'L' for left coprime factorization, 'R' for right\n  fact (str): 'S' for prescribed stability degree, 'I' for inner denominator\n  jobmr (str): 'B' for square-root B&T, 'N' for balancing-free B&T\n  equil (str): 'S' to equilibrate (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  alpha (float): Stability degree. Continuous: alpha < 0, Discrete: 0 <= alpha < 1.\n                 Not used if fact='I'.\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for controllability/observability tests\n\nReturns:\n  (ar, br, cr, nr, nq, hsv, iwarn, info):\n    Reduced system matrices (ar, br, cr), actual order (nr),\n    order of coprime factorization (nq), Hankel singular values (hsv),\n    warning indicator (iwarn), and exit code (info)\n\nExamples:\n\n>>> from slicot import ab09fd\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> a = np.array([\n...     [-0.04165,  0.0000,  4.9200,  0.4920,  0.0000,  0.0000,  0.0000],\n...     [-5.2100, -12.500,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.0000,  3.3300, -3.3300,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.5450,  0.0000,  0.0000,  0.0000,  0.0545,  0.0000,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000, -0.4920,  0.004165, 0.0000,  4.9200],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.5210, -12.500,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  3.3300, -3.3300]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [ 0.0000,  0.0000],\n...     [12.500,   0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000, 12.500],\n...     [ 0.0000,  0.0000]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000]\n...     ], dtype=float, order='F')\n>>> nr = 0\n>>> alpha = -0.1\n>>> tol1 = 0.1\n>>> tol2 = 1e-10\n>>> ar, br, cr, nr_out, nq, hsv, iwarn, info = ab09fd(\n...     'C', 'L', 'I', 'B', 'S', 'A',\n...     n, m, p, nr, alpha, a, b, c, tol1, tol2\n...     )\n>>> info\n0",
  "ab09gd": "SPA model reduction for unstable systems with coprime factorization.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for an original\nstate-space representation (A,B,C,D) by using either the square-root\nor the balancing-free square-root Singular Perturbation Approximation\n(SPA) model reduction method in conjunction with stable coprime\nfactorization techniques.\n\nThe algorithm computes a stable coprime factorization of G:\n  G = R^{-1}*Q (left) or G = Q*R^{-1} (right)\nThen applies SPA model reduction to the extended system Ge = (Q,R)\nor Ge = [Q;R], and recovers the reduced system from reduced factors.\n\nError bound: HSV(NR) <= ||Ge-Ger||_inf <= 2*sum(HSV(NR+1:NQ))\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  jobcf (str): 'L' for left coprime factorization, 'R' for right\n  fact (str): 'S' for prescribed stability degree, 'I' for inner denominator\n  jobmr (str): 'B' for square-root B&T, 'N' for balancing-free B&T\n  equil (str): 'S' to equilibrate (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  alpha (float): Stability degree. Continuous: alpha < 0, Discrete: 0 <= alpha < 1.\n                 Not used if fact='I'.\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for minimal realization order\n  tol3 (float): Tolerance for controllability/observability tests\n\nReturns:\n  (ar, br, cr, dr, nr, nq, hsv, iwarn, info):\n    Reduced system matrices (ar, br, cr, dr), actual order (nr),\n    order of extended system (nq), Hankel singular values (hsv),\n    warning indicator (iwarn), and exit code (info)\n\nExamples:\n\n>>> from slicot import ab09gd\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> nr = 0\n>>> alpha = -0.1\n>>> tol1 = 0.1\n>>> tol2 = 1e-10\n>>> tol3 = 1e-10\n>>> a = np.array([\n...     [-0.04165, 0.0000, 4.9200, 0.4920, 0.0000, 0.0000, 0.0000],\n...     [-5.2100, -12.500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 3.3300, -3.3300, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.5450, 0.0000, 0.0000, 0.0000, 0.0545, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, -0.49200, 0.004165, 0.0000, 4.9200],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 0.5210, -12.500, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 3.3300, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0000, 0.0000],\n...     [12.500, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 12.500],\n...     [0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> ar, br, cr, dr, nr_out, nq, hsv, iwarn, info = ab09gd(\n...     'C', 'L', 'I', 'B', 'S', 'A', n, m, p, nr, alpha,\n...     a, b, c, d, tol1, tol2, tol3\n...     )\n>>> ar_reduced = ar[:nr_out, :nr_out]\n>>> eig_ar = np.linalg.eigvals(ar_reduced)\n>>> br_reduced = br[:nr_out, :m]\n>>> cr_reduced = cr[:p, :nr_out]\n>>> dr_reduced = dr[:p, :m]\n>>> info\n0",
  "ab09hd": "Stochastic balancing based model reduction.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for an original\nstate-space representation (A,B,C,D) using the stochastic balancing\napproach in conjunction with Balance & Truncate or Singular Perturbation\nApproximation methods for the ALPHA-stable part of the system.\n\nIf BETA > 0, model reduction is performed on [G BETA*I] instead of G,\nproviding a balance between absolute and relative error minimization.\nBETA = 0 is pure relative error (requires rank(D) = P).\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  job (str): 'B' square-root B&T, 'F' balancing-free B&T,\n             'S' square-root SPA, 'P' balancing-free SPA\n  equil (str): 'S' to equilibrate (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0, p <= m if beta=0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  alpha (float): Stability boundary. Continuous: alpha <= 0, Discrete: 0 <= alpha <= 1\n  beta (float): Error weighting (beta >= 0). Large=absolute error, small=relative error\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for minimal realization order\n\nReturns:\n  (ar, br, cr, dr, nr, ns, hsv, iwarn, info):\n    Reduced system matrices, actual order, dimension of stable part,\n    Hankel singular values of phase system, warning, and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab09hd\n>>> n, m, p = 7, 2, 3\n>>> a = np.array([\n...     [-0.04165,  0.0000,  4.9200, -4.9200,  0.0000,  0.0000,  0.0000],\n...     [-5.2100, -12.500,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.0000,  3.3300, -3.3300,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.5450,  0.0000,  0.0000,  0.0000, -0.5450,  0.0000,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  4.9200, -0.04165, 0.0000,  4.9200],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000, -5.2100, -12.500,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  3.3300, -3.3300],\n...     ], order='F', dtype=np.float64)\n>>> b = np.array([\n...     [ 0.0000,  0.0000],\n...     [12.500,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000, 12.500],\n...     [ 0.0000,  0.0000],\n...     ], order='F', dtype=np.float64)\n>>> c = np.array([\n...     [1.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [0.0000,  0.0000,  0.0000,  1.0000,  0.0000,  0.0000,  0.0000],\n...     [0.0000,  0.0000,  0.0000,  0.0000,  1.0000,  0.0000,  0.0000],\n...     ], order='F', dtype=np.float64)\n>>> d = np.array([\n...     [0.0000,  0.0000],\n...     [0.0000,  0.0000],\n...     [0.0000,  0.0000],\n...     ], order='F', dtype=np.float64)\n>>> nr_in = 0\n>>> alpha = 0.0\n>>> beta = 1.0\n>>> tol1 = 0.1\n>>> tol2 = 0.0\n>>> ar, br, cr, dr, nr_out, ns, hsv, iwarn, info = ab09hd(\n...     'C', 'F', 'N', 'A', n, m, p, nr_in, alpha, beta,\n...     a, b, c, d, tol1, tol2\n...     )\n>>> eig_computed = np.linalg.eigvals(ar[:nr_out, :nr_out])\n>>> def sort_key(ev):\n...     return (ev.real, ev.imag)\n>>> eig_computed_sorted = np.array(sorted(eig_computed, key=sort_key))\n>>> info\n0",
  "ab09hx": "Stochastic balancing model reduction for stable systems.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for an original stable\nstate-space representation (A,B,C,D) using the stochastic balancing\napproach with Balance & Truncate (B&T) or Singular Perturbation\nApproximation (SPA) methods.\n\nThe state dynamics matrix A must be in real Schur canonical form and\nD must have full row rank.\n\nFor B&T: Ar = TI * A * T, Br = TI * B, Cr = C * T\nFor SPA: Am = TI * A * T, Bm = TI * B, Cm = C * T, then SPA applied\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  job (str): 'B' square-root B&T, 'F' balancing-free B&T,\n             'S' square-root SPA, 'P' balancing-free SPA\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (m >= p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  a (ndarray): State matrix A in Schur form (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D with full row rank (p x m, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for minimal realization order\n\nReturns:\n  (ar, br, cr, dr, nr, hsv, t, ti, nmin, rcond, iwarn, info):\n    - ar, br, cr, dr: Reduced system matrices\n    - nr: Actual order of reduced model\n    - hsv: Hankel singular values of phase system (decreasing order, <= 1)\n    - t: N-by-NR right truncation matrix\n    - ti: NR-by-N left truncation matrix\n    - nmin: Order of minimal realization\n    - rcond: Reciprocal condition number of Riccati solver\n    - iwarn: Warning (0=ok, 1=nr > nmin)\n    - info: Exit code (0=success, 1=A not stable/Schur, 2-5=Hamiltonian errors, 6=D rank deficient, 7=SVD failed)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab09hx\n>>> n, m, p = 4, 2, 2\n>>> a = np.diag([-1.0, -2.0, -3.0, -4.0]).astype(float, order='F')\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.5, 0.5],\n...     [0.0, 1.0],\n...     [0.2, 0.3]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.5, 0.2, 0.1],\n...     [0.0, 1.0, 0.5, 0.2]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> nr_in = 0\n>>> tol1 = 1e-3\n>>> tol2 = 0.0\n>>> ar, br, cr, dr, nr_out, hsv, t, ti, nmin, rcond, iwarn, info = ab09hx(\n...     'C', 'B', 'A', n, m, p, nr_in, a, b, c, d, tol1, tol2\n...     )\n>>> info\n0",
  "ab09hy": "Cholesky factors of controllability and observability Grammians.\n\nComputes Cholesky factors Su and Ru of the controllability Grammian\nP = Su*Su' and observability Grammian Q = Ru'*Ru satisfying:\n  A*P + P*A' + scalec^2*B*B' = 0 (controllability Lyapunov)\n  A'*Q + Q*A + scaleo^2*Cw'*Cw = 0 (observability Lyapunov)\nwhere Cw = Hw - Bw'*X is modified output matrix.\n\nMatrix A must be stable (continuous-time) and in real Schur form.\nMatrix D must have full row rank (requires m >= p).\n\nParameters:\n  n (int): Order of state-space representation (n >= 0)\n  m (int): Number of system inputs (m >= 0)\n  p (int): Number of system outputs (0 <= p <= m)\n  a (ndarray): N-by-N stable state matrix in real Schur form (F-order)\n  b (ndarray): N-by-M input matrix (F-order)\n  c (ndarray): P-by-N output matrix (F-order)\n  d (ndarray): P-by-M feedthrough matrix with full row rank (F-order)\n\nReturns:\n  (s, r, scalec, scaleo, rcond, info):\n    - s: N-by-N upper triangular Cholesky factor Su (P = Su*Su')\n    - r: N-by-N upper triangular Cholesky factor Ru (Q = Ru'*Ru)\n    - scalec: Scaling factor for controllability Grammian\n    - scaleo: Scaling factor for observability Grammian\n    - rcond: Reciprocal condition number of Riccati solver\n    - info: Exit code (0=success, 1=A unstable, 2-5=Riccati failed, 6=D rank deficient)\n\nExamples:\n\n>>> from slicot import ab09hy\n>>> import numpy as np\n>>> n, m, p = 3, 2, 1\n>>> a = np.diag([-1.0, -2.0, -3.0]).astype(float, order='F')\n>>> b = np.array([\n...     [1.0, 0.5],\n...     [0.5, 1.0],\n...     [0.3, 0.7]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.5, 0.3]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [1.0, 0.5]\n...     ], order='F', dtype=float)\n>>> s, r, scalec, scaleo, rcond, info = ab09hy(n, m, p, a, b, c, d)\n>>> s_upper = np.triu(s)\n>>> r_upper = np.triu(r)\n>>> p_computed = s_upper @ s_upper.T\n>>> q_computed = r_upper.T @ r_upper\n>>> p_eigvals = np.linalg.eigvalsh(p_computed)\n>>> q_eigvals = np.linalg.eigvalsh(q_computed)\n>>> info\n0",
  "ab09id": "Frequency-weighted model reduction based on balancing techniques.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for an original\nstate-space representation (A,B,C,D) using frequency weighted\nsquare-root or balancing-free square-root Balance & Truncate (B&T)\nor Singular Perturbation Approximation (SPA) methods.\n\nThe algorithm minimizes ||V*(G-Gr)*W|| where G and Gr are the\ntransfer-function matrices of original and reduced systems,\nand V, W are frequency weighting transfer-function matrices.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  jobc (str): 'S' standard combination, 'E' enhanced stability\n  jobo (str): 'S' standard combination, 'E' enhanced stability\n  job (str): 'B' sqrt B&T, 'F' balfree B&T, 'S' sqrt SPA, 'P' balfree SPA\n  weight (str): 'N' no weight, 'L' left V, 'R' right W, 'B' both\n  equil (str): 'S' scale (A,B,C), 'N' no scaling\n  ordsel (str): 'F' fixed order, 'A' automatic\n  n (int): Order of G (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nv (int): Order of left weight V (nv >= 0)\n  pv (int): Number of outputs of V (pv >= 0)\n  nw (int): Order of right weight W (nw >= 0)\n  mw (int): Number of inputs of W (mw >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  alpha (float): Stability boundary\n  alphac (float): Combination parameter for controllability (|alphac|<=1)\n  alphao (float): Combination parameter for observability (|alphao|<=1)\n  a, b, c, d (ndarray): State-space matrices of G (F-order)\n  av, bv, cv, dv (ndarray): State-space matrices of V (F-order)\n  aw, bw, cw, dw (ndarray): State-space matrices of W (F-order)\n  tol1 (float): Tolerance for order selection\n  tol2 (float): Tolerance for minimal realization\n\nReturns:\n  (ar, br, cr, dr, av, bv, cv, aw, bw, cw, ns, hsv, nr, iwarn, info):\n    Reduced system matrices, transformed weight matrices, stable order,\n    Hankel singular values, actual order, warning, and error code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab09id\n>>> n, m, p = 3, 1, 1\n>>> nv, pv = 6, 1\n>>> nw, mw = 0, 0\n>>> a = np.array([\n...     [-26.4000,  6.4023,  4.3868],\n...     [ 32.0000,  0.0,     0.0   ],\n...     [  0.0,     8.0000,  0.0   ]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [16.0],\n...     [ 0.0],\n...     [ 0.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [9.2994, 1.1624, 0.1090]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> av = np.array([\n...     [-1.0,  0.0,  4.0, -9.2994, -1.1624, -0.1090],\n...     [ 0.0,  2.0,  0.0, -9.2994, -1.1624, -0.1090],\n...     [ 0.0,  0.0, -3.0, -9.2994, -1.1624, -0.1090],\n...     [16.0, 16.0, 16.0, -26.4000, 6.4023,  4.3868],\n...     [ 0.0,  0.0,  0.0,  32.0000, 0.0,     0.0   ],\n...     [ 0.0,  0.0,  0.0,   0.0,    8.0000,  0.0   ]\n...     ], order='F', dtype=float)\n>>> bv = np.array([\n...     [1.0],\n...     [1.0],\n...     [1.0],\n...     [0.0],\n...     [0.0],\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> cv = np.array([\n...     [1.0, 1.0, 1.0, 0.0, 0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> dv = np.array([\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> aw = np.zeros((1, 1), order='F', dtype=float)\n>>> bw = np.zeros((1, 1), order='F', dtype=float)\n>>> cw = np.zeros((1, 1), order='F', dtype=float)\n>>> dw = np.zeros((1, 1), order='F', dtype=float)\n>>> nr = 2\n>>> alpha = 0.0\n>>> alphac = 0.0\n>>> alphao = 0.0\n>>> tol1 = 0.1\n>>> tol2 = 0.0\n>>> (a_out, b_out, c_out, d_out, av_out, bv_out, cv_out,\n...     aw_out, bw_out, cw_out, ns, hsv, nr_out, iwarn, info) = ab09id(\n...     'C', 'S', 'S', 'F', 'L', 'S', 'F',\n...     n, m, p, nv, pv, nw, mw, nr, alpha, alphac, alphao,\n...     a, b, c, d, av, bv, cv, dv, aw, bw, cw, dw, tol1, tol2\n...     )\n...     err_msg=\"Hankel singular values mismatch\")\n>>> ar_actual = a_out[:nr_out, :nr_out].copy()\n>>> br_actual = b_out[:nr_out, :m].copy()\n>>> cr_actual = c_out[:p, :nr_out].copy()\n>>> dr_actual = d_out[:p, :m].copy()\n...     err_msg=\"Reduced A matrix mismatch\")\n...     err_msg=\"Reduced B matrix mismatch\")\n...     err_msg=\"Reduced C matrix mismatch\")\n...     err_msg=\"Reduced D matrix mismatch\")",
  "ab09ix": "Accuracy enhanced balancing related model reduction.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for an original\nstate-space representation (A,B,C,D) using square-root or\nbalancing-free square-root Balance & Truncate (B&T) or\nSingular Perturbation Approximation (SPA) methods.\n\nThe computation uses Cholesky factors S and R of controllability\nand observability Grammians. Hankel singular values are computed\nas singular values of R*S.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  job (str): 'B' square-root B&T, 'F' balancing-free B&T,\n             'S' square-root SPA, 'P' balancing-free SPA\n  fact (str): 'S' if A is in Schur form, 'N' if general matrix\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  scalec (float): Scaling for controllability Cholesky factor (> 0)\n  scaleo (float): Scaling for observability Cholesky factor (> 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  ti (ndarray): Upper triangular Cholesky factor S (n x n, F-order)\n  t (ndarray): Upper triangular Cholesky factor R (n x n, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for minimal realization order\n\nReturns:\n  (ar, br, cr, dr, ti, t, nr, nminr, hsv, iwarn, info):\n    Reduced system matrices, truncation matrices, actual order,\n    minimal realization order, Hankel singular values,\n    warning indicator, and exit code\n\nExamples:\n\n>>> from slicot import ab09ix\n>>> import numpy as np\n>>> n, m, p = 4, 1, 1\n>>> a = np.array([\n...     [-1.0,  0.1,  0.0,  0.0],\n...     [ 0.0, -2.0,  0.1,  0.0],\n...     [ 0.0,  0.0, -3.0,  0.1],\n...     [ 0.0,  0.0,  0.0, -4.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0],\n...     [0.0],\n...     [0.0],\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [0.0, 0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> ti = np.array([\n...     [0.7071, 0.0, 0.0, 0.0],\n...     [0.0, 0.5, 0.0, 0.0],\n...     [0.0, 0.0, 0.4082, 0.0],\n...     [0.0, 0.0, 0.0, 0.3536]\n...     ], order='F', dtype=float)\n>>> t = np.array([\n...     [0.7071, 0.0, 0.0, 0.0],\n...     [0.0, 0.5, 0.0, 0.0],\n...     [0.0, 0.0, 0.4082, 0.0],\n...     [0.0, 0.0, 0.0, 0.3536]\n...     ], order='F', dtype=float)\n>>> scalec = 1.0\n>>> scaleo = 1.0\n>>> nr_in = 2\n>>> tol1 = 0.0\n>>> tol2 = 0.0\n>>> ar, br, cr, dr, ti_out, t_out, nr, nminr, hsv, iwarn, info = ab09ix(\n...     'C', 'B', 'N', 'F', n, m, p, nr_in, scalec, scaleo,\n...     a, b, c, d, ti, t, tol1, tol2\n...     )\n>>> info\n0",
  "ab09iy": "Cholesky factors of frequency-weighted controllability/observability Grammians.\n\nComputes the Cholesky factors S and R of the frequency-weighted\ncontrollability Grammian P = S*S' and observability Grammian Q = R'*R\nfor model reduction with frequency weighting using V*G*W.\n\nG, V and W must be stable with state matrices A, AV, AW in real Schur form.\nThe combination method of Enns and Lin-Chiu is used.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  jobc (str): 'S' standard combination, 'N' stability enhanced\n  jobo (str): 'S' standard combination, 'N' stability enhanced\n  weight (str): 'N' no weights, 'L' left V, 'R' right W, 'B' both\n  n (int): Order of G (n >= 0)\n  m (int): Number of G inputs (m >= 0)\n  p (int): Number of G outputs (p >= 0)\n  nv (int): Order of V (nv >= 0)\n  pv (int): Number of V outputs (pv >= 0)\n  nw (int): Order of W (nw >= 0)\n  mw (int): Number of W inputs (mw >= 0)\n  alphac (float): Combination parameter for controllability (0 < alphac <= 1)\n  alphao (float): Combination parameter for observability (0 < alphao <= 1)\n  a (ndarray): N-by-N state matrix of G in Schur form (F-order)\n  b (ndarray): N-by-M input matrix of G (F-order)\n  c (ndarray): P-by-N output matrix of G (F-order)\n  av (ndarray): NV-by-NV state matrix of V (F-order)\n  bv (ndarray): NV-by-P input matrix of V (F-order)\n  cv (ndarray): PV-by-NV output matrix of V (F-order)\n  dv (ndarray): PV-by-P feedthrough matrix of V (F-order)\n  aw (ndarray): NW-by-NW state matrix of W (F-order)\n  bw (ndarray): NW-by-MW input matrix of W (F-order)\n  cw (ndarray): M-by-NW output matrix of W (F-order)\n  dw (ndarray): M-by-MW feedthrough matrix of W (F-order)\n\nReturns:\n  (s, r, scalec, scaleo, info):\n    - s: N-by-N upper triangular Cholesky factor (P = S*S')\n    - r: N-by-N upper triangular Cholesky factor (Q = R'*R)\n    - scalec: Scaling factor for controllability Grammian\n    - scaleo: Scaling factor for observability Grammian\n    - info: Exit code (0=success, 1=A unstable, 2=Lyapunov failed)\n\nExamples:\n\n>>> from slicot import ab09iy\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> nv, pv = 0, 0\n>>> nw, mw = 0, 0\n>>> a = np.diag([-1.0, -2.0, -3.0]).astype(float, order='F')\n>>> b = np.array([\n...     [1.0, 0.5],\n...     [0.5, 1.0],\n...     [0.3, 0.7]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.5, 0.3],\n...     [0.2, 1.0, 0.6]\n...     ], order='F', dtype=float)\n>>> av = np.zeros((0, 0), order='F', dtype=float)\n>>> bv = np.zeros((0, m), order='F', dtype=float)\n>>> cv = np.zeros((pv, 0), order='F', dtype=float)\n>>> dv = np.zeros((pv, m), order='F', dtype=float)\n>>> aw = np.zeros((0, 0), order='F', dtype=float)\n>>> bw = np.zeros((0, mw), order='F', dtype=float)\n>>> cw = np.zeros((p, 0), order='F', dtype=float)\n>>> dw = np.zeros((p, mw), order='F', dtype=float)\n>>> s, r, scalec, scaleo, info = ab09iy(\n...     'C', 'N', 'N', 'N',\n...     n, m, p, nv, pv, nw, mw,\n...     1.0, 1.0,\n...     a, b, c,\n...     av, bv, cv, dv,\n...     aw, bw, cw, dw\n...     )\n>>> p_gram = s @ s.T\n>>> q_gram = r.T @ r\n>>> p_eigvals = np.linalg.eigvalsh(p_gram)\n>>> q_eigvals = np.linalg.eigvalsh(q_gram)\n>>> info\n0",
  "ab09jd": "Frequency-weighted Hankel-norm approximation with invertible weights.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) using frequency weighted\noptimal Hankel-norm approximation with invertible transfer-function\nweights V and W.\n\nMinimizes ||op(V)*(G-Gr)*op(W)||_H where op(X) can be X, inv(X),\nconj(X), or conj(inv(X)).\n\nWeight stability requirements:\n- op(V)=V or op(W)=W: antistable weights\n- op(V)=inv(V) or op(W)=inv(W): antistable zeros\n- op(V)=conj(V) or op(W)=conj(W): stable weights\n- op(V)=conj(inv(V)) or op(W)=conj(inv(W)): minimum-phase\n\nParameters:\n  jobv (str): 'N' V=I, 'V' op(V)=V, 'I' inv(V), 'C' conj(V), 'R' conj(inv(V))\n  jobw (str): 'N' W=I, 'W' op(W)=W, 'I' inv(W), 'C' conj(W), 'R' conj(inv(W))\n  jobinv (str): 'N' inverse-free, 'I' inversion-based, 'A' auto-switch\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  equil (str): 'S' to equilibrate (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of G (n >= 0)\n  nv (int): Order of left weight V (nv >= 0)\n  nw (int): Order of right weight W (nw >= 0)\n  m (int): Number of G inputs (m >= 0)\n  p (int): Number of G outputs (p >= 0)\n  nr (int): Desired reduced order if ordsel='F' (0 <= nr <= n)\n  alpha (float): Stability boundary (continuous: alpha <= 0, discrete: 0 <= alpha <= 1)\n  a (ndarray): N-by-N state matrix of G (F-order)\n  b (ndarray): N-by-M input matrix of G (F-order)\n  c (ndarray): P-by-N output matrix of G (F-order)\n  d (ndarray): P-by-M feedthrough matrix of G (F-order)\n  av (ndarray): NV-by-NV state matrix of V (F-order)\n  bv (ndarray): NV-by-P input matrix of V (F-order)\n  cv (ndarray): P-by-NV output matrix of V (F-order)\n  dv (ndarray): P-by-P feedthrough matrix of V (F-order)\n  aw (ndarray): NW-by-NW state matrix of W (F-order)\n  bw (ndarray): NW-by-M input matrix of W (F-order)\n  cw (ndarray): M-by-NW output matrix of W (F-order)\n  dw (ndarray): M-by-M feedthrough matrix of W (F-order)\n  tol1 (float): Tolerance for order selection (ordsel='A')\n  tol2 (float): Tolerance for minimal realization\n\nReturns:\n  (ar, br, cr, dr, av, bv, cv, aw, bw, cw, nr, ns, hsv, iwarn, info):\n    - ar, br, cr, dr: Reduced system matrices\n    - av, bv, cv: Transformed V matrices\n    - aw, bw, cw: Transformed W matrices\n    - nr: Actual reduced order\n    - ns: Dimension of stable subsystem\n    - hsv: Hankel singular values of stable part\n    - iwarn: Warning (0=ok, 1=nr>nsmin, 2=nr<nu)\n    - info: Error code (0=success, 1-21 various failures)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab09jd\n>>> n, m, p = 6, 1, 1\n>>> nv, nw = 2, 0\n>>> a = np.array([\n...     [-3.8637, -7.4641, -9.1416, -7.4641, -3.8637, -1.0000],\n...     [ 1.0000,  0.0,     0.0,     0.0,     0.0,     0.0   ],\n...     [ 0.0,     1.0000,  0.0,     0.0,     0.0,     0.0   ],\n...     [ 0.0,     0.0,     1.0000,  0.0,     0.0,     0.0   ],\n...     [ 0.0,     0.0,     0.0,     1.0000,  0.0,     0.0   ],\n...     [ 0.0,     0.0,     0.0,     0.0,     1.0000,  0.0   ]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0],\n...     [0.0],\n...     [0.0],\n...     [0.0],\n...     [0.0],\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> av = np.array([\n...     [0.2, -1.0],\n...     [1.0,  0.0]\n...     ], order='F', dtype=float)\n>>> bv = np.array([\n...     [1.0],\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> cv = np.array([\n...     [-1.8, 0.0]\n...     ], order='F', dtype=float)\n>>> dv = np.array([\n...     [1.0]\n...     ], order='F', dtype=float)\n>>> aw = np.zeros((1, 1), order='F', dtype=float)\n>>> bw = np.zeros((1, m), order='F', dtype=float)\n>>> cw = np.zeros((m, 1), order='F', dtype=float)\n>>> dw = np.zeros((m, m), order='F', dtype=float)\n>>> nr = 0\n>>> alpha = 0.0\n>>> tol1 = 0.1\n>>> tol2 = 1e-14\n>>> (a_out, b_out, c_out, d_out, av_out, bv_out, cv_out,\n...     aw_out, bw_out, cw_out, nr_out, ns, hsv, iwarn, info) = ab09jd(\n...     'V', 'N', 'I', 'C', 'S', 'A', n, nv, nw, m, p, nr, alpha,\n...     a, b, c, d, av, bv, cv, dv, aw, bw, cw, dw, tol1, tol2\n...     )\n...     err_msg=\"Hankel singular values mismatch\")\n>>> ar_actual = a_out[:nr_out, :nr_out].copy()\n>>> br_actual = b_out[:nr_out, :m].copy()\n>>> cr_actual = c_out[:p, :nr_out].copy()\n>>> ar_actual = np.abs(ar_actual)\n...     err_msg=\"Reduced A matrix mismatch\")\n>>> br_actual = np.abs(br_actual)\n...     err_msg=\"Reduced B matrix mismatch\")\n>>> cr_actual = np.abs(cr_actual)\n...     err_msg=\"Reduced C matrix mismatch\")\n...     err_msg=\"Reduced D matrix mismatch\")",
  "ab09jv": "Construct projection containing poles of G.\n\nConstructs the state-space representation for the projection of\nV*G or conj(V)*G containing the poles of the transfer-function\nmatrix G, where V is a stable transfer-function matrix.\n\nUsed in coprime factorization-based model reduction algorithms.\n\nParameters:\n  job (str): 'V' for V*G, 'C' for conj(V)*G\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  jobev (str): 'G' for general EV, 'I' for identity EV\n  stbchk (str): 'C' to check stability of AV, 'N' to skip check\n  n (int): Order of system G (n >= 0)\n  m (int): Number of inputs of G (m >= 0)\n  p (int): Number of outputs of G (p >= 0)\n  nv (int): Order of weight V (nv >= 0)\n  pv (int): Number of rows of CV = number of inputs of V\n  a (ndarray): State matrix A of G (n x n, F-order)\n  b (ndarray): Input matrix B of G (n x m, F-order)\n  c (ndarray): Output matrix C of G (p x n, F-order), modified on exit\n  d (ndarray): Feedthrough matrix D of G (p x m, F-order), modified on exit\n  av (ndarray): State matrix AV of V (nv x nv, F-order), modified on exit\n  ev (ndarray): Descriptor matrix EV of V (nv x nv, F-order), modified on exit\n  bv (ndarray): Input matrix BV of V (nv x pv, F-order), modified on exit\n  cv (ndarray): Output matrix CV of V (pv x nv, F-order), modified on exit\n  dv (ndarray): Feedthrough matrix DV of V (pv x p, F-order)\n\nReturns:\n  (c, d, av, ev, bv, cv, info):\n    Modified system matrices and exit code.\n    info=0: success\n    info=1: AV not stable (when STBCHK='C')\n    info=2: pencil (AV,EV) not in generalized Schur form\n    info=3: Sylvester equation singular\n\nExamples:\n\n>>> from slicot import ab09jv\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> nv, pv = 0, p\n>>> a = np.array([\n...     [-1.0, 0.5, 0.0],\n...     [0.0, -2.0, 0.3],\n...     [0.0, 0.0, -3.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [0.5, 0.5]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.5]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0, 0.0],\n...     [0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> av = np.zeros((1, 1), order='F', dtype=float)\n>>> ev = np.zeros((1, 1), order='F', dtype=float)\n>>> bv = np.zeros((1, p), order='F', dtype=float)\n>>> cv = np.zeros((pv, 1), order='F', dtype=float)\n>>> dv = np.eye(pv, p, order='F', dtype=float)\n>>> c_out, d_out, av_out, ev_out, bv_out, cv_out, info = ab09jv(\n...     'V', 'C', 'I', 'N', n, m, p, nv, pv,\n...     a, b, c, d, av, ev, bv, cv, dv\n...     )\n>>> info\n0",
  "ab09jw": "Construct projection of G*W or G*conj(W) containing poles of G.\n\nConstructs the state-space representation for the projection of\nG*W or G*conj(W) containing the poles of the transfer-function\nmatrix G, where W is a right-side weight transfer-function matrix.\n\nUsed in coprime factorization-based model reduction algorithms.\n\nParameters:\n  job (str): 'W' for G*W, 'C' for G*conj(W)\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  jobew (str): 'G' for general EW, 'I' for identity EW\n  stbchk (str): 'C' to check stability of AW, 'N' to skip check\n  n (int): Order of system G (n >= 0)\n  m (int): Number of inputs of G (m >= 0)\n  p (int): Number of outputs of G (p >= 0)\n  nw (int): Order of weight W (nw >= 0)\n  mw (int): Number of inputs (job='W') or outputs (job='C') of W\n  a (ndarray): State matrix A of G (n x n, F-order)\n  b (ndarray): Input matrix B of G (n x m, F-order), modified on exit\n  c (ndarray): Output matrix C of G (p x n, F-order)\n  d (ndarray): Feedthrough matrix D of G (p x m, F-order), modified on exit\n  aw (ndarray): State matrix AW of W (nw x nw, F-order), modified on exit\n  ew (ndarray): Descriptor matrix EW of W (nw x nw, F-order), modified on exit\n  bw (ndarray): Input matrix BW of W (nw x mbw, F-order), modified on exit\n  cw (ndarray): Output matrix CW of W (pcw x nw, F-order), modified on exit\n  dw (ndarray): Feedthrough matrix DW of W (pcw x mbw, F-order)\n\nReturns:\n  (b, d, aw, ew, bw, cw, info):\n    Modified system matrices and exit code.\n    info=0: success\n    info=1: Schur form reduction failed\n    info=2: Sylvester equation (generalized) singular\n    info=3: Sylvester equation (standard) singular\n    info=4: stability/antistability check failed\n\nExamples:\n\n>>> from slicot import ab09jw\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> nw, mw = 0, m\n>>> a = np.array([\n...     [-1.0, 0.5, 0.0],\n...     [0.0, -2.0, 0.3],\n...     [0.0, 0.0, -3.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [0.5, 0.5]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.5]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0, 0.0],\n...     [0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> aw = np.zeros((1, 1), order='F', dtype=float)\n>>> ew = np.zeros((1, 1), order='F', dtype=float)\n>>> bw = np.zeros((1, mw), order='F', dtype=float)\n>>> cw = np.zeros((m, 1), order='F', dtype=float)\n>>> dw = np.eye(m, mw, order='F', dtype=float)\n>>> b_out, d_out, aw_out, ew_out, bw_out, cw_out, info = ab09jw(\n...     'W', 'C', 'I', 'N', n, m, p, nw, mw,\n...     a, b, c, d, aw, ew, bw, cw, dw\n...     )\n>>> info\n0",
  "ab09jx": "Check stability/antistability of finite eigenvalues.\n\nChecks whether all finite eigenvalues lie within a specified\nstability domain defined by DICO, STDOM, and ALPHA.\n\nDomain definitions:\n- Continuous stable: Re(lambda) < ALPHA\n- Continuous unstable: Re(lambda) > ALPHA\n- Discrete stable: |lambda| < ALPHA\n- Discrete unstable: |lambda| > ALPHA\n\nFor EVTYPE='R', conditions apply to 1/lambda.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  stdom (str): 'S' for stability domain, 'U' for instability domain\n  evtype (str): 'S' standard (ED=1), 'G' generalized, 'R' reciprocal\n  n (int): Dimension of eigenvalue vectors (n >= 0)\n  alpha (float): Boundary value for real parts or moduli\n  er (ndarray): Real parts of eigenvalues, dimension (n)\n  ei (ndarray): Imaginary parts of eigenvalues, dimension (n)\n  ed (ndarray): Denominators for generalized eigenvalues, dimension (n)\n  tolinf (float): Tolerance for infinite eigenvalue detection (0 <= tolinf < 1)\n\nReturns:\n  info: 0 if all in domain, 1 if some outside, -i if param i invalid\n\nExamples:\n\n>>> from slicot import ab09jx\n>>> import numpy as np\n>>> n = 3\n>>> er = np.array([-1.0, -2.0, -3.0], order='F', dtype=float)\n>>> ei = np.array([0.0, 0.0, 0.0], order='F', dtype=float)\n>>> ed = np.array([1.0, 1.0, 1.0], order='F', dtype=float)\n>>> alpha = 0.0\n>>> tolinf = 1e-10\n>>> info = ab09jx('C', 'S', 'S', n, alpha, er, ei, ed, tolinf)\n>>> info\n0",
  "ab09kd": "Frequency-weighted Hankel-norm approximation model reduction.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for an original\nstate-space representation (A,B,C,D) using frequency weighted\noptimal Hankel-norm approximation.\n\nMinimizes ||V*(G-Gr)*W||_H or ||conj(V)*(G-Gr)*conj(W)||_H.\n\nFor JOB='N': V and W must be antistable.\nFor JOB='C': V and W must be stable.\nDV and DW must be invertible.\n\nParameters:\n  job (str): 'N' for ||V*(G-Gr)*W||_H, 'C' for ||conj(V)*(G-Gr)*conj(W)||_H\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  weight (str): 'N' no weights, 'L' left only, 'R' right only, 'B' both\n  equil (str): 'S' to equilibrate (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of G (n >= 0)\n  nv (int): Order of left weight V (nv >= 0)\n  nw (int): Order of right weight W (nw >= 0)\n  m (int): Number of G inputs (m >= 0)\n  p (int): Number of G outputs (p >= 0)\n  nr (int): Desired reduced order if ordsel='F' (0 <= nr <= n)\n  alpha (float): Stability boundary (continuous: alpha <= 0, discrete: 0 <= alpha <= 1)\n  a (ndarray): N-by-N state matrix of G (F-order)\n  b (ndarray): N-by-M input matrix of G (F-order)\n  c (ndarray): P-by-N output matrix of G (F-order)\n  d (ndarray): P-by-M feedthrough matrix of G (F-order)\n  av (ndarray): NV-by-NV state matrix of V (F-order)\n  bv (ndarray): NV-by-P input matrix of V (F-order)\n  cv (ndarray): P-by-NV output matrix of V (F-order)\n  dv (ndarray): P-by-P feedthrough matrix of V (F-order)\n  aw (ndarray): NW-by-NW state matrix of W (F-order)\n  bw (ndarray): NW-by-M input matrix of W (F-order)\n  cw (ndarray): M-by-NW output matrix of W (F-order)\n  dw (ndarray): M-by-M feedthrough matrix of W (F-order)\n  tol1 (float): Tolerance for order selection (ordsel='A')\n  tol2 (float): Tolerance for minimal realization\n\nReturns:\n  (ar, br, cr, dr, av, bv, cv, aw, bw, cw, nr, ns, hsv, iwarn, info):\n    - ar, br, cr, dr: Reduced system matrices\n    - av, bv, cv: Transformed V matrices (inverse of V)\n    - aw, bw, cw: Transformed W matrices (inverse of W)\n    - nr: Actual reduced order\n    - ns: Dimension of stable subsystem\n    - hsv: Hankel singular values of stable part\n    - iwarn: Warning (0=ok, 1=nr>nsmin, 2=nr<nu)\n    - info: Error code (0=success, 1-13 various failures)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab09kd\n>>> n, m, p = 6, 1, 1\n>>> nv, nw = 2, 0\n>>> a = np.array([\n...     [-3.8637, -7.4641, -9.1416, -7.4641, -3.8637, -1.0000],\n...     [ 1.0000,  0.0,     0.0,     0.0,     0.0,     0.0   ],\n...     [ 0.0,     1.0000,  0.0,     0.0,     0.0,     0.0   ],\n...     [ 0.0,     0.0,     1.0000,  0.0,     0.0,     0.0   ],\n...     [ 0.0,     0.0,     0.0,     1.0000,  0.0,     0.0   ],\n...     [ 0.0,     0.0,     0.0,     0.0,     1.0000,  0.0   ]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0],\n...     [0.0],\n...     [0.0],\n...     [0.0],\n...     [0.0],\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> av = np.array([\n...     [0.2, -1.0],\n...     [1.0,  0.0]\n...     ], order='F', dtype=float)\n>>> bv = np.array([\n...     [1.0],\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> cv = np.array([\n...     [-1.8, 0.0]\n...     ], order='F', dtype=float)\n>>> dv = np.array([\n...     [1.0]\n...     ], order='F', dtype=float)\n>>> aw = np.zeros((1, 1), order='F', dtype=float)\n>>> bw = np.zeros((1, m), order='F', dtype=float)\n>>> cw = np.zeros((m, 1), order='F', dtype=float)\n>>> dw = np.zeros((m, m), order='F', dtype=float)\n>>> nr = 0\n>>> alpha = 0.0\n>>> tol1 = 0.1\n>>> tol2 = 1e-14\n>>> (a_out, b_out, c_out, d_out, av_out, bv_out, cv_out,\n...     aw_out, bw_out, cw_out, nr_out, ns, hsv, iwarn, info) = ab09kd(\n...     'N', 'C', 'L', 'S', 'A', n, nv, nw, m, p, nr, alpha,\n...     a, b, c, d, av, bv, cv, dv, aw, bw, cw, dw, tol1, tol2\n...     )\n...     err_msg=\"Hankel singular values mismatch\")\n>>> ar_actual = a_out[:nr_out, :nr_out].copy()\n>>> br_actual = b_out[:nr_out, :m].copy()\n>>> cr_actual = c_out[:p, :nr_out].copy()\n>>> ar_actual = np.abs(ar_actual)\n...     err_msg=\"Reduced A matrix mismatch\")\n>>> br_actual = np.abs(br_actual)\n...     err_msg=\"Reduced B matrix mismatch\")\n>>> cr_actual = np.abs(cr_actual)\n...     err_msg=\"Reduced C matrix mismatch\")\n...     err_msg=\"Reduced D matrix mismatch\")",
  "ab09kx": "Stable projection of V*G*W or conj(V)*G*conj(W).\n\nConstructs a state-space representation (A,BS,CS,DS) of the stable\nprojection of V*G*W or conj(V)*G*conj(W) from the state-space\nrepresentations (A,B,C,D), (AV,BV,CV,DV), and (AW,BW,CW,DW) of\ntransfer-function matrices G, V and W respectively.\n\nG must be stable and A must be in real Schur form.\nFor JOB='N': V and W must be completely unstable.\nFor JOB='C': V and W must be stable.\n\nParameters:\n  job (str): 'N' for V*G*W, 'C' for conj(V)*G*conj(W)\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  weight (str): 'N' no weights, 'L' left only, 'R' right only, 'B' both\n  n (int): Order of G state matrix (n >= 0)\n  nv (int): Order of V state matrix (nv >= 0)\n  nw (int): Order of W state matrix (nw >= 0)\n  m (int): Number of G inputs and W I/O dimension (m >= 0)\n  p (int): Number of G outputs and V I/O dimension (p >= 0)\n  a (ndarray): N-by-N state matrix of G in real Schur form (F-order)\n  b (ndarray): N-by-M input matrix of G (F-order)\n  c (ndarray): P-by-N output matrix of G (F-order)\n  d (ndarray): P-by-M feedthrough matrix of G (F-order)\n  av (ndarray): NV-by-NV state matrix of V (F-order)\n  bv (ndarray): NV-by-P input matrix of V (F-order)\n  cv (ndarray): P-by-NV output matrix of V (F-order)\n  dv (ndarray): P-by-P feedthrough matrix of V (F-order)\n  aw (ndarray): NW-by-NW state matrix of W (F-order)\n  bw (ndarray): NW-by-M input matrix of W (F-order)\n  cw (ndarray): M-by-NW output matrix of W (F-order)\n  dw (ndarray): M-by-M feedthrough matrix of W (F-order)\n\nReturns:\n  (bs, cs, ds, av, bv, cv, aw, bw, cw, iwarn, info):\n    - bs, cs, ds: Modified B, C, D matrices (stable projection)\n    - av, bv, cv: Transformed V matrices (real Schur form)\n    - aw, bw, cw: Transformed W matrices (real Schur form)\n    - iwarn: Warning (0=ok, 1=AV issue, 2=AW issue, 3=both)\n    - info: Error (0=ok, 1=AV Schur failed, 2=AW Schur failed,\n            3=Sylvester (V) failed, 4=Sylvester (W) failed)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab09kx\n>>> n, m, p = 2, 1, 2\n>>> nv = 2\n>>> a = np.array([\n...     [-1.0, 0.0],\n...     [0.0, -2.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0],\n...     [0.5]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.1],\n...     [0.2]\n...     ], order='F', dtype=float)\n>>> av = np.array([\n...     [1.0, 0.0],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> bv = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> cv = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> dv = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> aw = np.zeros((1, 1), order='F', dtype=float)\n>>> bw = np.zeros((1, m), order='F', dtype=float)\n>>> cw = np.zeros((m, 1), order='F', dtype=float)\n>>> dw = np.zeros((m, m), order='F', dtype=float)\n>>> b_out, c_out, d_out, av_out, bv_out, cv_out, aw_out, bw_out, cw_out, iwarn, info = ab09kx(\n...     'N', 'C', 'L', n, nv, 0, m, p,\n...     a, b, c, d, av, bv, cv, dv, aw, bw, cw, dw\n...     )\n>>> info\n0",
  "ab09md": "Balance & Truncate model reduction for ALPHA-stable part of a system.\n\nComputes a reduced order model (Ar,Br,Cr) for an original\nstate-space representation (A,B,C) by using either square-root\nor balancing-free square-root Balance & Truncate (B&T)\nfor the ALPHA-stable part of the system.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  job (str): 'B' for square-root B&T, 'N' for balancing-free B&T\n  equil (str): 'S' to equilibrate (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  alpha (float): Stability boundary (continuous: alpha <= 0, discrete: 0 <= alpha <= 1)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  tol (float): Tolerance for order selection (used if ordsel='A')\n\nReturns:\n  (ar, br, cr, ns, hsv, nr, iwarn, info):\n    Reduced system matrices, dimension of stable part,\n    Hankel singular values, actual order, warning indicator, and exit code\n\nExamples:\n\n>>> from slicot import ab09md\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> nr = 0\n>>> alpha = -0.6\n>>> tol = 0.1\n>>> a = np.array([\n...     [-0.04165, 0.0000, 4.9200, -4.9200, 0.0000, 0.0000, 0.0000],\n...     [-5.2100, -12.500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 3.3300, -3.3300, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.5450, 0.0000, 0.0000, 0.0000, -0.5450, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 4.9200, -0.04165, 0.0000, 4.9200],\n...     [0.0000, 0.0000, 0.0000, 0.0000, -5.2100, -12.500, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 3.3300, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0000, 0.0000],\n...     [12.500, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 12.500],\n...     [0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> ar, br, cr, ns, hsv, nr_out, iwarn, info = ab09md(\n...     'C', 'N', 'N', 'A', n, m, p, nr, alpha, a, b, c, tol\n...     )\n>>> info\n0",
  "ab09nd": "SPA model reduction for ALPHA-stable part of a system.\n\nComputes a reduced order model (Ar,Br,Cr,Dr) for an original\nstate-space representation (A,B,C,D) by using either square-root\nor balancing-free square-root Singular Perturbation Approximation (SPA)\nfor the ALPHA-stable part of the system.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  job (str): 'B' for square-root SPA, 'N' for balancing-free SPA\n  equil (str): 'S' to equilibrate (A,B,C), 'N' for no scaling\n  ordsel (str): 'F' for fixed order, 'A' for automatic selection\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  nr (int): Desired order if ordsel='F' (0 <= nr <= n)\n  alpha (float): Stability boundary (continuous: alpha <= 0, discrete: 0 <= alpha <= 1)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol1 (float): Tolerance for order selection (used if ordsel='A')\n  tol2 (float): Tolerance for minimal realization order\n\nReturns:\n  (ar, br, cr, dr, nr, ns, hsv, iwarn, info):\n    Reduced system matrices, actual order, dimension of stable part,\n    Hankel singular values, warning indicator, and exit code\n\nExamples:\n\n>>> from slicot import ab09nd\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> a = np.array([\n...     [-0.04165,  0.0000,  4.9200, -4.9200, 0.0000,   0.0000,  0.0000],\n...     [-5.2100,  -12.500,  0.0000,  0.0000, 0.0000,   0.0000,  0.0000],\n...     [ 0.0000,   3.3300, -3.3300,  0.0000, 0.0000,   0.0000,  0.0000],\n...     [ 0.5450,   0.0000,  0.0000,  0.0000, -0.5450,  0.0000,  0.0000],\n...     [ 0.0000,   0.0000,  0.0000,  4.9200, -0.04165, 0.0000,  4.9200],\n...     [ 0.0000,   0.0000,  0.0000,  0.0000, -5.2100, -12.500,  0.0000],\n...     [ 0.0000,   0.0000,  0.0000,  0.0000,  0.0000,  3.3300, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [ 0.0000,  0.0000],\n...     [12.500,   0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000, 12.500],\n...     [ 0.0000,  0.0000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> dico = 'C'\n>>> job = 'N'\n>>> equil = 'N'\n>>> ordsel = 'A'\n>>> nr_in = 0\n>>> alpha = -0.6\n>>> tol1 = 0.1\n>>> tol2 = 1e-14\n>>> ar, br, cr, dr, nr, ns, hsv, iwarn, info = ab09nd(\n...     dico, job, equil, ordsel, n, m, p, nr_in, alpha,\n...     a, b, c, d, tol1, tol2\n...     )\n>>> info\n0",
  "ab13ad": "Compute Hankel-norm of ALPHA-stable projection.\n\nComputes the Hankel-norm of the ALPHA-stable projection of the\ntransfer-function matrix G of the state-space system (A,B,C).\n\nThe routine decomposes G = G1 + G2 where G1 has only ALPHA-stable\npoles, then returns the Hankel-norm of G1 (max Hankel singular value).\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  equil (str): 'S' to scale (A,B,C), 'N' for no scaling\n  n (int): Order of matrix A (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  alpha (float): Stability boundary:\n                 Continuous: alpha <= 0, eigenvalues with Re < alpha are stable\n                 Discrete: 0 <= alpha <= 1, eigenvalues with |.| < alpha are stable\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n\nReturns:\n  (hankel_norm, ns, hsv, info):\n    - hankel_norm: Hankel-norm of ALPHA-stable projection (0 if error)\n    - ns: Dimension of ALPHA-stable subsystem\n    - hsv: Hankel singular values of stable part (length N, leading NS used)\n    - info: Error code (0=success, 1=Schur failed, 2=separation failed,\n            3=marginally stable, 4=HSV computation failed)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab13ad\n>>> n, m, p = 7, 2, 3\n>>> alpha = 0.0\n>>> a = np.array([\n...     [-0.04165,  0.0000,  4.9200, -4.9200,  0.0000,  0.0000,  0.0000],\n...     [-5.2100, -12.500,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.0000,  3.3300, -3.3300,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.5450,  0.0000,  0.0000,  0.0000, -0.5450,  0.0000,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  4.9200, -0.04165, 0.0000,  4.9200],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000, -5.2100, -12.500,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  3.3300, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0000, 0.0000],\n...     [12.500, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 12.500],\n...     [0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> hankel_norm, ns, hsv, info = ab13ad('C', 'N', n, m, p, alpha, a, b, c)\n...     err_msg=\"Hankel-norm should match doc example\")\n>>> expected_hsv = np.array([2.5139, 2.0846, 1.9178, 0.7666, 0.5473, 0.0253, 0.0246])\n...     err_msg=\"Hankel singular values should match doc example\")\n>>> info\n0",
  "ab13bd": "Compute H2 or L2 norm of a transfer-function matrix.\n\nComputes the H2-norm (continuous) or L2-norm (discrete) of\ntransfer-function matrix G(lambda) = C*inv(lambda*I - A)*B + D.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  jobn (str): 'H' for H-infinity Gramian approach, 'L' for L2 gain\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol (float): Tolerance for rank determination\n\nReturns:\n  (h2norm, nq, iwarn, info): H2/L2 norm, order of minimal realization,\n    warning indicator, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab13bd\n>>> n, m, p = 3, 2, 2\n>>> a = np.diag([-1.0, -2.0, -3.0]).astype(float, order='F')\n>>> b = np.random.randn(n, m).astype(float, order='F')\n>>> c = np.random.randn(p, n).astype(float, order='F')\n>>> d = np.zeros((p, m), order='F', dtype=float)\n>>> tol = 0.0\n>>> h2norm, nq, iwarn, info = ab13bd(\n...     'C', 'L',\n...     a.copy(order='F'), b.copy(order='F'), c.copy(order='F'),\n...     d.copy(order='F'), tol)\n>>> info\n0",
  "ab13cd": "Compute H-infinity norm of continuous-time stable system.\n\nComputes the H-infinity norm of the continuous-time stable system\nG(s) = C*inv(sI - A)*B + D, which is the peak gain of the frequency\nresponse (largest singular value in MIMO case).\n\nUses the algorithm from Bruinsma & Steinbuch (1990).\n\nParameters:\n  n (int): System order (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  np (int): Number of outputs (np >= 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  tol (float): Tolerance for accuracy in determining the norm\n\nReturns:\n  (hnorm, fpeak, info): H-infinity norm, peak frequency, exit code\n    info: 0=success, 1=unstable, 2=tolerance too small, 3=eigenvalue error, 4=SVD error\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab13cd\n>>> n, m, np_ = 6, 1, 1\n>>> a = np.array([\n...     [0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n...     [-0.5, -0.0002, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 1.0, 0.0, 0.0],\n...     [0.0, 0.0, -1.0, -0.00002, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 1.0],\n...     [0.0, 0.0, 0.0, 0.0, -2.0, -0.000002]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0], [0.0], [1.0], [0.0], [1.0], [0.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, 1.0, 0.0, 1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([[0.0]], order='F', dtype=float)\n>>> tol = 1e-9\n>>> hnorm, fpeak, info = ab13cd(n, m, np_, a, b, c, d, tol)\n>>> info\n0",
  "ab13dd": "Compute L-infinity norm of state-space system.\n\nComputes the L-infinity norm of a continuous-time or discrete-time\nsystem G(lambda) = C*inv(lambda*E - A)*B + D.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  jobe (str): 'I' for E=identity, 'G' for general E\n  equil (str): 'S' to scale system, 'N' for no scaling\n  jobd (str): 'Z' for D=zero, 'D' for general D\n  n (int): System order\n  m (int): Number of inputs\n  p (int): Number of outputs\n  fpeak (ndarray): Frequency estimate [omega, scale]\n  a (ndarray): State matrix A (n x n, F-order)\n  e (ndarray): Descriptor matrix E (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol (float): Tolerance for convergence (0 <= tol < 1)\n\nReturns:\n  (gpeak, fpeak, info): Peak gain [norm, scale], peak frequency, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab13dd\n>>> n, m, p = 6, 1, 1\n>>> a = np.array([\n...     [0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n...     [-0.5, -0.0002, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 1.0, 0.0, 0.0],\n...     [0.0, 0.0, -1.0, -0.00002, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 1.0],\n...     [0.0, 0.0, 0.0, 0.0, -2.0, -0.000002]\n...     ], order='F', dtype=float)\n>>> e = np.eye(n, order='F', dtype=float)\n>>> b = np.array([[1.0], [0.0], [1.0], [0.0], [1.0], [0.0]], order='F', dtype=float)\n>>> c = np.array([[1.0, 0.0, 1.0, 0.0, 1.0, 0.0]], order='F', dtype=float)\n>>> d = np.array([[0.0]], order='F', dtype=float)\n>>> fpeak = np.array([0.0, 1.0], order='F', dtype=float)\n>>> tol = 1e-9\n>>> gpeak, fpeak_out, info = ab13dd(\n...     'C', 'I', 'N', 'D', n, m, p, fpeak, a, e, b, c, d, tol\n...     )\n>>> info\n0",
  "ab13dx": "Compute transfer function gain at specific frequency.\n\nComputes maximum singular value of G(lambda) = C*inv(lambda*E - A)*B + D\nat a given frequency omega.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  jobe (str): 'I' for E=identity, 'G' for general E\n  jobd (str): 'Z' for D=zero, 'D' for general D\n  n (int): System order\n  m (int): Number of inputs\n  p (int): Number of outputs\n  a (ndarray): State matrix A (n x n, F-order)\n  e (ndarray): Descriptor matrix E (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  omega (float): Frequency value\n\nReturns:\n  (result, info): Maximum singular value, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab13dx\n>>> n, m, p = 2, 1, 1\n>>> a = np.array([\n...     [-1.0, 0.0],\n...     [0.0, -2.0]\n...     ], order='F', dtype=float)\n>>> e = np.eye(n, order='F', dtype=float)\n>>> b = np.array([[1.0], [1.0]], order='F', dtype=float)\n>>> c = np.array([[1.0, 1.0]], order='F', dtype=float)\n>>> d = np.zeros((p, m), order='F', dtype=float)\n>>> omega = 1.0\n>>> result, info = ab13dx('C', 'I', 'Z', n, m, p, a, e, b, c, d, omega)\n>>> info\n0",
  "ab13ed": "Estimate distance to instability (stability radius).\n\nParameters:\n  a (ndarray): State matrix A (n x n)\n  tol (float): Tolerance\n\nReturns:\n  (low, high, info): Lower/Upper bounds, exit code\n\nExamples:\n\n>>> from slicot import ab13ed\n>>> import numpy as np\n>>> A = np.array([[-1.0]], order='F')\n>>> low, high, info = ab13ed(A)\n>>> info\n0",
  "ab13fd": "Compute complex stability radius using SVD.\n\nComputes beta(A), the 2-norm distance from a real matrix A to the\nnearest complex matrix with an eigenvalue on the imaginary axis.\nbeta(A) = min_w sigma_min(A - jwI)\n\nParameters:\n  a (ndarray): State matrix A (n x n, F-order)\n  tol (float): Accuracy tolerance (default 0.0)\n\nReturns:\n  (beta, omega, info): Stability radius, minimizing frequency, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab13fd\n>>> a = np.array([\n...     [246.500, 242.500, 202.500, -197.500],\n...     [-252.500, -248.500, -207.500, 202.500],\n...     [-302.500, -297.500, -248.500, 242.500],\n...     [-307.500, -302.500, -252.500, 246.500]\n...     ], order='F', dtype=float)\n>>> tol = 0.0\n>>> beta, omega, info = ab13fd(a, tol)\n>>> info\n0",
  "ab13hd": "Compute L-infinity norm of proper continuous-time or causal discrete-time descriptor system.\n\nComputes the L-infinity norm of a proper and target continuous-time\nor a causal and target discrete-time system:\n  G(lambda) = C * inv(lambda*E - A) * B + D\n\nwhere 'proper' means system doesn't have infinite eigenvalues in E,\nand 'causal' means system is causal in discrete-time.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  jobe (str): 'I' for E=identity, 'G' for general E\n  equil (str): 'S' to scale system, 'N' for no scaling\n  jobd (str): 'Z' for D=zero, 'D' for general D, 'F' for feedthrough factor form\n  ckprop (str): 'C' to check properness, 'N' to not check\n  reduce (str): 'R' to reduce system order, 'N' for no reduction\n  poles (str): 'P' to output poles, 'N' to not output\n  n (int): System order (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  ranke (int): Rank of E matrix (0 <= ranke <= n for jobe='G')\n  fpeak (ndarray): Frequency estimate [omega, scale] (2 elements)\n  a (ndarray): State matrix A (n x n, F-order)\n  e (ndarray): Descriptor matrix E (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  d (ndarray): Feedthrough matrix D (p x m, F-order)\n  tol (ndarray): Tolerances (3 elements)\n\nReturns:\n  (gpeak, fpeak, nr, iwarn, info): Peak gain [norm, scale], peak frequency,\n    reduced order, warning indicator, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab13hd\n>>> n, m, p = 6, 1, 1\n>>> a = np.array([\n...     [0.0, 1.0, 0.0, 0.0, 0.0, 0.0],\n...     [-0.5, -0.0002, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 1.0, 0.0, 0.0],\n...     [0.0, 0.0, -1.0, -0.00002, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 1.0],\n...     [0.0, 0.0, 0.0, 0.0, -2.0, -0.000002]\n...     ], order='F', dtype=float)\n>>> e = np.eye(n, order='F', dtype=float)\n>>> b = np.array([[1.0], [0.0], [1.0], [0.0], [1.0], [0.0]], order='F', dtype=float)\n>>> c = np.array([[1.0, 0.0, 1.0, 0.0, 1.0, 0.0]], order='F', dtype=float)\n>>> d = np.array([[0.0]], order='F', dtype=float)\n>>> fpeak = np.array([0.0, 1.0], order='F', dtype=float)\n>>> tol = np.array([1e-9, -1.0], order='F', dtype=float)\n>>> gpeak, fpeak_out, nr, iwarn, info = ab13hd(\n...     'C', 'I', 'N', 'D', 'N', 'N', 'A',\n...     n, m, p, 0, fpeak, a, e, b, c, d, tol\n...     )\n>>> info\n0",
  "ab13id": "Check if descriptor system transfer function is proper.\n\nDetermines whether the transfer function G(lambda) = C*inv(lambda*E - A)*B\nof a descriptor system (A-lambda*E, B, C) is proper. A transfer function\nis proper if it has no poles at infinity.\n\nThe routine optionally computes a deflated system (Ar-lambda*Er, Br, Cr)\nwith the same transfer function but with E upper triangular and nonsingular.\n\nParameters:\n  jobsys (str): 'R' to reduce system order, 'N' for no reduction\n  jobeig (str): 'A' remove all infinite eigenvalues, 'I' only those uncontrollable from infinity\n  equil (str): 'S' to scale system, 'N' for no scaling\n  cksing (str): 'C' to check singularity of E, 'N' to skip check\n  restor (str): 'R' to restore (A,E,B,C) on exit if improper, 'N' for no restoration\n  update (str): 'U' to update (A,E,B,C), 'N' for no update\n  a (ndarray): State matrix A (n x n, F-order)\n  e (ndarray): Descriptor matrix E (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  n (int, optional): System order (default from A shape)\n  m (int, optional): Number of inputs (default from B shape)\n  p (int, optional): Number of outputs (default from C shape)\n  tol (ndarray, optional): Tolerances [tol1, tol2] (default [0.0, 0.0])\n\nReturns:\n  (is_proper, nr, ranke, a, e, b, c, iwarn, info):\n    - is_proper: True if transfer function is proper, False otherwise\n    - nr: Order of reduced descriptor system\n    - ranke: Rank of E (number of finite generalized eigenvalues)\n    - a, e, b, c: Modified system matrices\n    - iwarn: Warning (1=E nearly singular, 2=system nearly improper)\n    - info: Exit code (0=success, 1=Schur failed, 2=QZ failed)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab13id\n>>> n, m, p = 9, 2, 2\n>>> a = np.array([\n...     [-2, -3, 0, 0, 0, 0, 0, 0, 0],\n...     [1, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, -2, -3, 0, 0, 0, 0, 0],\n...     [0, 0, 1, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 1, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 1, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 1, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 1, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 0, 1],\n...     ], dtype=float, order='F')\n>>> e = np.array([\n...     [1, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 1, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 1, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 1, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 1, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 1, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 1, 0],\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [1, 0],\n...     [0, 0],\n...     [0, 1],\n...     [0, 0],\n...     [-1, 0],\n...     [0, 0],\n...     [0, -1],\n...     [0, 0],\n...     [0, 0],\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [1, 0, 1, -3, 0, 1, 0, 2, 0],\n...     [0, 1, 1, 3, 0, 1, 0, 0, 1],\n...     ], dtype=float, order='F')\n>>> jobsys = 'R'  # Reduce\n>>> jobeig = 'I'  # Remove infinite eigenvalues only\n>>> equil = 'N'   # No scaling\n>>> cksing = 'N'  # No singularity check\n>>> restor = 'N'  # No restore\n>>> update = 'U'  # Update matrices\n>>> tol = np.array([0.0, 0.0, 0.0], dtype=float)\n>>> is_proper, nr, ranke, a_out, e_out, b_out, c_out, iwarn, info = ab13id(\n...     jobsys, jobeig, equil, cksing, restor, update,\n...     a, e, b, c, tol\n...     )\n>>> info\n0",
  "ab13md": "Compute upper bound on structured singular value (mu).\n\nComputes an upper bound on the structured singular value for a given\nsquare complex matrix and a given block structure of the uncertainty.\n\nParameters:\n  z (ndarray): Complex matrix Z (n x n, F-order)\n  nblock (ndarray): Block sizes, dimension (m), int32\n  itype (ndarray): Block types (1=real, 2=complex), dimension (m), int32\n  fact (str, optional): 'F' to use x from previous call, 'N' fresh (default)\n  x (ndarray, optional): Scaling vector from previous call\n\nReturns:\n  (bound, d, g, x, info): Upper bound on mu, scaling matrices D and G,\n    scaling vector X for next call, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ab13md\n>>> n = 4\n>>> z_real = np.random.randn(n, n)\n>>> z_imag = np.random.randn(n, n)\n>>> z = (z_real + 1j * z_imag).astype(np.complex128, order='F')\n>>> nblock = np.array([n], dtype=np.int32)\n>>> itype = np.array([2], dtype=np.int32)\n>>> bound, d, g, x, info = ab13md(z, nblock, itype)\n>>> sigma_max = np.linalg.svd(z, compute_uv=False)[0]\n>>> info\n0",
  "ab8nxz": "Extract reduced system with same transmission zeros (complex).\n\nExtracts from compound system [B A; D C] a reduced system\n[B' A'; D' C'] with same transmission zeros but D' full row rank.\n\nParameters:\n  n (int): Number of state variables (n >= 0)\n  m (int): Number of system inputs (m >= 0)\n  p (int): Number of system outputs (p >= 0)\n  ro (int): p for original, max(p-m,0) for pertransposed system\n  sigma (int): 0 for original, m for pertransposed system\n  svlmax (float): Estimate of largest singular value (>= 0)\n  abcd (ndarray): Compound matrix (n+p x m+n, F-order, complex)\n  tol (float): Tolerance for rank decisions\n\nReturns:\n  (abcd, ro, sigma, mu, nu, ninfz, infz, kronl, info): Reduced matrix,\n    final ro/sigma, dimensions (mu,nu), infinite zero count/degrees,\n    left Kronecker indices, exit code\n\nExamples:\n\n>>> from slicot import ab8nxz\n>>> import numpy as np\n>>> n, m, p = 2, 1, 1\n>>> ro = p\n>>> sigma = 0\n>>> svlmax = 0.0\n>>> tol = 1.0e-10\n>>> A = np.random.randn(n, n) + 1j * np.random.randn(n, n)\n>>> B = np.random.randn(n, m) + 1j * np.random.randn(n, m)\n>>> C = np.random.randn(p, n) + 1j * np.random.randn(p, n)\n>>> D = np.random.randn(p, m) + 1j * np.random.randn(p, m)\n>>> abcd = np.zeros((n + p, m + n), dtype=complex, order='F')\n>>> abcd[:n, :m] = B\n>>> abcd[:n, m:] = A\n>>> abcd[n:, :m] = D\n>>> abcd[n:, m:] = C\n>>> result = ab8nxz(n, m, p, ro, sigma, svlmax, abcd.copy(), tol)\n>>> abcd_out, ro_out, sigma_out, mu, nu, ninfz, infz, kronl, info = result",
  "ag07bd": "Descriptor inverse of a state-space or descriptor system.\n\nComputes the inverse (Ai-lambda*Ei, Bi, Ci, Di) of a given\ndescriptor system (A-lambda*E, B, C, D) using the formulas:\n  Ei = [E 0; 0 0], Ai = [A B; C D], Bi = [0; -I], Ci = [0 I], Di = 0\n\nThe inverse system has order N+M.\n\nParameters:\n  jobe (str): 'G' for general E, 'I' for identity E\n  n (int): Order of A and E matrices (n >= 0)\n  m (int): Number of inputs/outputs (m >= 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (m x n, F-order)\n  d (ndarray): Feedthrough matrix D (m x m, F-order)\n  e (ndarray, optional): Descriptor matrix E (n x n, F-order), required if jobe='G'\n\nReturns:\n  (ai, ei, bi, ci, di, info):\n    - ai: State matrix of inverse ((n+m) x (n+m))\n    - ei: Descriptor matrix of inverse ((n+m) x (n+m))\n    - bi: Input matrix of inverse ((n+m) x m)\n    - ci: Output matrix of inverse (m x (n+m))\n    - di: Feedthrough matrix of inverse (m x m, always zero)\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ag07bd\n>>> import numpy as np\n>>> n, m = 2, 1\n>>> A = np.array([[1.0, 2.0],\n...     [3.0, 4.0]], order='F', dtype=float)\n>>> B = np.array([[1.0],\n...     [0.0]], order='F', dtype=float)\n>>> C = np.array([[0.0, 1.0]], order='F', dtype=float)\n>>> D = np.array([[1.0]], order='F', dtype=float)\n>>> result = ag07bd('I', n, m, A, B, C, D)\n>>> ai, ei, bi, ci, di, info = result",
  "ag08bd": "Zeros and Kronecker structure of a descriptor system pencil.\n\nExtracts from the system pencil S(lambda) = [A-lambda*E, B; C, D]\na regular pencil Af-lambda*Ef with finite Smith zeros as eigenvalues.\nAlso computes infinite zero orders and Kronecker structure.\n\nParameters:\n  equil (str): 'S' to balance, 'N' no balancing\n  l (int): Number of rows of A, B, E (l >= 0)\n  n (int): Number of columns of A, E, C (n >= 0)\n  m (int): Number of columns of B (m >= 0)\n  p (int): Number of rows of C (p >= 0)\n  a (ndarray): State matrix (l x n, F-order)\n  e (ndarray): Descriptor matrix (l x n, F-order)\n  b (ndarray): Input matrix (l x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  d (ndarray): Direct transmission matrix (p x m, F-order)\n  tol (float): Tolerance for rank decisions\n\nReturns:\n  (a, e, nfz, nrank, niz, dinfz, nkror, ninfe, nkrol,\n   infz, kronr, infe, kronl, info):\n    - a: Contains Af in leading nfz x nfz block\n    - e: Contains Ef in leading nfz x nfz block\n    - nfz: Number of finite zeros\n    - nrank: Normal rank of system pencil\n    - niz: Number of infinite zeros\n    - dinfz: Max multiplicity of infinite zeros\n    - nkror: Number of right Kronecker indices\n    - ninfe: Number of elementary infinite blocks\n    - nkrol: Number of left Kronecker indices\n    - infz: Infinite zero degrees\n    - kronr: Right Kronecker indices\n    - infe: Multiplicities of infinite eigenvalues\n    - kronl: Left Kronecker indices\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ag08bd\n>>> import numpy as np\n>>> l, n, m, p = 9, 9, 3, 3\n>>> A = np.array([\n...     [1, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 1, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 1, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 1, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 1, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 1, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 1, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 1, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 0, 1],\n...     ], dtype=float, order='F')\n>>> E = np.array([\n...     [0, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [1, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 1, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 1, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 1, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 1, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 1, 0],\n...     ], dtype=float, order='F')\n>>> B = np.array([\n...     [-1, 0, 0],\n...     [0, 0, 0],\n...     [0, 0, 0],\n...     [0, -1, 0],\n...     [0, 0, 0],\n...     [0, 0, 0],\n...     [0, 0, -1],\n...     [0, 0, 0],\n...     [0, 0, 0],\n...     ], dtype=float, order='F')\n>>> C = np.array([\n...     [0, 1, 1, 0, 3, 4, 0, 0, 2],\n...     [0, 1, 0, 0, 4, 0, 0, 2, 0],\n...     [0, 0, 1, 0, -1, 4, 0, -2, 2],\n...     ], dtype=float, order='F')\n>>> D = np.array([\n...     [1, 2, -2],\n...     [0, -1, -2],\n...     [0, 0, 0],\n...     ], dtype=float, order='F')\n>>> result = ag08bd('N', l, n, m, p, A, E, B, C, D, 1e-7)\n>>> (a_out, e_out, nfz, nrank, niz, dinfz, nkror, ninfe, nkrol,\n...     infz, kronr, infe, kronl, info) = result\n...     eigvals = np.linalg.eigvals(\n...     np.linalg.solve(e_out[:nfz, :nfz], a_out[:nfz, :nfz])\n...     )",
  "ag08by": "Extract reduced descriptor system pencil preserving finite Smith zeros.\n\nExtracts from the (N+P)-by-(M+N) descriptor system pencil\nS(lambda) = [B, A-lambda*E; D, C] with E upper triangular\na reduced pencil Sr(lambda) = [Br, Ar-lambda*Er; Dr, Cr]\nwith the same finite Smith zeros but Dr full row rank.\n\nParameters:\n  first (bool): True if first call, False for already reduced system\n  n (int): Order of A and E (n >= 0)\n  m (int): Number of columns of B and D (m >= 0)\n  p (int): Number of rows of C and D (p >= 0)\n  svlmax (float): Max singular value estimate (>= 0)\n  abcd (ndarray): Compound matrix [B A; D C] ((n+p) x (m+n), F-order)\n  e (ndarray): Upper triangular E (n x n, F-order)\n  tol (float): Tolerance for rank decisions\n\nReturns:\n  (abcd, e, nr, pr, ninfz, dinfz, nkronl, infz, kronl, info):\n    - abcd: Reduced compound matrix\n    - e: Reduced upper triangular matrix\n    - nr: Order of reduced system\n    - pr: Rank of Dr\n    - ninfz: Number of infinite zeros\n    - dinfz: Max multiplicity of infinite zeros\n    - nkronl: Max dimension of left Kronecker blocks\n    - infz: Infinite zero degrees\n    - kronl: Left Kronecker block counts\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ag08by\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> A = np.array([\n...     [1.0, 2.0, 0.0],\n...     [4.0, -1.0, 0.0],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> C = np.array([\n...     [1.0, 0.0, 1.0],\n...     [0.0, 1.0, -1.0]\n...     ], order='F', dtype=float)\n>>> D = np.array([\n...     [0.0, 0.0],\n...     [0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> E = np.eye(n, order='F', dtype=float)\n>>> abcd = np.zeros((n + p, m + n), order='F', dtype=float)\n>>> abcd[:n, :m] = B\n>>> abcd[:n, m:] = A\n>>> abcd[n:, :m] = D\n>>> abcd[n:, m:] = C\n>>> svlmax = 0.0\n>>> tol = 0.0\n>>> result = ag08by(True, n, m, p, svlmax, abcd.copy(), E.copy(), tol)\n>>> abcd_out, e_out, nr, pr, ninfz, dinfz, nkronl, infz, kronl, info = result",
  "ag08bz": "Zeros and Kronecker structure of a complex descriptor system pencil.\n\nComplex version of ag08bd. Extracts from the system pencil\nS(lambda) = [A-lambda*E, B; C, D] a regular pencil Af-lambda*Ef\nwith finite Smith zeros as eigenvalues. Also computes infinite\nzero orders and Kronecker structure.\n\nParameters:\n  equil (str): 'S' to balance, 'N' no balancing\n  l (int): Number of rows of A, B, E (l >= 0)\n  n (int): Number of columns of A, E, C (n >= 0)\n  m (int): Number of columns of B (m >= 0)\n  p (int): Number of rows of C (p >= 0)\n  a (ndarray): Complex state matrix (l x n, F-order)\n  e (ndarray): Complex descriptor matrix (l x n, F-order)\n  b (ndarray): Complex input matrix (l x m, F-order)\n  c (ndarray): Complex output matrix (p x n, F-order)\n  d (ndarray): Complex direct transmission matrix (p x m, F-order)\n  tol (float): Tolerance for rank decisions\n\nReturns:\n  (nfz, nrank, niz, dinfz, nkror, ninfe, nkrol,\n   infz, kronr, infe, kronl, info):\n    - nfz: Number of finite zeros\n    - nrank: Normal rank of system pencil\n    - niz: Number of infinite zeros\n    - dinfz: Max multiplicity of infinite zeros\n    - nkror: Number of right Kronecker indices\n    - ninfe: Number of elementary infinite blocks\n    - nkrol: Number of left Kronecker indices\n    - infz: Infinite zero degrees\n    - kronr: Right Kronecker indices\n    - infe: Multiplicities of infinite eigenvalues\n    - kronl: Left Kronecker indices\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ag08bz\n>>> import numpy as np\n>>> A = self.A.copy()\n>>> E = self.E.copy()\n>>> B = self.B.copy()\n>>> C = self.C.copy()\n>>> D = self.D.copy()\n>>> result = ag08bz(self.equil, self.l, self.n, self.m, self.p,\n...     A, E, B, C, D, self.tol)\n>>> nfz, nrank, niz, dinfz, nkror, ninfe, nkrol, infz, kronr, infe, kronl, info = result",
  "ag8byz": "Extract reduced descriptor system pencil preserving finite Smith zeros (complex).\n\nComplex version of ag08by. Extracts from the (N+P)-by-(M+N) complex\ndescriptor system pencil S(lambda) = [B, A-lambda*E; D, C] with E\nupper triangular a reduced pencil Sr(lambda) = [Br, Ar-lambda*Er; Dr, Cr]\nwith the same finite Smith zeros but Dr full row rank.\n\nParameters:\n  first (bool): True if first call, False for already reduced system\n  n (int): Order of A and E (n >= 0)\n  m (int): Number of columns of B and D (m >= 0)\n  p (int): Number of rows of C and D (p >= 0)\n  svlmax (float): Max singular value estimate (>= 0)\n  abcd (ndarray): Complex compound matrix [B A; D C] ((n+p) x (m+n), F-order)\n  e (ndarray): Complex upper triangular E (n x n, F-order)\n  tol (float): Tolerance for rank decisions\n\nReturns:\n  (abcd, e, nr, pr, ninfz, dinfz, nkronl, infz, kronl, info):\n    - abcd: Reduced compound matrix (complex)\n    - e: Reduced upper triangular matrix (complex)\n    - nr: Order of reduced system\n    - pr: Rank of Dr\n    - ninfz: Number of infinite zeros\n    - dinfz: Max multiplicity of infinite zeros\n    - nkronl: Max dimension of left Kronecker blocks\n    - infz: Infinite zero degrees\n    - kronl: Left Kronecker block counts\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import ag8byz\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> A = np.array([\n...     [1.0+0.1j, 2.0+0.0j, 0.0+0.0j],\n...     [4.0+0.0j, -1.0+0.2j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 1.0+0.0j]\n...     ], order='F', dtype=complex)\n>>> B = np.array([\n...     [1.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 1.0+0.0j],\n...     [1.0+0.0j, 1.0+0.0j]\n...     ], order='F', dtype=complex)\n>>> C = np.array([\n...     [1.0+0.0j, 0.0+0.0j, 1.0+0.0j],\n...     [0.0+0.0j, 1.0+0.0j, -1.0+0.0j]\n...     ], order='F', dtype=complex)\n>>> D = np.array([\n...     [0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j]\n...     ], order='F', dtype=complex)\n>>> E = np.eye(n, order='F', dtype=complex)\n>>> abcd = np.zeros((n + p, m + n), order='F', dtype=complex)\n>>> abcd[:n, :m] = B\n>>> abcd[:n, m:] = A\n>>> abcd[n:, :m] = D\n>>> abcd[n:, m:] = C\n>>> svlmax = 0.0\n>>> tol = 0.0\n>>> result = ag8byz(True, n, m, p, svlmax, abcd.copy(), E.copy(), tol)\n>>> abcd_out, e_out, nr, pr, ninfz, dinfz, nkronl, infz, kronl, info = result",
  "bb01ad": "Generate benchmark examples for continuous-time algebraic Riccati equations.\n\nGenerates benchmark examples for the numerical solution of CAREs:\n  0 = Q + A'X + XA - XGX\ncorresponding to the Hamiltonian matrix H = [A G; Q -A'].\n\nThe examples come from the CAREX collection (Kenney/Laub/Wette 1989).\n\nParameters:\n  def (str): 'D' use default parameters, 'N' use provided parameters\n  nr (list/ndarray): Example identifier [group, number] (int32)\n  dpar (ndarray): Real parameters, dimension 7 (F-order, float64)\n  ipar (ndarray): Integer parameters [n, m, p, ...], dimension 4 (int32)\n  bpar (ndarray): Boolean parameters, dimension 6 (bool):\n    bpar[0]: True=compute G, False=return B,R factors\n    bpar[1]: True=G full storage, False=packed\n    bpar[2]: True=G upper packed, False=lower\n    bpar[3]: True=compute Q, False=return C,W factors\n    bpar[4]: True=Q full storage, False=packed\n    bpar[5]: True=Q upper packed, False=lower\n\nReturns:\n  (vec, n, m, p, a, b, c, g, q, x, info):\n    - vec: Boolean flags (9 elements)\n    - n, m, p: Problem dimensions\n    - a: State matrix (n x n)\n    - b: Input matrix (n x m)\n    - c: Output matrix (p x n)\n    - g: G matrix or packed form\n    - q: Q matrix or packed form\n    - x: Solution matrix (if vec[8]=True)\n    - info: 0=success, 1=not implemented, 2=invalid param, 3=singular R\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import bb01ad\n>>> nr = [2, 3]\n>>> dpar = np.array([0.1234, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], dtype=np.float64)\n>>> ipar = np.array([0, 0, 0, 0], dtype=np.int32)\n>>> bpar = np.array([True, True, True, False, True, True], dtype=bool)\n>>> vec, n, m, p, a, b, c, g, q, x, info = bb01ad('N', nr, dpar, ipar, bpar)\n>>> info\n0",
  "bb02ad": "Generate benchmark examples for discrete-time algebraic Riccati equations.\n\nGenerates benchmark examples for the numerical solution of DAREs:\n  0 = A'XA - X - (A'XB + S)(R + B'XB)^{-1}(B'XA + S') + Q\n\nThe examples come from the DAREX collection (Benner/Laub/Mehrmann 1995).\n\nParameters:\n  def (str): 'D' use default parameters, 'N' use provided parameters\n  nr (list/ndarray): Example identifier [group, number] (int32)\n  dpar (ndarray): Real parameters, dimension 4 (F-order, float64)\n  ipar (ndarray): Integer parameters [n, m, p], dimension 3 (int32)\n  bpar (ndarray): Boolean parameters, dimension 7 (bool):\n    bpar[0]: True=compute Q, False=return C,Q0 factors\n    bpar[1]: True=Q full storage, False=packed\n    bpar[2]: True=Q upper packed, False=lower\n    bpar[3]: True=compute G, False=return B,R factors\n    bpar[4]: True=R/G full storage, False=packed\n    bpar[5]: True=R/G upper packed, False=lower\n    bpar[6]: True=return S matrix, False=don't return S\n\nReturns:\n  (vec, n, m, p, a, b, c, q, r, s, x, info):\n    - vec: Boolean flags (10 elements)\n    - n, m, p: Problem dimensions\n    - a: State matrix (n x n)\n    - b: Input matrix (n x m)\n    - c: Output matrix (p x n)\n    - q: Q matrix or packed form\n    - r: R matrix or G if bpar[3]=True\n    - s: Coefficient matrix S (if bpar[6]=True)\n    - x: Solution matrix (if vec[9]=True)\n    - info: 0=success, 1=not implemented, 2=div by zero, 3=singular R\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import bb02ad\n>>> nr = np.array([2, 3], dtype=np.int32)\n>>> dpar = np.array([0.1234, 0.0, 0.0, 0.0], dtype=np.float64)\n>>> ipar = np.array([0, 0, 0], dtype=np.int32)\n>>> bpar = np.array([True, True, True, False, False, True, True], dtype=bool)\n>>> result = bb02ad('N', nr, dpar, ipar, bpar)\n>>> vec, n, m, p, a, b, c, q, r, s, x, info = result",
  "bb03ad": "Generate benchmark examples for continuous-time Lyapunov equations.\n\nGenerates benchmark examples of (generalized) continuous-time Lyapunov equations:\n  A'XE + E'XA = Y\n\nIn some examples, Y = -B'B and X = U'U (Cholesky factor).\nImplements the CTLEX collection (Kressner/Mehrmann/Penzl 1999).\n\nParameters:\n  def (str): 'D' use default parameters, 'N' use provided parameters\n  nr (list/ndarray): Example identifier [group, number] (int32)\n    Only group 4 (scalable parameter-dependent) is supported:\n    nr[1]=1: Example 4.1 (r, s parameters)\n    nr[1]=2: Example 4.2 (lambda, s parameters)\n    nr[1]=3: Example 4.3 (generalized, t parameter)\n    nr[1]=4: Example 4.4 (generalized, t parameter, n=3*q)\n  dpar (ndarray): Real parameters, dimension 2 (float64)\n  ipar (ndarray): Integer parameters [n or q], dimension 1 (int32)\n\nReturns:\n  (vec, n, m, e, a, y, b, x, u, note, info):\n    - vec: Boolean flags (8 elements):\n      vec[0-1]: N, M always available\n      vec[2]: True if E is NOT identity\n      vec[3-4]: A, Y always available\n      vec[5]: True if B provided\n      vec[6]: True if X (solution) provided\n      vec[7]: True if U (Cholesky) provided\n    - n: Problem dimension\n    - m: Rows in B (0 if not provided)\n    - e, a, y: Equation matrices (n x n)\n    - b: RHS factor (m x n if provided)\n    - x: Solution (n x n if provided)\n    - u: Cholesky factor (n x n if provided)\n    - note: Example description string\n    - info: 0=success, <0=invalid argument\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import bb03ad\n>>> nr = np.array([4, 1], dtype=np.int32)\n>>> dpar = np.array([1.5, 1.5], dtype=np.float64)\n>>> ipar = np.array([5], dtype=np.int32)\n>>> result = bb03ad('N', nr, dpar, ipar)\n>>> vec, n, m, e, a, y, b, x, u, note, info = result",
  "bb04ad": "Generate benchmark examples for discrete-time Lyapunov equations.\n\nGenerates benchmark examples of (generalized) discrete-time Lyapunov equations:\n  A'XA - E'XE = Y\n\nIn some examples, Y = -B'B and X = U'U (Cholesky factor).\nImplements the DTLEX collection (Kressner/Mehrmann/Penzl 1999).\n\nParameters:\n  def (str): 'D' use default parameters, 'N' use provided parameters\n  nr (list/ndarray): Example identifier [group, number] (int32)\n    Only group 4 (scalable parameter-dependent) is supported:\n    nr[1]=1: Example 4.1 (r, s parameters, both > 1)\n    nr[1]=2: Example 4.2 (lambda in (-1,1), s > 1)\n    nr[1]=3: Example 4.3 (generalized, t >= 0)\n    nr[1]=4: Example 4.4 (generalized, t >= 1, n=3*q)\n  dpar (ndarray): Real parameters, dimension 2 (float64)\n  ipar (ndarray): Integer parameters [n or q], dimension 1 (int32)\n\nReturns:\n  (vec, n, m, e, a, y, b, x, u, note, info):\n    - vec: Boolean flags (8 elements):\n      vec[0-1]: N, M always available\n      vec[2]: True if E is NOT identity\n      vec[3-4]: A, Y always available\n      vec[5]: True if B provided\n      vec[6]: True if X (solution) provided\n      vec[7]: True if U (Cholesky) provided\n    - n: Problem dimension\n    - m: Rows in B (0 if not provided)\n    - e, a, y: Equation matrices (n x n)\n    - b: RHS factor (m x n if provided)\n    - x: Solution (n x n if provided)\n    - u: Cholesky factor (n x n if provided)\n    - note: Example description string\n    - info: 0=success, <0=invalid argument\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import bb04ad\n>>> nr = np.array([4, 1], dtype=np.int32)\n>>> dpar = np.array([1.5, 1.5], dtype=np.float64)\n>>> ipar = np.array([5], dtype=np.int32)\n>>> result = bb04ad('N', nr, dpar, ipar)\n>>> vec, n, m, e, a, y, b, x, u, note, info = result",
  "bd01ad": "Generate benchmark examples for continuous-time dynamical systems.\n\nGenerates benchmark examples for time-invariant, continuous-time\ndynamical systems (CTDSX collection from SLICOT Working Note 1998-9):\n  E x'(t) = A x(t) + B u(t)\n    y(t)  = C x(t) + D u(t)\n\nParameters:\n  def (str): 'D' use default parameters, 'N' use provided parameters\n  nr (list/ndarray): Example identifier [group, number] (int32)\n    Group 1: Parameter-free problems of fixed size\n    Group 2: Parameter-dependent problems of fixed size\n    Group 3: Parameter-free problems of scalable size\n    Group 4: Parameter-dependent problems of scalable size\n  dpar (ndarray): Real parameters, dimension 7 (float64)\n  ipar (ndarray): Integer parameters, dimension 1 (int32)\n\nReturns:\n  (vec, n, m, p, e, a, b, c, d, note, info):\n    - vec: Boolean flags (8 elements):\n      vec[0-2]: N, M, P always available\n      vec[3]: True if E is NOT identity\n      vec[4-6]: A, B, C always available\n      vec[7]: True if D is NOT zero\n    - n, m, p: Problem dimensions (states, inputs, outputs)\n    - e: Descriptor matrix (n x n), identity if vec[3]=False\n    - a: State matrix (n x n)\n    - b: Input matrix (n x m)\n    - c: Output matrix (p x n)\n    - d: Feedthrough matrix (p x m), zero if vec[7]=False\n    - note: Example description string\n    - info: 0=success, 1=data file required, <0=invalid argument\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import bd01ad\n>>> nr = np.array([1, 1], dtype=np.int32)\n>>> dpar = np.zeros(7, dtype=np.float64)\n>>> ipar = np.zeros(1, dtype=np.int32)\n>>> result = bd01ad('D', nr, dpar, ipar)\n>>> vec, n, m, p, e, a, b, c, d, note, info = result",
  "bd02ad": "Generate benchmark examples for discrete-time dynamical systems.\n\nGenerates benchmark examples for time-invariant, discrete-time\ndynamical systems (DTDSX collection from SLICOT Working Note 1998-10):\n  E x_{k+1} = A x_k + B u_k\n        y_k = C x_k + D u_k\n\nParameters:\n  def (str): 'D' use default parameters, 'N' use provided parameters\n  nr (list/ndarray): Example identifier [group, number] (int32)\n    Group 1: Parameter-free problems of fixed size\n    Group 2: Parameter-dependent problems of fixed size\n    Group 3: Parameter-free problems of scalable size\n    Group 4: Parameter-dependent problems of scalable size\n  dpar (ndarray): Real parameters, dimension 7 (float64)\n  ipar (ndarray): Integer parameters, dimension 1 (int32)\n\nReturns:\n  (vec, n, m, p, e, a, b, c, d, note, info):\n    - vec: Boolean flags (8 elements):\n      vec[0-2]: N, M, P always available\n      vec[3]: True if E is NOT identity\n      vec[4-6]: A, B, C always available\n      vec[7]: True if D is NOT zero\n    - n, m, p: Problem dimensions (states, inputs, outputs)\n    - e: Descriptor matrix (n x n), identity if vec[3]=False\n    - a: State matrix (n x n)\n    - b: Input matrix (n x m)\n    - c: Output matrix (p x n)\n    - d: Feedthrough matrix (p x m), zero if vec[7]=False\n    - note: Example description string\n    - info: 0=success, 1=data file required, <0=invalid argument\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import bd02ad\n>>> nr = np.array([1, 1], dtype=np.int32)\n>>> dpar = np.zeros(7, dtype=np.float64)\n>>> ipar = np.zeros(1, dtype=np.int32)\n>>> result = bd02ad('D', nr, dpar, ipar)\n>>> vec, n, m, p, e, a, b, c, d, note, info = result",
  "de01od": "Compute convolution or deconvolution of two real signals.\n\nParameters:\n  conv (str): 'C'=convolution, 'D'=deconvolution\n  a (ndarray): First signal (N samples, must be power of 2)\n  b (ndarray): Second signal (N samples, overwritten)\n\nReturns:\n  (a, info): Result signal and exit code\n\nExamples:\n\n>>> from slicot import de01od\n>>> import numpy as np\n>>> a = np.array([0.4862, 0.1948, 0.5788, -0.5861, 0.8254, 0.1815, 0.2904, -0.3599], dtype=float)\n>>> b = np.array([0.2288, 0.3671, 0.6417, 0.3875, 0.2380, 0.4682, 0.5312, 0.6116], dtype=float)\n>>> a_out, info = de01od('C', a, b)\n>>> info\n0",
  "de01pd": "Compute convolution or deconvolution using Hartley transform.\n\nComputes convolution or deconvolution of two real signals A and B using\nthree scrambled Hartley transforms (DG01OD). O(N*log(N)) complexity.\n\nParameters:\n  conv (str): 'C'=convolution, 'D'=deconvolution\n  wght (str): 'A'=weights available, 'N'=not available\n  a (ndarray): First signal (N samples, power of 2, modified in-place)\n  b (ndarray): Second signal (N samples, overwritten)\n  w (ndarray): Weight vector (N - log2(N) elements for N > 1)\n\nReturns:\n  (a, w, info): Result signal, weight vector, and exit code\n\nExamples:\n\n>>> from slicot import de01pd\n>>> import numpy as np\n>>> a = np.array([0.4862, 0.1948, 0.5788, -0.5861, 0.8254, 0.1815, 0.2904, -0.3599],\n...     dtype=float, order='F')\n>>> b = np.array([0.2288, 0.3671, 0.6417, 0.3875, 0.2380, 0.4682, 0.5312, 0.6116],\n...     dtype=float, order='F')\n>>> w = np.zeros(8, dtype=float, order='F')\n>>> a_out, w_out, info = de01pd('C', 'N', a, b, w)\n>>> info\n0",
  "df01md": "Compute sine or cosine transform of a real signal.\n\nTransforms a real signal using FFT-based sine or cosine transform.\nN must be a power of 2 plus 1 (e.g., 5, 9, 17, 33, 65, 129).\n\nParameters:\n  sico (str): 'S'=sine transform, 'C'=cosine transform\n  dt (float): Sampling time of the signal\n  a (ndarray): Signal array (N samples, N = 2^k + 1)\n\nReturns:\n  (a, info): Transform coefficients and exit code\n\nNotes:\n  For sine transform: first and last coefficients are always 0\n  For cosine transform: coefficients scaled by sampling time dt\n\nExamples:\n\n>>> from slicot import df01md\n>>> import numpy as np\n>>> a = np.array([-0.1862, 0.1288, 0.3948, 0.0671, 0.6788, -0.2417, 0.1861, 0.8875,\n...     0.7254, 0.9380, 0.5815, -0.2682, 0.4904, 0.9312, -0.9599, -0.3116, 0.8743],\n...     dtype=float, order='F')\n>>> dt = 1.0\n>>> a_out, info = df01md('C', dt, a)\n>>> info\n0",
  "dg01md": "Compute discrete Fourier transform or inverse of complex signal.\n\nParameters:\n  indi (str): 'D'=forward FFT, 'I'=inverse FFT\n  xr (ndarray): Real part of signal (N samples, must be power of 2)\n  xi (ndarray): Imaginary part of signal (N samples)\n\nReturns:\n  (xr, xi, info): Transformed signal (real, imag) and exit code\n\nExamples:\n\n>>> from slicot import dg01md\n>>> import numpy as np\n>>> xr = np.array([-0.1862, 0.3948, 0.6788, 0.1861, 0.7254, 0.5815, 0.4904, -0.9599], dtype=float)\n>>> xi = np.array([0.1288, 0.0671, -0.2417, 0.8875, 0.9380, -0.2682, 0.9312, -0.3116], dtype=float)\n>>> xr_out, xi_out, info = dg01md('D', xr, xi)\n>>> info\n0",
  "dg01nd": "Compute discrete Fourier transform or inverse of real signal.\n\nTransforms a real signal of 2*N samples, represented as odd/even parts\n(for forward transform) or N+1 complex frequency components (for inverse).\n\nParameters:\n  indi (str): 'D'=forward FFT, 'I'=inverse FFT\n  xr (ndarray): Odd samples (forward) or real part (inverse), N samples\n  xi (ndarray): Even samples (forward) or imag part (inverse), N samples\n\nReturns:\n  (xr, xi, info): N+1 (forward) or N (inverse) components, and exit code\n\nExamples:\n\n>>> from slicot import dg01nd\n>>> import numpy as np\n>>> xr = np.array([-0.1862, 0.3948, 0.6788, 0.1861, 0.7254, 0.5815, 0.4904, -0.9599], dtype=float)\n>>> xi = np.array([0.1288, 0.0671, -0.2417, 0.8875, 0.9380, -0.2682, 0.9312, -0.3116], dtype=float)\n>>> xr_out, xi_out, info = dg01nd('D', xr, xi)\n>>> info\n0",
  "dg01od": "Compute (scrambled) discrete Hartley transform of real signal.\n\nThe Hartley transform is self-inverse: applying twice returns N * original.\nN must be a power of 2.\n\nParameters:\n  scr (str): Scrambling mode: 'N'=none, 'I'=input bit-reversed, 'O'=output bit-reversed\n  wght (str): Weight availability: 'A'=available, 'N'=not available\n  a (ndarray): Signal array (N samples, power of 2)\n  w (ndarray): Weight vector (N - log2(N) elements)\n\nReturns:\n  (a, w, info): Transformed signal, weights (for reuse), and exit code\n\nExamples:\n\n>>> from slicot import dg01od\n>>> import numpy as np\n>>> a = np.array([1., 2., 3., 4., 5., 6., 7., 8.,\n...     9., 10., 11., 12., 13., 14., 15., 16.], dtype=float, order='F')\n>>> n = len(a)\n>>> w = np.zeros(n, dtype=float, order='F')\n>>> a_out, w_out, info = dg01od('N', 'N', a, w)\n>>> info\n0",
  "dgegv": "Compute generalized eigenvalues and eigenvectors.\n\nThis routine is deprecated and replaced by DGGEV.\n\nComputes eigenvalues and optionally left/right eigenvectors of\na real matrix pair (A,B). Given A*x = lambda*B*x, returns\nalpha and beta such that lambda = alpha/beta.\n\nParameters:\n  jobvl (str): 'N' no left eigenvectors, 'V' compute left eigenvectors\n  jobvr (str): 'N' no right eigenvectors, 'V' compute right eigenvectors\n  a (ndarray): Matrix A (n x n, F-order), overwritten on exit\n  b (ndarray): Matrix B (n x n, F-order), overwritten on exit\n  lwork (int, optional): Workspace size (-1 for query, default auto)\n\nReturns:\n  (alphar, alphai, beta, vl, vr, info):\n    alphar: Real parts of eigenvalue numerators (n,)\n    alphai: Imaginary parts of eigenvalue numerators (n,)\n    beta: Denominators of eigenvalues (n,)\n    vl: Left eigenvectors (n x n) if jobvl='V', else empty\n    vr: Right eigenvectors (n x n) if jobvr='V', else empty\n    info: Exit code (0=success)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import dgegv\n>>> a = np.array([\n...     [1.0, 2.0],\n...     [3.0, 4.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> alphar, alphai, beta, vl, vr, info = dgegv('N', 'N', a, b)\n>>> eigs_computed = []\n...     eigs_computed.append(complex(alphar[i], alphai[i]) / beta[i])\n>>> eigs_computed = np.array(sorted(eigs_computed, key=lambda x: x.real))\n...     np.array([e.real for e in eigs_computed]),\n...     rtol=1e-12\n>>> )\n>>> info\n0",
  "dk01md": "Apply anti-aliasing window to a real signal.\n\nParameters:\n  type (str): 'M'=Hamming, 'N'=Hann, 'Q'=Quadratic\n  a (ndarray): Signal array (N samples)\n\nReturns:\n  (a, info): Windowed signal and exit code\n\nExamples:\n\n>>> from slicot import dk01md\n>>> import numpy as np\n>>> a = np.array([0.3262, 0.8723, -0.7972, 0.6673, -0.1722, 0.3237, 0.5263, -0.3275], dtype=float)\n>>> a_out, info = dk01md('M', a)\n>>> info\n0",
  "dlatzm": "Apply Householder matrix generated by DTZRQF.\n\nThis routine is deprecated and replaced by DORMRZ. It applies\na Householder matrix P = I - tau*u*u^T to a matrix C.\n\nIf SIDE = 'L', C = [C1; C2] is overwritten by P*C.\nIf SIDE = 'R', C = [C1, C2] is overwritten by C*P.\n\nParameters:\n  side (str): 'L' for left multiplication, 'R' for right\n  m (int): Number of rows of C\n  n (int): Number of columns of C\n  v (ndarray): Vector in representation of P\n  incv (int): Increment between elements of v (incv != 0)\n  tau (float): Scalar in representation of P\n  c1 (ndarray): First row/column of C (modified in-place)\n  c2 (ndarray): Remaining rows/columns of C (modified in-place)\n\nReturns:\n  (c1, c2): Modified matrices\n\nExamples:\n\n>>> import numpy as np\n>>> m, n = 4, 3\n>>> v = np.random.randn(m - 1).astype(float, order='F')\n>>> tau = 0.5\n>>> incv = 1\n>>> c1 = np.random.randn(1, n).astype(float, order='F')\n>>> c2 = np.random.randn(m - 1, n).astype(float, order='F')\n>>> u = np.vstack([np.ones((1, 1)), v.reshape(-1, 1)])\n>>> P = np.eye(m) - tau * u @ u.T\n>>> from slicot import dlatzm\n>>> c1_out, c2_out = dlatzm('L', m, n, v, incv, tau, c1, c2)\n>>> C_result = np.vstack([c1_out, c2_out])",
  "fb01qd": "Time-varying square root covariance Kalman filter (dense matrices).\n\nCalculates a combined measurement and time update of one iteration\nof the time-varying Kalman filter using square root covariance filter\nwith dense matrices. Performs one recursion of the square root covariance\nfilter algorithm using Householder transformations.\n\nThe algorithm triangularizes:\n  | R^{1/2}_i   C*S_{i-1}    0       |     | (RINOV)^{1/2}_i  0    0 |\n  |                                  | T = |                        |\n  | 0          A*S_{i-1}  B*Q^{1/2}  |     |     AK_i        S_i  0 |\n\nThe state covariance is P_{i|i-1} = S_i * S_i' (left Cholesky factor).\nThe Kalman gain is K_i = AK_i * (RINOV_i)^{-1/2}.\n\nParameters:\n  jobk (str): 'K' = compute Kalman gain K_i, 'N' = K not required (returns AK_i)\n  multbq (str): 'P' = B contains B*Q^{1/2}, Q not used; 'N' = B and Q separate\n  s (ndarray): N x N lower triangular S_{i-1} on entry, S_i on exit (F-order)\n  a (ndarray): N x N state transition matrix A_i (F-order)\n  b (ndarray): N x M input matrix B_i or B_i*Q^{1/2} if MULTBQ='P' (F-order)\n  q (ndarray): M x M lower triangular Q^{1/2}_i if MULTBQ='N' (F-order)\n  c (ndarray): P x N output matrix C_i (F-order)\n  r (ndarray): P x P lower triangular R^{1/2}_i, returns (RINOV)^{1/2}_i (F-order)\n  tol (float, optional): Tolerance for singularity test (default 0.0 = P*P*EPS)\n\nReturns:\n  (s, k, r, rcond, info):\n    s: Updated state covariance square root S_i (lower triangular)\n    k: Kalman gain K_i (N x P) if JOBK='K', else AK_i\n    r: Lower triangular (RINOV)^{1/2}_i\n    rcond: Reciprocal condition number of (RINOV)^{1/2}_i (if JOBK='K')\n    info: Exit code (0=success, 1=singular matrix, <0=parameter error)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import fb01qd\n>>> n, m, p = 4, 2, 2\n>>> s = np.zeros((n, n), order='F', dtype=float)\n>>> a = np.array([\n...     [0.2113, 0.8497, 0.7263, 0.8833],\n...     [0.7560, 0.6857, 0.1985, 0.6525],\n...     [0.0002, 0.8782, 0.5442, 0.3076],\n...     [0.3303, 0.0683, 0.2320, 0.9329],\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.5618, 0.5042],\n...     [0.5896, 0.3493],\n...     [0.6853, 0.3873],\n...     [0.8906, 0.9222],\n...     ], order='F', dtype=float)\n>>> q = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [0.3616, 0.5664, 0.5015, 0.2693],\n...     [0.2922, 0.4826, 0.4368, 0.6325],\n...     ], order='F', dtype=float)\n...     s, k, r_out, rcond, info = fb01qd(\n...     'K', 'N', s, a, b, q, c, r, 0.0\n...     )\n>>> info\n0",
  "fb01rd": "Time-invariant square root covariance Kalman filter (observer Hessenberg form).\n\nCalculates one iteration of the Kalman filter in square root covariance form\nusing the condensed observer Hessenberg form. Exploits sparsity of the\nobserver Hessenberg form for efficiency.\n\nParameters:\n  jobk (str): 'K' = compute Kalman gain K_i, 'N' = not required\n  multbq (str): 'P' = B contains B*Q^{1/2}, Q not used; 'N' = separate\n  s (ndarray): N x N lower triangular S_{i-1} on entry, S_i on exit (F-order)\n  a (ndarray): N x N state matrix in observer Hessenberg form (F-order)\n  b (ndarray): N x M input matrix or B*Q^{1/2} (F-order)\n  q (ndarray): M x M lower triangular Q^{1/2} if MULTBQ='N' (F-order)\n  c (ndarray): P x N output matrix in observer Hessenberg form (F-order)\n  r (ndarray): P x P lower triangular R^{1/2}, returns (RINOV)^{1/2} (F-order)\n  tol (float): Singularity tolerance for gain computation\n\nReturns:\n  (s, r, k, info): Updated S, updated R, gain K, exit code\n\nExamples:\n\n>>> from slicot import fb01rd\n>>> import numpy as np\n>>> n, m, p = 4, 2, 2\n>>> s = np.array([\n...     [0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0]\n...     ], dtype=float, order='F')\n>>> a = np.array([\n...     [0.2113, 0.8497, 0.7263, 0.0000],\n...     [0.7560, 0.6857, 0.1985, 0.6525],\n...     [0.0002, 0.8782, 0.5442, 0.3076],\n...     [0.3303, 0.0683, 0.2320, 0.9329]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [0.5618, 0.5042],\n...     [0.5896, 0.3493],\n...     [0.6853, 0.3873],\n...     [0.8906, 0.9222]\n...     ], dtype=float, order='F')\n>>> q = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [0.3616, 0.0000, 0.0000, 0.0000],\n...     [0.2922, 0.4826, 0.0000, 0.0000]\n...     ], dtype=float, order='F')\n>>> s_work = s.copy(order='F')\n...     s_work, r_out, k_out, info = fb01rd(\n...     'K',       # jobk\n...     'N',       # multbq\n...     s_work, a, b, q, c, r_work,\n...     0.0        # tol\n...     )\n>>> info\n0",
  "fb01sd": "Time-varying square root information Kalman filter (dense matrices).\n\nCalculates a combined measurement and time update of one iteration\nof the time-varying Kalman filter using square root information filter\nwith dense matrices. Performs one recursion of the square root information\nfilter algorithm using Householder transformations.\n\nParameters:\n  jobx (str): 'X' = compute filtered state X_{i+1}, 'N' = not required\n  multab (str): 'P' = AINV, B contain A^{-1}, A^{-1}B; 'N' = AINV, B contain A^{-1}, B\n  multrc (str): 'P' = C contains R^{-1/2}C, RINV not used; 'N' = RINV, C separate\n  sinv (ndarray): N x N upper triangular S_i^{-1} on entry, S_{i+1}^{-1} on exit (F-order)\n  ainv (ndarray): N x N matrix A_i^{-1} (F-order)\n  b (ndarray): N x M input matrix B_i or A_i^{-1}B_i if MULTAB='P' (F-order)\n  rinv (ndarray): P x P upper triangular R_{i+1}^{-1/2} if MULTRC='N' (F-order)\n  c (ndarray): P x N output matrix C_{i+1} or product if MULTRC='P' (F-order)\n  qinv (ndarray): M x M upper triangular Q_i^{-1/2}, updated on exit (F-order)\n  x (ndarray): Filtered state X_i on entry, X_{i+1} on exit if JOBX='X' (length N)\n  rinvy (ndarray): Product R_{i+1}^{-1/2}Y_{i+1} (length P)\n  z (ndarray): Process noise mean Z_i (length M)\n  e (ndarray): Output error estimate E_{i+1} (length P)\n  tol (float): Singularity tolerance for X computation (only if JOBX='X')\n\nReturns:\n  (sinv, qinv, x, e, info):\n    sinv: Updated information square root\n    qinv: Updated process noise innovation square root\n    x: Updated/transformed state estimate\n    e: Estimated error\n    info: Exit code (0=success, 1=singular matrix, <0=parameter error)\n\nExamples:\n\n>>> from slicot import fb01sd\n>>> import numpy as np\n>>> n, m, p = 4, 2, 2\n>>> ainv = np.array([\n...     [0.2113, 0.7560, 0.0002, 0.3303],\n...     [0.8497, 0.6857, 0.8782, 0.0683],\n...     [0.7263, 0.1985, 0.5442, 0.2320],\n...     [0.8833, 0.6525, 0.3076, 0.9329]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [0.3616, 0.5664, 0.5015, 0.2693],\n...     [0.2922, 0.4826, 0.4368, 0.6325]\n...     ], dtype=float, order='F')\n>>> rinv = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [-0.8805, 1.3257],\n...     [2.1039, 0.5207],\n...     [-0.6075, 1.0386],\n...     [-0.8531, 1.1688]\n...     ], dtype=float, order='F')\n>>> qinv = np.array([\n...     [1.1159, 0.2305],\n...     [0.0, 0.6597]\n...     ], dtype=float, order='F')\n>>> sinv = np.array([\n...     [1.0, 0.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 0.0],\n...     [0.0, 0.0, 0.0, 1.0]\n...     ], dtype=float, order='F')\n>>> z = np.array([0.0019, 0.5075], dtype=float)\n>>> x = np.array([0.4076, 0.8408, 0.5017, 0.9128], dtype=float)\n>>> rinvy = np.array([0.2129, 0.5591], dtype=float)\n>>> e = np.zeros(p, dtype=float)\n>>> sinv_out, qinv_out, x_out, e_out, info = fb01sd(\n...     'X',       # jobx\n...     'P',       # multab\n...     'N',       # multrc\n...     sinv, ainv, b, rinv, c, qinv,\n...     x, rinvy, z, e\n...     )\n>>> info\n0",
  "fb01td": "Time-invariant square root information Kalman filter (controller Hessenberg form).\n\nCalculates a combined measurement and time update of one iteration\nof the time-invariant Kalman filter using square root information filter\nwith condensed controller Hessenberg form. Performs one recursion using\nHouseholder transformations, exploiting the sparsity of the Hessenberg form.\n\nParameters:\n  jobx (str): 'X' = compute filtered state X_{i+1}, 'N' = not required\n  multrc (str): 'P' = C contains R^{-1/2}C, RINV not used; 'N' = RINV, C separate\n  sinv (ndarray): N x N upper triangular S_i^{-1} on entry, S_{i+1}^{-1} on exit (F-order)\n  ainv (ndarray): N x N matrix A_i^{-1} in controller Hessenberg form (F-order)\n  ainvb (ndarray): N x M product A_i^{-1}B in controller Hessenberg form (F-order)\n  rinv (ndarray): P x P upper triangular R_{i+1}^{-1/2} if MULTRC='N' (F-order)\n  c (ndarray): P x N output matrix C_{i+1} or product if MULTRC='P' (F-order)\n  qinv (ndarray): M x M upper triangular Q_i^{-1/2}, updated on exit (F-order)\n  x (ndarray): Filtered state X_i on entry, X_{i+1} on exit if JOBX='X' (length N)\n  rinvy (ndarray): Product R_{i+1}^{-1/2}Y_{i+1} (length P)\n  z (ndarray): Process noise mean Z_i (length M)\n  e (ndarray): Output error estimate E_{i+1} (length P)\n  tol (float): Singularity tolerance for X computation (only if JOBX='X')\n\nReturns:\n  (sinv, qinv, x, e, info):\n    sinv: Updated information square root\n    qinv: Updated process noise innovation square root (QINOV)^{-1/2}\n    x: Updated/transformed state estimate\n    e: Estimated error\n    info: Exit code (0=success, 1=singular matrix, <0=parameter error)\n\nExamples:\n\n>>> from slicot import fb01td\n>>> import numpy as np\n>>> data = self.load_example_data()\n>>> sinv = data['sinv'].copy(order='F')\n>>> qinv = data['qinv'].copy(order='F')\n>>> x = data['x'].copy()\n>>> e = np.zeros(data['p'], dtype=float)\n>>> sinv_out, qinv_out, x_out, e_out, info = fb01td(\n...     data['jobx'],\n...     data['multrc'],\n...     sinv,\n...     data['ainv'],\n...     data['ainvb'],\n...     data['rinv'],\n...     data['c'],\n...     qinv,\n...     x,\n...     data['rinvy'],\n...     data['z'],\n...     e,\n...     data['tol']\n...     )\n...     sinv_out[:data['n'], :data['n']],\n...     rtol=1e-3, atol=1e-4,\n...     err_msg=\"SINV output mismatch\"\n>>> )\n...     x_out,\n...     rtol=1e-3, atol=1e-4,\n...     err_msg=\"X output mismatch\"\n>>> )\n>>> info\n0",
  "fb01vd": "One recursion of the conventional Kalman filter.\n\nComputes one update of the Riccati difference equation and the Kalman\nfilter gain. The conventional Kalman filter gain is:\n  K_i = P_{i|i-1} * C_i' * RINOV_i^{-1}\nwhere RINOV_i = C_i * P_{i|i-1} * C_i' + R_i.\n\nThe state covariance matrix is updated by:\n  P_{i+1|i} = A_i * (P_{i|i-1} - K_i * C_i * P_{i|i-1}) * A_i' + B_i * Q_i * B_i'\n\nParameters:\n  n (int): State dimension (n >= 0)\n  m (int): Input dimension (m >= 0)\n  l (int): Output dimension (l >= 0)\n  p (ndarray): N x N state covariance P_{i|i-1} (upper tri, F-order), updated to P_{i+1|i}\n  a (ndarray): N x N state transition matrix A_i (F-order)\n  b (ndarray): N x M input weight matrix B_i (F-order)\n  c (ndarray): L x N output weight matrix C_i (F-order)\n  q (ndarray): M x M process noise covariance Q_i (F-order)\n  r (ndarray): L x L measurement noise covariance R_i (F-order), updated to Cholesky(RINOV)\n  tol (float, optional): Tolerance for singularity test (default 0.0 = L*L*EPS)\n\nReturns:\n  (p, k, r, rcond, info):\n    p: Updated state covariance P_{i+1|i} (upper triangular)\n    k: Kalman filter gain K_i (N x L)\n    r: Upper triangular Cholesky factor of RINOV_i\n    rcond: Reciprocal condition number of RINOV_i\n    info: Exit code (0=success, 1-L=Cholesky failed, L+1=RINOV singular)\n\nExamples:\n\n>>> from slicot import fb01vd\n>>> import numpy as np\n>>> n, m, l = 4, 3, 2\n>>> P = np.array([\n...     [0.5015, 0.4368, 0.2693, 0.6325],\n...     [0.4368, 0.4818, 0.2639, 0.4148],\n...     [0.2693, 0.2639, 0.1121, 0.6856],\n...     [0.6325, 0.4148, 0.6856, 0.8906]\n...     ], order='F', dtype=float)\n>>> A = np.array([\n...     [0.2113, 0.8497, 0.7263, 0.8833],\n...     [0.7560, 0.6857, 0.1985, 0.6525],\n...     [0.0002, 0.8782, 0.5442, 0.3076],\n...     [0.3303, 0.0683, 0.2320, 0.9329]\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [0.0437, 0.7783, 0.5618],\n...     [0.4818, 0.2119, 0.5896],\n...     [0.2639, 0.1121, 0.6853],\n...     [0.4148, 0.6856, 0.8906]\n...     ], order='F', dtype=float)\n>>> Q = np.array([\n...     [0.9329, 0.2146, 0.3126],\n...     [0.2146, 0.2922, 0.5664],\n...     [0.3126, 0.5664, 0.5935]\n...     ], order='F', dtype=float)\n>>> C = np.array([\n...     [0.3873, 0.9488, 0.3760, 0.0881],\n...     [0.9222, 0.3435, 0.7340, 0.4498]\n...     ], order='F', dtype=float)\n>>> R = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> tol = 0.0\n>>> P_updated, K, Rinov_sqrt, rcond, info = fb01vd(n, m, l, P, A, B, C, Q, R, tol)\n...     err_msg=\"P_updated does not match expected\"\n>>> )\n...     err_msg=\"K does not match expected\"\n>>> )\n...     err_msg=\"Rinov_sqrt does not match expected\"\n>>> )\n>>> info\n0",
  "fd01ad": "Fast recursive least-squares filtering.\n\nSolves the least-squares filtering problem recursively in time.\nEach call implements one time update of the solution using a\nfast QR-decomposition based approach.\n\nThe algorithm minimizes an exponentially weighted sum of output errors:\n  sum_{k=1}^{n} [LAMBDA^{2(n-k)} * EOUT(k)^2]\n\nwhere EOUT(n) = YIN(n) - sum_{i=0}^{L-1} h_i * XIN(n-i)\n\nParameters:\n  jp (str): 'B' = both prediction and filtering, 'P' = prediction only\n  l (int): Length of impulse response (l >= 1)\n  lambda (float): Square root of forgetting factor (0 < lambda <= 1)\n  xin (float): Input sample at instant n\n  yin (float): Reference sample at instant n (only if jp='B')\n  efor (float): Square root of prediction error energy at instant (n-1)\n  xf (ndarray): Transformed forward prediction variables (length l)\n  epsbck (ndarray): Backward prediction residuals + conversion factor (length l+1)\n  cteta (ndarray): Cosines of rotation angles (length l)\n  steta (ndarray): Sines of rotation angles (length l)\n  yq (ndarray): Transformed reference vector / tap multipliers (length l, jp='B' only)\n\nReturns:\n  (xf, epsbck, cteta, steta, yq, efor, epos, salph, eout, iwarn, info):\n    xf: Updated forward prediction variables\n    epsbck: Updated backward prediction residuals\n    cteta: Updated cosines of rotation angles\n    steta: Updated sines of rotation angles\n    yq: Updated reference vector (jp='B' only)\n    efor: Updated prediction error energy square root\n    epos: A posteriori forward prediction error residual\n    salph: Opposite of reflection coefficients (length l)\n    eout: A posteriori output error residual (jp='B' only)\n    iwarn: Warning (0=ok, 1=numerical precision issue)\n    info: Exit code (0=success, <0=parameter error)\n\nExamples:\n\n>>> from slicot import fd01ad\n>>> import numpy as np\n>>> l = 2\n>>> lam = 0.99\n>>> delta = 1.0e-2  # soft start\n>>> n_iter = 500\n>>> xf = np.zeros(l, dtype=float)\n>>> epsbck = np.zeros(l + 1, dtype=float)\n>>> epsbck[l] = 1.0\n>>> cteta = np.ones(l, dtype=float)\n>>> steta = np.zeros(l, dtype=float)\n>>> yq = np.zeros(l, dtype=float)\n>>> efor = delta\n...     xin = np.sin(0.3 * float(i))\n...     yin = 0.5 * np.sin(0.3 * float(i)) + 2.0 * np.sin(0.3 * float(i - 1))\n...     xf, epsbck, cteta, steta, yq, efor, epos, eout, salph, iwarn, info = fd01ad(\n...     'B', l, lam, xin, yin, efor, xf, epsbck, cteta, steta, yq\n...     )\n>>> info\n0",
  "ib01ad": "System identification driver - MOESP/N4SID preprocessing and order estimation.\n\nPreprocesses input-output data for estimating state-space matrices and finds\nan estimate of the system order using MOESP or N4SID subspace identification.\n\nParameters:\n  meth (str): 'M' for MOESP, 'N' for N4SID\n  alg (str): 'C' for Cholesky, 'F' for Fast QR, 'Q' for QR\n  jobd (str): 'M' or 'N' for MOESP BD computation mode (not used for N4SID)\n  batch (str): 'F' first, 'I' intermediate, 'L' last, 'O' one block\n  conct (str): 'C' connected blocks, 'N' not connected\n  ctrl (str): 'C' user confirmation, 'N' no confirmation\n  nobr (int): Number of block rows (nobr > 0)\n  m (int): Number of system inputs (m >= 0)\n  l (int): Number of system outputs (l > 0)\n  u (ndarray): NSMP-by-M input data (F-order)\n  y (ndarray): NSMP-by-L output data (F-order)\n  rcond (float): Rank tolerance for N4SID (0 for default)\n  tol (float): Order estimation tolerance (>=0: threshold, <0: gap-based)\n\nReturns:\n  (n, r, sv, iwarn, info): Order, R/S factor, singular values, warning, status\n\nExamples:\n\n>>> from slicot import ib01ad\n>>> import numpy as np\n>>> u, y, nobr, m, l, nsmp = load_html_example_data()\n>>> meth = 'M'\n>>> alg = 'C'\n>>> jobd = 'N'\n>>> batch = 'O'\n>>> conct = 'N'\n>>> ctrl = 'N'\n>>> rcond = 0.0\n>>> tol = -1.0\n>>> n, r, sv, iwarn, info = ib01ad(meth, alg, jobd, batch, conct, ctrl, nobr, m, l, u, y, rcond, tol)\n>>> info\n0",
  "ib01bd": "State-space matrices estimation from N4SID/MOESP triangular factor.\n\nEstimates system matrices (A,C,B,D), optionally noise covariance matrices\n(Q,Ry,S), and Kalman gain K from the triangular factor R computed by IB01AD.\n\nParameters:\n  meth (str): 'M' MOESP, 'N' N4SID, 'C' combined\n  job (str): 'A' all matrices, 'C' A,C only, 'B' B,D only, 'D' D only\n  jobck (str): 'K' Kalman gain, 'C' covariances, 'N' neither\n  nobr (int): Number of block rows (nobr > 1)\n  n (int): System order (0 < n < nobr)\n  m (int): Number of system inputs (m >= 0)\n  l (int): Number of system outputs (l > 0)\n  nsmpl (int): Number of samples\n  r (ndarray): Triangular factor from IB01AD\n  tol (float): Tolerance for rank estimation\n\nReturns:\n  (A, C, B, D, Q, Ry, S, K, iwarn, info): Matrices, covariances, gain, status\n\nExamples:\n\n>>> from slicot import ib01bd\n>>> import numpy as np\n>>> u, y, nobr, m, l, nsmp = load_html_example_data()\n>>> n = 4\n>>> meth_ib01ad = 'M'\n>>> alg = 'C'\n>>> jobd = 'N'\n>>> batch = 'O'\n>>> conct = 'N'\n>>> ctrl = 'N'\n>>> rcond = 0.0\n>>> tol_ad = -1.0\n>>> _n_est, r, _sv, _iwarn_ad, info_ad = ib01ad(meth_ib01ad, alg, jobd, batch, conct, ctrl, nobr, m, l, u, y, rcond, tol_ad)\n>>> meth = 'C'\n>>> job = 'A'\n>>> jobck = 'K'\n>>> tol = 0.0\n>>> A, C, B, D, Q, Ry, S, K, iwarn, info = ib01bd(meth, job, jobck, nobr, n, m, l, nsmp, r, tol)\n>>> info\n0",
  "ib01cd": "Estimate initial state and system matrices B, D (driver routine).\n\nDriver that transforms A to Schur form and calls IB01QD/IB01RD:\n  x(k+1) = A*x(k) + B*u(k)\n  y(k)   = C*x(k) + D*u(k)\n\nParameters:\n  jobx0 (str): 'X' to compute x0, 'N' to set x0=0\n  comuse (str): 'C' compute B/D, 'U' use given B/D, 'N' neither\n  job (str): 'B' compute B only, 'D' compute B and D\n  n (int): System order (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  l (int): Number of outputs (l > 0)\n  a (ndarray): N-by-N state matrix A (F-order)\n  b (ndarray): N-by-M input matrix B (F-order)\n  c (ndarray): L-by-N output matrix C (F-order)\n  d (ndarray): L-by-M feedthrough D (F-order)\n  u (ndarray): NSMP-by-M input data (F-order)\n  y (ndarray): NSMP-by-L output data (F-order)\n  tol (float): Tolerance for rank estimation\n\nReturns:\n  (x0, B, D, V, rcond, iwarn, info):\n  - x0: Estimated initial state (n,)\n  - B: Input matrix (n,m)\n  - D: Feedthrough matrix (l,m)\n  - V: Orthogonal Schur transformation (n,n)\n  - rcond: Reciprocal condition number\n  - iwarn: Warning (6 = A not stable)\n  - info: Exit code (0=success, 1=Schur failed)\n\nExamples:\n\n>>> from slicot import ib01cd\n>>> import numpy as np\n>>> n, m, l = 3, 1, 2\n>>> A, B, C, D, x0_true = create_stable_system(n, m, l, seed=42)\n>>> nsmp = max(n, 20)\n>>> u = np.random.randn(nsmp, m).astype(float, order='F')\n>>> y = simulate_system(A, B, C, D, u, x0_true)\n>>> jobx0 = 'X'\n>>> comuse = 'U'\n>>> job = 'D'\n>>> tol = 0.0\n>>> x0_est, B_out, D_out, V, rcond, iwarn, info = ib01cd(\n...     jobx0, comuse, job, n, m, l, A, B, C, D, u, y, tol\n...     )\n>>> info\n0",
  "ib01md": "Upper triangular factor R of concatenated block Hankel matrices.\n\nConstructs R from QR factorization of block Hankel matrices built from\ninput-output data. Data can be processed sequentially.\n\nParameters:\n  meth (str): 'M' for MOESP, 'N' for N4SID\n  alg (str): 'C' for Cholesky, 'F' for Fast QR, 'Q' for QR\n  batch (str): 'F' first, 'I' intermediate, 'L' last, 'O' one block\n  conct (str): 'C' connected blocks, 'N' not connected\n  nobr (int): Number of block rows (nobr > 0)\n  m (int): Number of system inputs (m >= 0)\n  l (int): Number of system outputs (l > 0)\n  u (ndarray): NSMP-by-M input data (F-order)\n  y (ndarray): NSMP-by-L output data (F-order)\n  r (ndarray, optional): Previous R for sequential (F-order)\n  iwork (ndarray, optional): Previous iwork for sequential\n\nReturns for batch='O' or 'L':\n  (r, iwarn, info): Upper triangular R, warning, exit code\nReturns for batch='F' or 'I':\n  (r, iwork, iwarn, info): R, iwork state, warning, exit code\n\nExamples:\n\n>>> from slicot import ib01md\n>>> import numpy as np\n>>> nobr = 2\n>>> m = 1\n>>> l = 1\n>>> nsmp = 2 * (m + l + 1) * nobr\n>>> u, y = generate_io_data(nsmp, m, l, seed=42)\n>>> meth = 'N'\n>>> alg = 'Q'\n>>> batch = 'O'\n>>> conct = 'N'\n>>> r, iwarn, info = ib01md(meth, alg, batch, conct, nobr, m, l, u, y)\n>>> nr = 2 * (m + l) * nobr\n>>> info\n0",
  "ib01nd": "SVD system order via block Hankel.\n\nComputes SVD of triangular factor R from QR factorization of\nconcatenated block Hankel matrices to determine system order.\n\nParameters:\n  meth (str): 'M' for MOESP, 'N' for N4SID\n  jobd (str): 'M' or 'N' for MOESP BD computation mode\n  nobr (int): Number of block rows (nobr > 0)\n  m (int): Number of system inputs (m >= 0)\n  l (int): Number of system outputs (l > 0)\n  r (ndarray): Upper triangular R matrix, dimension 2*(m+l)*nobr x 2*(m+l)*nobr\n  tol (float): Tolerance for rank estimation (N4SID only)\n\nReturns:\n  (r, sv, rcond1, rcond2, iwarn, info): Processed R, singular values, rconds, status\n\nExamples:\n\n>>> from slicot import ib01nd\n>>> import numpy as np\n>>> nobr = 4\n>>> m = 1\n>>> l = 2\n>>> nr = 2 * (m + l) * nobr  # 24\n>>> lnobr = l * nobr  # 8\n>>> r = np.zeros((nr, nr), order='F', dtype=float)\n...     r[i, j] = np.random.randn()\n...     r[i, i] = abs(r[i, i]) + 10.0\n>>> meth = 'M'\n>>> jobd = 'N'\n>>> tol = 0.0\n>>> r_out, sv, rcond1, rcond2, iwarn, info = ib01nd(meth, jobd, nobr, m, l, r, tol)\n>>> info\n0",
  "ib01od": "Estimate system order from Hankel singular values.\n\nEstimates system order based on singular values of triangular factor\nfrom QR factorization of concatenated block Hankel matrices.\n\nParameters:\n  ctrl (str): 'C' for user confirmation, 'N' for no confirmation\n  nobr (int): Number of block rows (nobr > 0)\n  l (int): Number of system outputs (l > 0)\n  sv (ndarray): Singular values, dimension (l*nobr), descending order\n  tol (float): Tolerance (>=0: threshold, 0: default, <0: gap-based)\n\nReturns:\n  (n, iwarn, info): Estimated order, warning, exit code\n\nExamples:\n\n>>> from slicot import ib01od\n>>> import numpy as np\n>>> nobr = 5\n>>> l = 2\n>>> sv = np.array([10.0, 5.0, 2.0, 1.0, 0.5, 0.1, 0.05, 0.01, 0.001, 0.0001],\n...     order='F', dtype=float)\n>>> tol = 0.5\n>>> ctrl = 'N'  # No user confirmation\n>>> n, iwarn, info = ib01od(ctrl, nobr, l, sv, tol)\n>>> info\n0",
  "ib01oy": "User's confirmation of the system order.\n\nNon-interactive version for library use. Validates parameters and ensures N <= NMAX.\n\nParameters:\n  ns (int): Number of singular values (ns > 0)\n  nmax (int): Maximum value of system order (0 <= nmax <= ns)\n  n (int): Estimated system order (0 <= n <= ns)\n  sv (ndarray): Singular values, dimension (ns), descending order\n\nReturns:\n  (n, info): Validated order, exit code\n\nExamples:\n\n>>> from slicot import ib01oy\n>>> import numpy as np\n>>> ns = 10\n>>> nmax = 8\n>>> n = 5\n>>> sv = np.array([10.0, 5.0, 2.0, 1.0, 0.5, 0.1, 0.05, 0.01, 0.005, 0.001],\n...     order='F', dtype=float)\n>>> n_out, info = ib01oy(ns, nmax, n, sv)\n>>> info\n0",
  "ib01pd": "Estimate system matrices from R factor (subspace identification).\n\nEstimates state-space matrices A, C, B, D from the R factor produced by\nIB01MD. Optionally computes covariance matrices for Kalman gain.\n\nParameters:\n  meth (str): 'M' for MOESP, 'N' for N4SID\n  job (str): 'A' all matrices, 'C' A/C only, 'B' B only, 'D' B/D only\n  jobcv (str): 'C' compute covariances, 'N' no covariances\n  nobr (int): Number of block rows (nobr > 1)\n  n (int): System order (0 < n < nobr)\n  m (int): Number of inputs (m >= 0)\n  l (int): Number of outputs (l > 0)\n  nsmpl (int): Number of samples (for covariances)\n  r (ndarray): R factor from IB01MD (2*(m+l)*nobr x 2*(m+l)*nobr, F-order)\n  tol (float): Tolerance for rank estimation\n  a (ndarray, optional): Input A for JOB='B'/'D' with N4SID\n  c (ndarray, optional): Input C for JOB='B'/'D' with N4SID\n\nReturns (varies by job/jobcv):\n  JOB='A', JOBCV='N': (a, c, b, d, rcond, iwarn, info)\n  JOB='A', JOBCV='C': (a, c, b, d, q, ry, s, o, rcond, iwarn, info)\n  JOB='C', JOBCV='N': (a, c, rcond, iwarn, info)\n  JOB='D', JOBCV='N': (b, d, rcond, iwarn, info)\n\nExamples:\n\n>>> from slicot import ib01pd\n>>> import numpy as np\n>>> nobr = 4\n>>> n = 2\n>>> m = 1\n>>> l = 1\n>>> nsmpl = 100\n>>> nr = 2 * (m + l) * nobr\n>>> r = np.random.randn(nr, nr).astype(float, order='F')\n>>> r = np.triu(r)\n>>> meth = 'M'\n>>> job = 'A'\n>>> jobcv = 'N'\n>>> tol = 0.0\n>>> a, c, b, d, rcond, iwarn, info = ib01pd(\n...     meth, job, jobcv, nobr, n, m, l, nsmpl, r, tol\n...     )\n...     eig_a = np.linalg.eigvals(a)\n>>> info\n0",
  "ib01qd": "Estimate initial state and system matrices B, D.\n\nGiven (A, C) and input/output trajectories, estimates B, D, and x(0)\nfor: x(k+1) = A*x(k) + B*u(k), y(k) = C*x(k) + D*u(k).\nMatrix A must be in real Schur form.\n\nParameters:\n  jobx0 (str): 'X' to compute x(0), 'N' if x(0) known to be zero\n  job (str): 'B' for B only (D=0), 'D' for B and D\n  n (int): System order (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  l (int): Number of outputs (l > 0)\n  a (ndarray): N-by-N state matrix A in Schur form (F-order)\n  c (ndarray): L-by-N output matrix C (F-order)\n  u (ndarray): NSMP-by-M input data (F-order)\n  y (ndarray): NSMP-by-L output data (F-order)\n  tol (float): Tolerance for rank estimation (<= 0 uses machine eps)\n\nReturns:\n  (x0, b, d, rcond_w2, rcond_u, iwarn, info):\n  - x0: Estimated initial state (n,)\n  - b: Estimated input matrix B (n x m)\n  - d: Estimated direct transmission D (l x m)\n  - rcond_w2: Reciprocal condition of W2\n  - rcond_u: Reciprocal condition of U (if JOB='D')\n  - iwarn: Warning (4 = rank-deficient)\n  - info: Exit code (0=success, 2=SVD failed)\n\nExamples:\n\n>>> from slicot import ib01qd\n>>> import numpy as np\n>>> n, m, l = 2, 1, 1\n>>> A, B, C, D, x0_true = create_schur_system(n, m, l, seed=42)\n>>> nsmp = n * m + n + m + 10\n>>> u = np.random.randn(nsmp, m).astype(float, order='F')\n>>> y = simulate_system(A, B, C, D, u, x0_true)\n>>> jobx0 = 'X'\n>>> job = 'D'\n>>> tol = 0.0\n>>> x0_est, B_est, D_est, rcond_w2, rcond_u, iwarn, info = ib01qd(\n...     jobx0, job, n, m, l, A, C, u, y, tol\n...     )\n>>> info\n0",
  "ib01rd": "Estimate initial state for discrete-time LTI system.\n\nGiven (A,B,C,D) and input/output trajectories, estimates initial state x(0)\nfor: x(k+1) = A*x(k) + B*u(k), y(k) = C*x(k) + D*u(k).\nMatrix A must be in real Schur form.\n\nParameters:\n  job (str): 'Z' if D is zero, 'N' if D is not zero\n  n (int): System order (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  l (int): Number of outputs (l > 0)\n  nsmp (int): Number of samples (nsmp >= n)\n  a (ndarray): N-by-N state matrix A in Schur form (F-order)\n  b (ndarray): N-by-M input matrix B (F-order)\n  c (ndarray): L-by-N output matrix C (F-order)\n  d (ndarray): L-by-M direct transmission D (F-order)\n  u (ndarray): NSMP-by-M input data (F-order)\n  y (ndarray): NSMP-by-L output data (F-order)\n  tol (float): Tolerance for rank estimation (<= 0 uses machine eps)\n\nReturns:\n  (x0, rcond, iwarn, info):\n  - x0: Estimated initial state (n,)\n  - rcond: Reciprocal condition of triangular factor\n  - iwarn: Warning (4 = rank-deficient)\n  - info: Exit code (0=success, 2=SVD failed)\n\nExamples:\n\n>>> from slicot import ib01rd\n>>> import numpy as np\n>>> n, m, l = 2, 1, 1\n>>> a = np.array([[0.9, 0.2],\n...     [0.0, 0.8]], order='F', dtype=float)\n>>> b = np.array([[0.5],\n...     [0.3]], order='F', dtype=float)\n>>> c = np.array([[1.0, 0.5]], order='F', dtype=float)\n>>> d = np.array([[0.1]], order='F', dtype=float)\n>>> x0_true = np.array([1.0, -0.5], dtype=float)\n>>> nsmp = 20\n>>> u = np.random.randn(nsmp, m).astype(float, order='F')\n>>> y = _simulate_system(a, b, c, d, u, x0_true)\n>>> x0_est, rcond, iwarn, info = ib01rd('N', n, m, l, nsmp, a, b, c, d, u, y, 0.0)\n>>> info\n0",
  "ib03ad": "Wiener system identification with algorithm choice.\n\nComputes parameters for approximating a Wiener system consisting of a\nlinear state-space part and a static nonlinearity (neural network):\n  x(t+1) = A*x(t) + B*u(t)       (linear state-space)\n  z(t)   = C*x(t) + D*u(t)\n  y(t)   = f(z(t), wb(1:L))      (nonlinear function)\n\nParameters:\n  init (str): 'L' init linear, 'S' init nonlinear, 'B' init both, 'N' no init\n  alg (str): 'D' Cholesky (direct), 'I' CG (iterative)\n  stor (str): 'F' full storage, 'P' packed storage\n  nobr (int): Block rows for MOESP/N4SID (used if init='L' or 'B')\n  m (int): Number of inputs (m >= 0)\n  l (int): Number of outputs (l >= 0, l > 0 if init='L' or 'B')\n  nsmp (int): Number of input/output samples\n  n (int): System order (n < nobr if init='L' or 'B')\n  nn (int): Number of neurons (nn >= 0)\n  itmax1 (int): Max iterations for nonlinear init\n  itmax2 (int): Max iterations for whole optimization\n  u (ndarray): Input samples (nsmp x m, F-order)\n  y (ndarray): Output samples (nsmp x l, F-order)\n  tol1 (float): Tolerance for nonlinear init (< 0 uses sqrt(eps))\n  tol2 (float): Tolerance for whole optimization (< 0 uses sqrt(eps))\n  dwork_seed (ndarray, optional): Seed for random init (4 values)\n  x_init (ndarray, optional): Initial parameters\n  nprint (int, optional): Print control (default 0)\n\nReturns:\n  (x, iwarn, info, dwork): Parameters, warning, status, workspace info\n\nExamples:\n\n>>> from slicot import ib03ad\n>>> import numpy as np\n>>> nobr = 5\n>>> m = 1\n>>> l = 1\n>>> nsmp = 200\n>>> n = 2\n>>> nn = 2\n>>> itmax1 = 50\n>>> itmax2 = 100\n>>> nprint = 0\n>>> tol1 = 1e-4\n>>> tol2 = 1e-4\n>>> u, y = generate_simple_wiener_data(nsmp=nsmp, n=n, m=m, l=l, nn=nn, seed=42)\n>>> bsn = nn * (l + 2) + 1\n>>> lths = n * (l + m + 1) + l * m\n>>> lx = bsn * l + lths\n>>> seed = np.array([1998.0, 1999.0, 2000.0, 2001.0], dtype=float)\n>>> x, iwarn, info, dwork = ib03ad(\n...     'B', 'D', 'F',\n...     nobr, m, l, nsmp, n, nn,\n...     itmax1, itmax2,\n...     u, y,\n...     tol1, tol2,\n...     dwork_seed=seed\n...     )\n>>> info\n0",
  "ib03bd": "Wiener system identification using Levenberg-Marquardt algorithm.\n\nComputes parameters for approximating a Wiener system consisting of a\nlinear state-space part and a static nonlinearity (neural network):\n  x(t+1) = A*x(t) + B*u(t)       (linear state-space)\n  z(t)   = C*x(t) + D*u(t)\n  y(t)   = f(z(t), wb(1:L))      (nonlinear function)\n\nParameters:\n  init (str): 'L' init linear, 'S' init nonlinear, 'B' init both, 'N' no init\n  nobr (int): Block rows for MOESP/N4SID (used if init='L' or 'B')\n  m (int): Number of inputs (m >= 0)\n  l (int): Number of outputs (l >= 0, l > 0 if init='L' or 'B')\n  nsmp (int): Number of input/output samples\n  n (int): System order (n < nobr if init='L' or 'B')\n  nn (int): Number of neurons (nn >= 0)\n  itmax1 (int): Max iterations for nonlinear init\n  itmax2 (int): Max iterations for whole optimization\n  u (ndarray): Input samples (nsmp x m, F-order)\n  y (ndarray): Output samples (nsmp x l, F-order)\n  tol1 (float): Tolerance for nonlinear init (< 0 uses sqrt(eps))\n  tol2 (float): Tolerance for whole optimization (< 0 uses sqrt(eps))\n  dwork_seed (ndarray, optional): Seed for random init (4 values)\n  x_init (ndarray, optional): Initial parameters\n  nprint (int, optional): Print control (default 0)\n\nReturns:\n  (x, iwarn, info, dwork): Parameters, warning, status, workspace info\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ib03bd\n>>> u, y, seed = load_test_data()\n>>> u = u.reshape(-1, 1).astype(float, order='F')\n>>> y = y.reshape(-1, 1).astype(float, order='F')\n>>> nobr = 10\n>>> m = 1\n>>> l = 1\n>>> nsmp = 1024\n>>> n = 4\n>>> nn = 12\n>>> itmax1 = 500\n>>> itmax2 = 1000\n>>> tol1 = 1e-5\n>>> tol2 = 1e-5\n>>> init = 'B'\n>>> bsn = nn * (l + 2) + 1\n>>> lths = n * (l + m + 1) + l * m\n>>> nx = bsn * l + lths\n>>> dwork_seed = seed.astype(float, order='F')\n>>> x, iwarn, info, dwork_out = ib03bd(\n...     init, nobr, m, l, nsmp, n, nn, itmax1, itmax2,\n...     u, y, tol1, tol2, dwork_seed\n...     )\n>>> residual = dwork_out[1]  # DWORK(2) contains residual\n>>> expected_residual = 0.2995840\n...     f\"Residual mismatch: got {residual}, expected ~{expected_residual}\"\n>>> iterations = int(dwork_out[2])  # DWORK(3) contains iterations\n>>> info\n0",
  "ma01ad": "Compute complex square root in real arithmetic.\n\nComputes the complex square root YR + i*YI of XR + i*XI.\nThe result satisfies: YR >= 0 and SIGN(YI) = SIGN(XI).\n\nParameters:\n  xr (float): Real part of input complex number\n  xi (float): Imaginary part of input complex number\n\nReturns:\n  (yr, yi): Real and imaginary parts of square root\n\nExamples:\n\n>>> from slicot import ma01ad\n>>> import numpy as np\n>>> xr, xi = 4.0, 0.0\n>>> yr, yi = ma01ad(xr, xi)",
  "ma01bd": "Compute general product of K real scalars without overflow/underflow.\n\nComputes the product of K scalars stored in array A, controlled by\nsignature array S. Result is ALPHA / BETA * BASE^SCAL.\n\nParameters:\n  base (float): Machine base\n  lgbas (float): Logarithm of BASE\n  k (int): Number of scalars (k >= 1)\n  s (ndarray): Signature array (int32). s[i]=1 multiply, s[i]=-1 divide\n  a (ndarray): Array of real scalars\n  inca (int): Increment for array A (inca != 0)\n\nReturns:\n  (alpha, beta, scal): Scaled result: ALPHA / BETA * BASE^SCAL\n\nExamples:\n\n>>> from slicot import ma01bd\n>>> import numpy as np\n>>> base = 2.0\n>>> lgbas = math.log(base)\n>>> k = 3\n>>> s = np.array([1, 1, 1], dtype=np.int32)\n>>> a = np.array([2.0, 3.0, 4.0], dtype=np.float64)\n>>> inca = 1\n>>> alpha, beta, scal = ma01bd(base, lgbas, k, s, a, inca)\n>>> result = alpha * (base ** scal)",
  "ma01bz": "Compute general product of K complex scalars without overflow/underflow.\n\nComputes the product of K complex scalars stored in array A, controlled by\nsignature array S. Result is ALPHA / BETA * BASE^SCAL.\n\nParameters:\n  base (float): Machine base\n  k (int): Number of scalars (k >= 1)\n  s (ndarray): Signature array (int32). s[i]=1 multiply, s[i]=-1 divide\n  a (ndarray): Array of complex scalars (complex128)\n  inca (int): Increment for array A (inca != 0)\n\nReturns:\n  (alpha, beta, scal): Scaled result: ALPHA / BETA * BASE^SCAL\n                       alpha: complex numerator with 1 <= |alpha| < BASE\n                       beta: complex (0 or 1)\n\nExamples:\n\n>>> from slicot import ma01bz\n>>> import numpy as np\n>>> base = 2.0\n>>> k = 3\n>>> s = np.array([1, 1, 1], dtype=np.int32)\n>>> a = np.array([1+1j, 2+0j, 0+3j], dtype=np.complex128)\n>>> inca = 1\n>>> alpha, beta, scal = ma01bz(base, k, s, a, inca)\n...     result = alpha * (base ** scal)\n...     expected = (1+1j) * (2+0j) * (0+3j)",
  "ma01cd": "Compute sign of sum of two scaled numbers without overflow.\n\nComputes the sign of A * BASE^IA + B * BASE^IB without overflow.\nAny base can be used, but must be the same for both numbers.\n\nParameters:\n  a (float): First real scalar\n  ia (int): Exponent for first scalar (A * BASE^IA)\n  b (float): Second real scalar\n  ib (int): Exponent for second scalar (B * BASE^IB)\n\nReturns:\n  int: Sign of the sum: 1 (positive), 0 (zero), or -1 (negative)\n\nExamples:\n\n>>> from slicot import ma01cd\n>>> import numpy as np\n>>> result = ma01cd(0.0, 0, 0.0, 0)",
  "ma01dd": "Compute approximate symmetric chordal metric for two complex numbers.\n\nComputes D = MIN(|A1 - A2|, |1/A1 - 1/A2|) for A1 = AR1 + i*AI1 and\nA2 = AR2 + i*AI2. The chordal metric is finite even if both numbers\nare infinite, or if one is infinite and the other is finite and nonzero.\n\nParameters:\n  ar1 (float): Real part of first complex number A1\n  ai1 (float): Imaginary part of first complex number A1\n  ar2 (float): Real part of second complex number A2\n  ai2 (float): Imaginary part of second complex number A2\n  eps (float): Relative machine precision (DLAMCH('E'))\n  safemn (float): Safe minimum (DLAMCH('S'))\n\nReturns:\n  float: The approximate symmetric chordal metric D (D >= 0)\n\nExamples:\n\n>>> from slicot import ma01dd\n>>> import numpy as np\n>>> eps, safemn = get_machine_constants()\n>>> ar1, ai1 = 3.0, 4.0\n>>> ar2, ai2 = 3.0, 4.0\n>>> d = ma01dd(ar1, ai1, ar2, ai2, eps, safemn)",
  "ma01dz": "Compute approximate symmetric chordal metric for two complex rationals.\n\nComputes D = MIN(|A1 - A2|, |1/A1 - 1/A2|) for complex numbers A1 and A2\nrepresented as rationals: Aj = (ARj + i*AIj) / Bj.\n\nSpecial cases:\n  - Bj = 0 with nonzero numerator means Aj is infinite\n  - ARj = AIj = Bj = 0 means Aj is not a number (NaN)\n\nParameters:\n  ar1 (float): Real part of numerator of A1\n  ai1 (float): Imaginary part of numerator of A1\n  b1 (float): Denominator of A1 (b1 >= 0)\n  ar2 (float): Real part of numerator of A2\n  ai2 (float): Imaginary part of numerator of A2\n  b2 (float): Denominator of A2 (b2 >= 0)\n  eps (float): Relative machine precision (DLAMCH('E'))\n  safemn (float): Safe minimum (DLAMCH('S'))\n\nReturns:\n  (d1, d2, iwarn): Chordal metric D = d1/d2\n    d1: Numerator (d1 >= 0)\n    d2: Denominator (0 or 1)\n    iwarn: 0 = success, 1 = NaN input (d1 = d2 = 0)\n\nExamples:\n\n>>> from slicot import ma01dz\n>>> import numpy as np\n>>> eps = np.finfo(float).eps\n>>> safemn = np.finfo(float).tiny\n>>> d1, d2, iwarn = ma01dz(1.0, 2.0, 3.0, 1.0, 2.0, 3.0, eps, safemn)",
  "ma02ad": "Transpose all or part of a matrix.\n\nParameters:\n  job (str): 'U' for upper triangular, 'L' for lower, else full matrix\n  a (ndarray): Input matrix (m x n, F-order)\n\nReturns:\n  b (ndarray): Transposed matrix (n x m, F-order)\n\nExamples:\n\n>>> from slicot import ma02ad\n>>> import numpy as np\n>>> a = np.array([[1.0, 4.0],\n...     [2.0, 5.0],\n...     [3.0, 6.0]], order='F')\n>>> b = ma02ad('F', a)\n>>> expected = np.array([[1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0]], order='F')",
  "ma02az": "Transpose or conjugate-transpose a complex matrix.\n\n(Conjugate) transposes all or part of a two-dimensional complex matrix A into another matrix B.\n\nParameters:\n  trans (str): 'T' = transpose (B = A^T), 'C' = conjugate transpose (B = A^H)\n  job (str): 'U' = upper triangular only, 'L' = lower triangular only, other = full matrix\n  a (ndarray): Input complex matrix (m x n, F-order, complex128)\n\nReturns:\n  b (ndarray): Output transposed matrix (n x m, F-order, complex128)\n\nExamples:\n\n>>> from slicot import ma02az\n>>> import numpy as np\n>>> a = np.array([\n...     [1+1j, 2+2j, 3+3j],\n...     [4+4j, 5+5j, 6+6j]\n...     ], order='F', dtype=np.complex128)\n>>> b = ma02az('T', 'F', a)\n>>> expected = np.array([\n...     [1+1j, 4+4j],\n...     [2+2j, 5+5j],\n...     [3+3j, 6+6j]\n...     ], order='F', dtype=np.complex128)",
  "ma02bd": "Reverse order of rows and/or columns of a matrix.\n\nPre/post-multiplies matrix by permutation matrix P with ones\ndown the secondary diagonal.\n\nParameters:\n  side (str): 'L' (P*A), 'R' (A*P), 'B' (P*A*P)\n  a (ndarray): Matrix (m x n, F-order), modified in place\n\nReturns:\n  a: Permuted matrix\n\nExamples:\n\n>>> from slicot import ma02bd\n>>> import numpy as np\n>>> a = np.random.randn(4, 3).astype(float, order='F')\n>>> ma02bd('L', a)",
  "ma02bz": "Reverse order of rows and/or columns of a complex matrix.\n\nPre/post-multiplies complex matrix by permutation matrix P with ones\ndown the secondary diagonal.\n\nParameters:\n  side (str): 'L' (P*A), 'R' (A*P), 'B' (P*A*P)\n  a (ndarray): Complex matrix (m x n, F-order, complex128), modified in place\n\nReturns:\n  a: Permuted complex matrix\n\nExamples:\n\n>>> from slicot import ma02bz\n>>> import numpy as np\n>>> a = (np.random.randn(4, 3) + 1j * np.random.randn(4, 3)).astype(\n...     np.complex128, order='F')\n>>> ma02bz('L', a)",
  "ma02cd": "Pertranspose the central band of a square matrix.\n\nComputes the pertranspose of the central band (KL subdiagonals, main\ndiagonal, KU superdiagonals). Equivalent to P*B'*P where P has ones\non the secondary diagonal.\n\nParameters:\n  a (ndarray): Square matrix (n x n, F-order), modified in place\n  kl (int): Number of subdiagonals to pertranspose (0 <= kl <= n-1)\n  ku (int): Number of superdiagonals to pertranspose (0 <= ku <= n-1)\n\nReturns:\n  a (ndarray): Matrix with central band pertransposed\n\nExamples:\n\n>>> from slicot import ma02cd\n>>> import numpy as np\n>>> a = np.array([\n...     [1.0, 2.0, 3.0, 4.0],\n...     [5.0, 6.0, 7.0, 8.0],\n...     [9.0, 10.0, 11.0, 12.0],\n...     [13.0, 14.0, 15.0, 16.0]\n...     ], order='F', dtype=float)\n>>> expected = np.array([\n...     [16.0, 12.0, 8.0, 4.0],\n...     [15.0, 11.0, 7.0, 3.0],\n...     [14.0, 10.0, 6.0, 2.0],\n...     [13.0, 9.0, 5.0, 1.0]\n...     ], order='F', dtype=float)\n>>> ma02cd(a, 3, 3)",
  "ma02cz": "Pertranspose the central band of a complex square matrix.\n\nComputes the pertranspose of the central band of a square complex matrix.\nThe pertranspose reverses elements along each antidiagonal within the\nspecified band (KL subdiagonals, main diagonal, KU superdiagonals).\nThis is equivalent to P*B'*P where B is the band matrix and P is\na permutation matrix with ones on the secondary diagonal.\n\nParameters:\n  a (ndarray): Complex square matrix (n x n, F-order, complex128), modified in place\n  kl (int): Number of subdiagonals to pertranspose (0 <= kl <= n-1)\n  ku (int): Number of superdiagonals to pertranspose (0 <= ku <= n-1)\n\nReturns:\n  a: Matrix with central band pertransposed\n\nExamples:\n\n>>> from slicot import ma02cz\n>>> import numpy as np\n>>> n = 4\n>>> a = np.array([\n...     [1+1j, 2+2j, 3+3j, 4+4j],\n...     [5+5j, 6+6j, 7+7j, 8+8j],\n...     [9+9j, 10+10j, 11+11j, 12+12j],\n...     [13+13j, 14+14j, 15+15j, 16+16j]\n...     ], order='F', dtype=np.complex128)\n>>> result = ma02cz(a, 0, 0)",
  "ma02dd": "Pack/unpack upper or lower triangle of symmetric matrix.\n\nPacks or unpacks the upper or lower triangle of a symmetric matrix.\nThe packed matrix is stored column-wise in a one-dimensional array.\n\nParameters:\n  job (str): 'P' = pack, 'U' = unpack\n  uplo (str): 'U' = upper triangular, 'L' = lower triangular\n  a/ap (ndarray): For job='P': square matrix to pack (n x n, F-order)\n                  For job='U': packed array (n*(n+1)/2 elements)\n  n (int): Matrix dimension (required for job='U')\n\nReturns:\n  For job='P': packed array (1D, n*(n+1)/2 elements)\n  For job='U': unpacked matrix (n x n, F-order)\n\nExamples:\n\n>>> from slicot import ma02dd\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([[1.0, 2.0, 4.0],\n...     [0.0, 3.0, 5.0],\n...     [0.0, 0.0, 6.0]], order='F')\n>>> ap = ma02dd('P', 'U', a)\n>>> expected = np.array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])",
  "ma02ed": "Store by symmetry the upper or lower triangle of a symmetric matrix.\n\nParameters:\n  uplo (str): 'U' if upper triangle given, 'L' if lower triangle given\n  a (ndarray): Symmetric matrix (n x n, F-order), modified in place\n\nReturns:\n  a (ndarray): Completed symmetric matrix with both triangles\n\nExamples:\n\n>>> import numpy as np\n>>> n = 4\n>>> A_full = np.random.randn(n, n)\n>>> A_full = (A_full + A_full.T) / 2  # Make symmetric\n>>> A = np.triu(A_full).astype(float, order='F')\n>>> from slicot import ma02ed\n>>> ma02ed('U', A)",
  "ma02es": "Store by skew-symmetry the upper or lower triangle of a skew-symmetric matrix.\n\nCompletes a skew-symmetric matrix by negating one triangle to fill the other.\nDiagonal entries are set to zero.\n\nParameters:\n  uplo (str): 'U' if upper triangle given, 'L' if lower triangle given\n  a (ndarray): Skew-symmetric matrix (n x n, F-order), modified in place\n\nReturns:\n  a (ndarray): Completed skew-symmetric matrix (A = -A^T)\n\nExamples:\n\n>>> import numpy as np\n>>> n = 4\n>>> A = np.random.randn(n, n).astype(float, order='F')\n>>> A_upper = np.triu(A, k=1)\n>>> from slicot import ma02es\n>>> ma02es('U', A_upper)",
  "ma02ez": "Store by (skew-)symmetry the upper or lower triangle of a complex matrix.\n\nCompletes a (skew-)symmetric/Hermitian complex matrix by copying one\ntriangle to the other, optionally applying conjugation or negation.\n\nParameters:\n  uplo (str): 'U' (upper given), 'L' (lower given)\n  trans (str): 'T' (transpose), 'C' (conjugate transpose)\n  skew (str): 'G' (general), 'N' (symmetric/Hermitian), 'S' (skew-symmetric/Hermitian)\n  a (ndarray): Complex square matrix (n x n, F-order, complex128), modified in place\n\nReturns:\n  a: Completed (skew-)symmetric/Hermitian matrix\n\nNotes:\n  For TRANS='C', SKEW='N': diagonal imaginary parts set to 0 (Hermitian)\n  For TRANS='C', SKEW='S': diagonal real parts set to 0 (skew-Hermitian)\n\nExamples:\n\n>>> from slicot import ma02ez\n>>> import numpy as np\n>>> A = np.array([\n...     [1+2j,  0+0j,  0+0j],\n...     [3+4j,  5+6j,  0+0j],\n...     [7+8j,  9+10j, 11+12j]\n...     ], order='F', dtype=np.complex128)\n>>> expected = np.array([\n...     [1+0j,  3-4j,  7-8j],\n...     [3+4j,  5+0j,  9-10j],\n...     [7+8j,  9+10j, 11+0j]\n...     ], order='F', dtype=np.complex128)\n>>> ma02ez('L', 'C', 'N', A)",
  "ma02gd": "Column interchanges on a matrix.\n\nPerforms column swaps based on pivot indices.\n\nParameters:\n  n (int): Number of rows\n  a (ndarray): Matrix to permute (n x m, F-order)\n  k1 (int): First pivot index (1-based)\n  k2 (int): Last pivot index (1-based)\n  ipiv (ndarray): Pivot indices (int32)\n  incx (int): Increment for IPIV traversal\n\nReturns:\n  a: Permuted matrix\n\nExamples:\n\n>>> from slicot import ma02gd\n>>> import numpy as np\n>>> n = 3  # rows\n>>> k1, k2 = 1, 2\n>>> incx = 1\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [7.0, 8.0, 9.0]\n...     ], order='F', dtype=float)\n>>> ipiv = np.array([1, 2], dtype=np.int32)\n>>> a_out = ma02gd(n, a, k1, k2, ipiv, incx)\n>>> expected = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [7.0, 8.0, 9.0]\n...     ], order='F', dtype=float)",
  "ma02gz": "Column interchanges on a complex matrix.\n\nPerforms a series of column swaps based on pivot indices. One column\ninterchange is initiated for each of columns K1 through K2 of A.\nColumn-oriented counterpart of LAPACK's ZLASWP (row swaps).\nComplex version of MA02GD.\n\nParameters:\n  n (int): Number of rows of matrix A (n >= 0)\n  a (ndarray): Complex matrix (n x m, F-order, complex128), modified in place\n  k1 (int): First column for which interchange is done (1-based)\n  k2 (int): Last column for which interchange is done (1-based)\n  ipiv (ndarray): Pivot indices (int32). IPIV[k-1]=l means swap columns k and l\n  incx (int): Increment between IPIV elements. Negative = reverse order.\n\nReturns:\n  a: Permuted complex matrix\n\nExamples:\n\n>>> from slicot import ma02gz\n>>> import numpy as np\n>>> n = 3  # rows\n>>> k1, k2 = 1, 2\n>>> incx = 1\n>>> a = np.array([\n...     [1.0+1j, 2.0+2j, 3.0+3j],\n...     [4.0+4j, 5.0+5j, 6.0+6j],\n...     [7.0+7j, 8.0+8j, 9.0+9j]\n...     ], order='F', dtype=complex)\n>>> ipiv = np.array([1, 2], dtype=np.int32)\n>>> a_out = ma02gz(n, a, k1, k2, ipiv, incx)\n>>> expected = np.array([\n...     [1.0+1j, 2.0+2j, 3.0+3j],\n...     [4.0+4j, 5.0+5j, 6.0+6j],\n...     [7.0+7j, 8.0+8j, 9.0+9j]\n...     ], order='F', dtype=complex)",
  "ma02hd": "Check if matrix equals scalar times identity-like matrix.\n\nChecks if A = DIAG*I, where I is an M-by-N matrix with ones on\nthe diagonal and zeros elsewhere.\n\nParameters:\n  job (str): Part of matrix to check: 'U' (upper), 'L' (lower), other (all)\n  a (ndarray): Input matrix (m x n, F-order)\n  diag (float): Scalar to compare diagonal elements against\n\nReturns:\n  bool: True if A = DIAG*I in specified region, False otherwise.\n        Returns False if min(m,n) = 0.\n\nExamples:\n\n>>> from slicot import ma02hd\n>>> import numpy as np\n>>> a = np.eye(3, order='F')\n>>> result = ma02hd('A', a, 1.0)",
  "ma02hz": "Check if complex matrix equals scalar times identity-like matrix.\n\nChecks if A = DIAG*I, where I is an M-by-N matrix with ones on\nthe diagonal and zeros elsewhere. A and DIAG are complex.\n\nParameters:\n  job (str): Part of matrix to check: 'U' (upper), 'L' (lower), other (all)\n  a (ndarray): Input complex matrix (m x n, F-order, complex128)\n  diag (complex): Complex scalar to compare diagonal elements against\n\nReturns:\n  bool: True if A = DIAG*I in specified region, False otherwise.\n        Returns False if min(m,n) = 0.\n\nExamples:\n\n>>> from slicot import ma02hz\n>>> import numpy as np\n>>> a = np.eye(3, dtype=complex, order='F')\n>>> result = ma02hz('A', a, 1.0+0j)",
  "ma02iz": "Compute norm of complex skew-Hamiltonian or Hamiltonian matrix.\n\nComputes the one norm, Frobenius norm, infinity norm, or max element\nof a complex skew-Hamiltonian or Hamiltonian matrix:\n    H = [A, G; Q, -A^H] for Hamiltonian (G=G^H, Q=Q^H)\n    X = [A, G; Q, A^H]  for skew-Hamiltonian (G=-G^H, Q=-Q^H)\n\nNote: For these matrix types, the infinity norm equals the one norm.\n\nParameters:\n  typ (str): 'S' = skew-Hamiltonian, 'H' = Hamiltonian\n  norm (str): '1'/'O' = one norm, 'F'/'E' = Frobenius, 'I' = infinity, 'M' = max\n  a (ndarray): Complex matrix A (n x n, F-order, complex128)\n  qg (ndarray): Complex matrix containing Q and G (n x n+1, F-order, complex128)\n\nReturns:\n  float: The computed norm value\n\nExamples:\n\n>>> from slicot import ma02iz\n>>> import numpy as np\n>>> a = np.zeros((0, 0), dtype=complex, order='F')\n>>> qg = np.zeros((0, 1), dtype=complex, order='F')\n...     result = ma02iz(typ, norm, a, qg)",
  "ma02jd": "Test if a matrix is an orthogonal symplectic matrix.\n\nComputes || Q^T Q - I ||_F for a matrix of the form:\n    Q = [  op(Q1)   op(Q2) ]\n        [ -op(Q2)   op(Q1) ]\n\nwhere Q1 and Q2 are N-by-N matrices. This residual can be used to\ntest whether Q is numerically an orthogonal symplectic matrix.\n\nParameters:\n  ltran1 (bool): If True, op(Q1) = Q1^T; otherwise op(Q1) = Q1\n  ltran2 (bool): If True, op(Q2) = Q2^T; otherwise op(Q2) = Q2\n  q1 (ndarray): Matrix Q1 (n x n, F-order)\n  q2 (ndarray): Matrix Q2 (n x n, F-order)\n\nReturns:\n  float: The computed residual || Q^T Q - I ||_F\n\nExamples:\n\n>>> from slicot import ma02jd\n>>> import numpy as np\n>>> n = 3\n>>> q1 = np.eye(n, order='F', dtype=float)\n>>> q2 = np.zeros((n, n), order='F', dtype=float)\n>>> residual = ma02jd(False, False, q1, q2)",
  "ma02jz": "Test if a complex matrix is a unitary symplectic matrix.\n\nComputes || Q^H Q - I ||_F for a complex matrix of the form:\n    Q = [  op(Q1)   op(Q2) ]\n        [ -op(Q2)   op(Q1) ]\n\nwhere Q1 and Q2 are N-by-N complex matrices. This residual can be used\nto test whether Q is numerically a unitary symplectic matrix.\n\nThis is the complex version of MA02JD.\n\nParameters:\n  ltran1 (bool): If True, op(Q1) = Q1'; otherwise op(Q1) = Q1\n  ltran2 (bool): If True, op(Q2) = Q2'; otherwise op(Q2) = Q2\n  q1 (ndarray): Complex matrix Q1 (n x n, F-order, complex128)\n  q2 (ndarray): Complex matrix Q2 (n x n, F-order, complex128)\n\nReturns:\n  float: The computed residual || Q^H Q - I ||_F\n\nExamples:\n\n>>> from slicot import ma02jz\n>>> import numpy as np\n>>> n = 3\n>>> q1 = np.eye(n, order='F', dtype=complex)\n>>> q2 = np.zeros((n, n), order='F', dtype=complex)\n>>> residual = ma02jz(False, False, q1, q2)",
  "ma02md": "Compute norms of a real skew-symmetric matrix.\n\nComputes the value of the one norm, or the Frobenius norm, or\nthe infinity norm, or the element of largest absolute value\nof a real skew-symmetric matrix.\n\nNote: For skew-symmetric matrices, the infinity norm equals the one norm.\n\nParameters:\n  norm (str): Specifies the value to return:\n              '1' or 'O' = one norm\n              'F' or 'E' = Frobenius norm\n              'I' = infinity norm\n              'M' = max(abs(A(i,j)))\n  uplo (str): 'U' = upper triangular part stored, 'L' = lower triangular part stored\n  a (ndarray): Skew-symmetric matrix (n x n, F-order)\n\nReturns:\n  float: The computed norm value\n\nExamples:\n\n>>> from slicot import ma02md\n>>> import numpy as np\n>>> n = 4\n>>> a = np.zeros((n, n), order='F', dtype=float)\n...     a[i, j] = np.random.randn()\n...     a[j, i] = -a[i, j]\n>>> expected = np.max(np.abs(a))\n>>> norm = ma02md('M', 'U', a)",
  "ma02mz": "Compute norms of a complex skew-Hermitian matrix.\n\nComputes the value of the one norm, or the Frobenius norm, or\nthe infinity norm, or the element of largest absolute value\nof a complex skew-Hermitian matrix.\n\nNote: For skew-Hermitian matrices, the infinity norm equals the one norm.\nDiagonal elements are assumed to be pure imaginary (real parts = 0).\n\nParameters:\n  norm (str): Specifies the value to return:\n              '1' or 'O' = one norm\n              'F' or 'E' = Frobenius norm\n              'I' = infinity norm\n              'M' = max(abs(A(i,j)))\n  uplo (str): 'U' = upper triangular part stored, 'L' = lower triangular part stored\n  a (ndarray): Complex skew-Hermitian matrix (n x n, F-order, complex128)\n\nReturns:\n  float: The computed norm value\n\nExamples:\n\n>>> from slicot import ma02mz\n>>> import numpy as np\n>>> n = 4\n>>> a = np.zeros((n, n), order='F', dtype=complex)\n...     a[i, j] = np.random.randn() + 1j * np.random.randn()\n...     a[j, i] = -np.conj(a[i, j])\n...     a[i, i] = 1j * np.random.randn()\n>>> expected = np.max(np.abs(a))\n>>> norm = ma02mz('M', 'U', a)",
  "ma02nz": "Permute two rows and corresponding columns of a (skew-)symmetric/Hermitian complex matrix.\n\nPermutes rows K and L and the corresponding columns K and L of a\n(skew-)symmetric/Hermitian complex matrix, stored in triangular form.\n\nParameters:\n  uplo (str): 'U' = upper triangular part stored, 'L' = lower triangular part stored\n  trans (str): 'T' = use transposition, 'C' = use conjugate transposition\n  skew (str): 'N' = symmetric/Hermitian, 'S' = skew-symmetric/skew-Hermitian\n  k (int): Smaller index of pair to permute (1-based). If k=0, routine returns.\n  l (int): Larger index of pair to permute (1-based). k <= l <= n.\n  a (ndarray): Complex matrix (n x n, F-order, complex128). Modified in-place.\n\nReturns:\n  a: The permuted matrix (modified in-place)\n\nExamples:\n\n>>> from slicot import ma02nz\n>>> import numpy as np\n>>> A = np.array([\n...     [1+0j,  0+0j,  0+0j],\n...     [2+1j,  3+0j,  0+0j],\n...     [4+2j,  5+3j,  6+0j]\n...     ], order='F', dtype=np.complex128)\n>>> expected = np.array([\n...     [6+0j,  0+0j,  0+0j],\n...     [5-3j,  3+0j,  0+0j],\n...     [4-2j,  2-1j,  1+0j]\n...     ], order='F', dtype=np.complex128)\n>>> ma02nz('L', 'C', 'N', 1, 3, A)",
  "ma02od": "Count zero rows of a real (skew-)Hamiltonian matrix.\n\nComputes the number of zero rows (and zero columns) of a real\n(skew-)Hamiltonian matrix:\n\n      (  A    D   )\n  H = (           )\n      (  E  +/-A' )\n\nThe matrix E is stored in the lower triangular part of DE (columns 1..M),\nand D is stored in the upper triangular part of DE (columns 2..M+1).\n\nParameters:\n  skew (str): 'H' = Hamiltonian (D=D', E=E'),\n              'S' = skew-Hamiltonian (D=-D', E=-E', diagonal assumed zero)\n  a (ndarray): Matrix A (m x m, F-order)\n  de (ndarray): Matrix DE (m x m+1, F-order) containing E (lower tri) and D (upper tri)\n\nReturns:\n  int: Number of zero rows in H\n\nExamples:\n\n>>> from slicot import ma02od\n>>> import numpy as np\n>>> m = 3\n>>> a = np.zeros((m, m), order='F', dtype=float)\n>>> de = np.zeros((m, m + 1), order='F', dtype=float)\n>>> nz = ma02od('H', a, de)",
  "ma02oz": "Count zero rows of a complex (skew-)Hamiltonian matrix.\n\nComputes the number of zero rows (and zero columns) of a complex\n(skew-)Hamiltonian matrix:\n\n      (  A    D   )\n  H = (           )\n      (  E  +/-A' )\n\nThe matrix E is stored in the lower triangular part of DE (columns 1..M),\nand D is stored in the upper triangular part of DE (columns 2..M+1).\n\nFor Hamiltonian: D and E are Hermitian, real parts of diagonal are checked.\nFor skew-Hamiltonian: D and E are skew-Hermitian, imaginary parts of diagonal are checked.\n\nThis is the complex version of MA02OD.\n\nParameters:\n  skew (str): 'H' = Hamiltonian (D=D^H, E=E^H),\n              'S' = skew-Hamiltonian (D=-D^H, E=-E^H)\n  a (ndarray): Complex matrix A (m x m, F-order, complex128)\n  de (ndarray): Complex matrix DE (m x m+1, F-order, complex128)\n\nReturns:\n  int: Number of zero rows in H\n\nExamples:\n\n>>> from slicot import ma02oz\n>>> import numpy as np\n>>> m = 3\n>>> a = np.zeros((m, m), order='F', dtype=complex)\n>>> de = np.zeros((m, m + 1), order='F', dtype=complex)\n>>> nz = ma02oz('H', a, de)",
  "ma02pd": "Compute the number of zero rows and zero columns of a real matrix.\n\nScans the M-by-N matrix A to count rows and columns that contain only zeros.\n\nParameters:\n  a (ndarray): Input matrix (m x n, F-order)\n\nReturns:\n  nzr (int): Number of zero rows\n  nzc (int): Number of zero columns\n\nExamples:\n\n>>> from slicot import ma02pd\n>>> import numpy as np\n>>> a = np.array([[1.0, 0.0, 2.0],\n...     [0.0, 0.0, 0.0],\n...     [3.0, 0.0, 4.0]], order='F')\n>>> nzr, nzc = ma02pd(a)",
  "ma02pz": "Compute the number of zero rows and zero columns of a complex matrix.\n\nScans the M-by-N complex matrix A to count rows and columns that contain only zeros.\nComplex version of MA02PD.\n\nParameters:\n  a (ndarray): Input complex matrix (m x n, F-order, complex128)\n\nReturns:\n  nzr (int): Number of zero rows\n  nzc (int): Number of zero columns\n\nExamples:\n\n>>> from slicot import ma02pz\n>>> import numpy as np\n>>> a = np.array([[1+1j, 0+0j, 2+2j],\n...     [0+0j, 0+0j, 0+0j],\n...     [3+3j, 0+0j, 4+4j]], order='F', dtype=complex)\n>>> nzr, nzc = ma02pz(a)",
  "ma02rd": "Sort vector D and rearrange E with same permutation.\n\nSorts the elements of an n-vector D in increasing (ID='I') or decreasing\n(ID='D') order, and rearranges the elements of an n-vector E using the\nsame permutations.\n\nUses Quick Sort with Insertion sort fallback for arrays of length <= 20.\nBased on LAPACK DLASRT, but applies to E the same interchanges used for D.\n\nParameters:\n  id (str): 'I' for increasing order, 'D' for decreasing order\n  d (ndarray): Vector to sort (n-element, F-order), modified in place\n  e (ndarray): Vector to rearrange (n-element, F-order), modified in place\n\nReturns:\n  d (ndarray): Sorted vector D\n  e (ndarray): Rearranged vector E (same permutation as D)\n  info (int): 0 on success, -i if i-th argument had illegal value\n\nExamples:\n\n>>> import numpy as np\n>>> n = 10\n>>> d = np.random.randn(n).astype(float, order='F')\n>>> e = np.random.randn(n).astype(float, order='F')\n>>> from slicot import ma02rd\n>>> d_out, e_out, info = ma02rd('I', d, e)\n...     j = orig_idx[0]\n>>> info\n0",
  "ma02sd": "Compute smallest nonzero absolute value of matrix elements.\n\nFinds the smallest nonzero |A(i,j)| in a real M-by-N matrix A.\n\nParameters:\n  a (ndarray): Input matrix (m x n, F-order)\n\nReturns:\n  result (float): Smallest nonzero absolute value. Returns 0 if M=0 or N=0.\n                  Returns overflow value if all elements are zero.\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ma02sd\n>>> a = np.array([[1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0]], order='F', dtype=float)\n>>> result = ma02sd(a)",
  "mb01kd": "Skew-symmetric rank-2k update.\n\nComputes C := alpha*A*B' - alpha*B*A' + beta*C (trans='N')\nor C := alpha*A'*B - alpha*B'*A + beta*C (trans='T'/'C')\nwhere C is skew-symmetric.\n\nParameters:\n  uplo (str): 'U' for strictly upper triangle, 'L' for strictly lower\n  trans (str): 'N' for C=alpha*A*B'-alpha*B*A'+beta*C, 'T'/'C' for transpose form\n  n (int): Order of matrix C\n  k (int): If trans='N': columns of A,B. If trans='T': rows of A,B\n  alpha (float): Scalar multiplier\n  a (ndarray): Matrix A (F-order)\n  b (ndarray): Matrix B (F-order)\n  beta (float): Scalar multiplier for C\n  c (ndarray): n-by-n skew-symmetric C (F-order)\n\nReturns:\n  (c, info): Updated C (strictly upper/lower triangle) and exit code",
  "mb01ld": "Skew-symmetric matrix update: R = alpha*R + beta*op(A)*X*op(A)'.\n\nComputes R := alpha*R + beta*op(A)*X*op(A)' where R and X are skew-symmetric.\n\nParameters:\n  uplo (str): 'U' for strictly upper triangle, 'L' for strictly lower\n  trans (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  m (int): Order of R and rows of op(A)\n  n (int): Order of X and columns of op(A)\n  alpha (float): Scalar for R\n  beta (float): Scalar for product\n  r (ndarray): m-by-m skew-symmetric R (F-order)\n  a (ndarray): Matrix A (F-order)\n  x (ndarray): n-by-n skew-symmetric X (F-order)\n\nReturns:\n  (r, info): Updated R (strictly upper/lower triangle) and exit code",
  "mb01md": "Skew-symmetric matrix-vector multiply: y := alpha*A*x + beta*y.\n\nPerforms y := alpha*A*x + beta*y where A is n-by-n skew-symmetric (A = -A').\nModified version of BLAS DSYMV for skew-symmetric matrices.\n\nParameters:\n  uplo (str): 'U' for strictly upper triangle, 'L' for strictly lower\n  n (int): Order of matrix A\n  alpha (float): Scalar for A*x. If alpha=0, A is not referenced\n  a (ndarray): n-by-n skew-symmetric A (F-order)\n  x (ndarray): Input vector x\n  incx (int): Increment for x. If incx<0, x accessed in reverse order\n  beta (float): Scalar for y. If beta=0, y need not be set on input\n  y (ndarray): Input/output vector y\n  incy (int): Increment for y. If incy<0, y accessed in reverse order\n\nReturns:\n  (y, info): Updated y and exit code (0=success, i=param i invalid)",
  "mb01nd": "Skew-symmetric rank 2 update: A := alpha*x*y' - alpha*y*x' + A.\n\nPerforms the skew-symmetric rank 2 operation where A is n-by-n skew-symmetric (A = -A').\nModified version of BLAS DSYR2 for skew-symmetric matrices.\n\nParameters:\n  uplo (str): 'U' for strictly upper triangle, 'L' for strictly lower\n  n (int): Order of matrix A\n  alpha (float): Scalar for rank-2 update. If alpha=0, x and y not referenced\n  x (ndarray): Input vector x\n  incx (int): Increment for x. If incx<0, x accessed in reverse order\n  y (ndarray): Input vector y\n  incy (int): Increment for y. If incy<0, y accessed in reverse order\n  a (ndarray): n-by-n skew-symmetric A (F-order)\n\nReturns:\n  (a, info): Updated A and exit code (0=success, i=param i invalid)",
  "mb01oc": "Symmetric rank 2k update with Hessenberg matrix.\n\nPerforms one of the special symmetric rank 2k operations:\n    R := alpha*R + beta*H*X + beta*X*H'     (trans='N')\n    R := alpha*R + beta*H'*X + beta*X*H     (trans='T' or 'C')\n\nwhere R and X are N-by-N symmetric matrices and H is N-by-N upper Hessenberg.\n\nParameters:\n  uplo (str): 'U' for upper triangle, 'L' for lower triangle of R and X\n  trans (str): 'N' for H*X + X*H', 'T'/'C' for H'*X + X*H\n  n (int): Order of matrices R, H, X\n  alpha (float): Scalar for R. If alpha=0, R need not be set\n  beta (float): Scalar for products. If beta=0, H and X not referenced\n  r (ndarray): n-by-n symmetric R (F-order), triangle per uplo\n  h (ndarray): n-by-n upper Hessenberg H (F-order)\n  x (ndarray): n-by-n symmetric X (F-order), triangle per uplo\n\nReturns:\n  (r, info): Updated R (same triangle) and exit code (0=success, -i=param i invalid)\n\nExamples:\n\n>>> from slicot import mb01oc\n>>> import numpy as np\n>>> n = 3\n>>> alpha = 0.5\n>>> beta = 1.0\n>>> r = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> h = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 7.0, 8.0]\n...     ], order='F', dtype=float)\n>>> x = np.array([\n...     [1.0, 0.5, 0.3],\n...     [0.0, 2.0, 0.4],\n...     [0.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> x_full = make_symmetric(x, 'U')\n>>> r_out, info = mb01oc('U', 'N', n, alpha, beta, r, h, x)\n>>> r_full_in = np.array([\n...     [1.0, 2.0, 3.0],\n...     [2.0, 4.0, 5.0],\n...     [3.0, 5.0, 6.0]\n...     ], order='F', dtype=float)\n>>> hx = h @ x_full\n>>> xht = x_full @ h.T\n>>> info\n0",
  "mb01od": "Symmetric rank 2k update with Hessenberg, symmetric, and triangular matrices.\n\nComputes the matrix formula:\n    R := alpha*R + beta*(op(H)*X*op(E)' + op(E)*X*op(H)')\n\nwhere R and X are N-by-N symmetric matrices, H is N-by-N upper Hessenberg,\nE is N-by-N upper triangular, and op(M) is M or M'.\n\nParameters:\n  uplo (str): 'U' for upper triangle, 'L' for lower triangle of R and X\n  trans (str): 'N' for op(M)=M, 'T'/'C' for op(M)=M'\n  n (int): Order of matrices R, H, X, E\n  alpha (float): Scalar for R. If alpha=0, R need not be set\n  beta (float): Scalar for products. If beta=0, H and X not referenced\n  r (ndarray): n-by-n symmetric R (F-order), triangle per uplo\n  h (ndarray): n-by-n upper Hessenberg H (F-order)\n  x (ndarray): n-by-n symmetric X (F-order), triangle per uplo\n  e (ndarray): n-by-n upper triangular E (F-order)\n\nReturns:\n  (r, info): Updated R (same triangle) and exit code (0=success, -i=param i invalid)\n\nExamples:\n\n>>> from slicot import mb01od\n>>> import numpy as np\n>>> n = 1\n>>> alpha = 1.0\n>>> beta = 1.0\n>>> r = np.array([[2.0]], order='F', dtype=float)\n>>> h = np.array([[3.0]], order='F', dtype=float)\n>>> x = np.array([[4.0]], order='F', dtype=float)\n>>> e = np.array([[5.0]], order='F', dtype=float)\n>>> r_out, info = mb01od('U', 'N', n, alpha, beta, r, h, x, e)\n>>> expected = alpha * 2.0 + 2.0 * beta * 3.0 * 4.0 * 5.0\n>>> info\n0",
  "mb01oe": "Symmetric rank 2k update with Hessenberg and triangular matrices.\n\nPerforms one of the symmetric rank 2k operations:\n    R := alpha*R + beta*H*E' + beta*E*H'     (trans='N')\n    R := alpha*R + beta*H'*E + beta*E'*H     (trans='T' or 'C')\n\nwhere R is N-by-N symmetric, H is N-by-N upper Hessenberg, and E is N-by-N upper triangular.\n\nParameters:\n  uplo (str): 'U' for upper triangle, 'L' for lower triangle of R\n  trans (str): 'N' for H*E' + E*H', 'T'/'C' for H'*E + E'*H\n  n (int): Order of matrices R, H, E\n  alpha (float): Scalar for R. If alpha=0, R need not be set\n  beta (float): Scalar for products. If beta=0, H and E not referenced\n  r (ndarray): n-by-n symmetric R (F-order), triangle per uplo\n  h (ndarray): n-by-n upper Hessenberg H (F-order)\n  e (ndarray): n-by-n upper triangular E (F-order)\n\nReturns:\n  (r, info): Updated R (same triangle) and exit code (0=success, -i=param i invalid)\n\nExamples:\n\n>>> from slicot import mb01oe\n>>> import numpy as np\n>>> n = 3\n>>> alpha = 0.5\n>>> beta = 1.0\n>>> r = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> h = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 7.0, 8.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> r_out, info = mb01oe('U', 'N', n, alpha, beta, r, h, e)\n>>> h_full = h.copy()\n>>> e_full = e.copy()\n>>> r_sym = make_symmetric(np.array([\n...     [1.0, 2.0, 3.0],\n...     [2.0, 4.0, 5.0],\n...     [3.0, 5.0, 6.0]\n...     ], order='F', dtype=float), 'U')\n>>> expected_full = alpha * r_sym + beta * (h_full @ e_full.T) + beta * (e_full @ h_full.T)\n>>> info\n0",
  "mb01oh": "Symmetric rank 2k update with two Hessenberg matrices.\n\nPerforms one of the symmetric rank 2k operations:\n    R := alpha*R + beta*H*A' + beta*A*H'     (trans='N')\n    R := alpha*R + beta*H'*A + beta*A'*H     (trans='T' or 'C')\n\nwhere R is N-by-N symmetric, and H and A are N-by-N upper Hessenberg matrices.\n\nParameters:\n  uplo (str): 'U' for upper triangle, 'L' for lower triangle of R\n  trans (str): 'N' for H*A' + A*H', 'T'/'C' for H'*A + A'*H\n  n (int): Order of matrices R, H, A\n  alpha (float): Scalar for R. If alpha=0, R need not be set\n  beta (float): Scalar for products. If beta=0, H and A not referenced\n  r (ndarray): n-by-n symmetric R (F-order), triangle per uplo\n  h (ndarray): n-by-n upper Hessenberg H (F-order)\n  a (ndarray): n-by-n upper Hessenberg A (F-order)\n\nReturns:\n  (r, info): Updated R (same triangle) and exit code (0=success, -i=param i invalid)\n\nExamples:\n\n>>> from slicot import mb01oh\n>>> import numpy as np\n>>> n = 3\n>>> alpha = 0.5\n>>> beta = 1.0\n>>> r = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> h = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 7.0, 8.0]\n...     ], order='F', dtype=float)\n>>> a = np.array([\n...     [1.0, 1.0, 2.0],\n...     [3.0, 2.0, 1.0],\n...     [0.0, 4.0, 3.0]\n...     ], order='F', dtype=float)\n>>> r_out, info = mb01oh('U', 'N', n, alpha, beta, r, h, a)\n>>> h_full = h.copy()\n>>> a_full = a.copy()\n>>> r_sym = make_symmetric(np.array([\n...     [1.0, 2.0, 3.0],\n...     [2.0, 4.0, 5.0],\n...     [3.0, 5.0, 6.0]\n...     ], order='F', dtype=float), 'U')\n>>> expected_full = alpha * r_sym + beta * (h_full @ a_full.T) + beta * (a_full @ h_full.T)\n>>> info\n0",
  "mb01oo": "Compute P = op(H)*X*op(E)' or P' with H Hessenberg, X symmetric, E triangular.\n\nComputes either P or P', with P defined by the matrix formula:\n    P = op(H)*X*op(E)'\n\nwhere H is an upper Hessenberg matrix, X is a symmetric matrix,\nE is an upper triangular matrix, and op(M) is M or M'.\n\nParameters:\n  uplo (str): 'U' for upper triangular part of X given, 'L' for lower\n  trans (str): 'N' for P=H*X*E', 'T'/'C' for P'=E'*X*H\n  h (ndarray): n-by-n upper Hessenberg H (F-order)\n  x (ndarray): n-by-n symmetric X (F-order), triangle per uplo\n  e (ndarray): n-by-n upper triangular E (F-order)\n\nReturns:\n  (p, info): Output matrix P and exit code (0=success, -i=param i invalid)\n\nExamples:\n\n>>> from slicot import mb01oo\n>>> import numpy as np\n>>> n = 4\n>>> h = make_upper_hessenberg(np.random.randn(n, n).astype(float, order='F'))\n>>> x_full = make_symmetric(np.random.randn(n, n).astype(float, order='F'))\n>>> x = np.triu(x_full).astype(float, order='F')\n>>> e = np.triu(np.random.randn(n, n).astype(float, order='F'))\n>>> p, info = mb01oo('U', 'N', h, x, e)\n>>> info\n0",
  "mb01os": "Compute P = H*X or P = X*H with H Hessenberg and X symmetric.\n\nComputes the matrix product:\n    P := H*X   (trans='N')\n    P := X*H   (trans='T' or 'C')\n\nwhere H is an N-by-N upper Hessenberg matrix and X is an N-by-N symmetric matrix.\n\nParameters:\n  uplo (str): 'U' for upper triangular part of X given, 'L' for lower\n  trans (str): 'N' for P=H*X, 'T'/'C' for P=X*H\n  h (ndarray): n-by-n upper Hessenberg H (F-order)\n  x (ndarray): n-by-n symmetric X (F-order), triangle per uplo\n\nReturns:\n  (p, info): Output matrix P and exit code (0=success, -i=param i invalid)\n\nExamples:\n\n>>> from slicot import mb01os\n>>> import numpy as np\n>>> n = 4\n>>> h = make_upper_hessenberg(np.random.randn(n, n).astype(float, order='F'))\n>>> x_full = make_symmetric(np.random.randn(n, n).astype(float, order='F'))\n>>> x = np.triu(x_full).astype(float, order='F')\n>>> p, info = mb01os('U', 'N', h, x)\n>>> info\n0",
  "mb01ot": "Symmetric rank 2k update with two upper triangular matrices.\n\nPerforms one of the symmetric rank 2k operations:\n    R := alpha*R + beta*E*T' + beta*T*E'     (trans='N')\n    R := alpha*R + beta*E'*T + beta*T'*E     (trans='T' or 'C')\n\nwhere R is N-by-N symmetric, and E and T are N-by-N upper triangular matrices.\n\nParameters:\n  uplo (str): 'U' for upper triangle, 'L' for lower triangle of R\n  trans (str): 'N' for E*T' + T*E', 'T'/'C' for E'*T + T'*E\n  n (int): Order of matrices R, E, T\n  alpha (float): Scalar for R. If alpha=0, R need not be set\n  beta (float): Scalar for products. If beta=0, E and T not referenced\n  r (ndarray): n-by-n symmetric R (F-order), triangle per uplo\n  e (ndarray): n-by-n upper triangular E (F-order)\n  t (ndarray): n-by-n upper triangular T (F-order)\n\nReturns:\n  (r, info): Updated R (same triangle) and exit code (0=success, -i=param i invalid)\n\nExamples:\n\n>>> from slicot import mb01ot\n>>> import numpy as np\n>>> n = 3\n>>> alpha = 0.5\n>>> beta = 1.0\n>>> r = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> t = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 1.0, 2.0],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> r_out, info = mb01ot('U', 'N', n, alpha, beta, r, e, t)\n>>> r_sym = make_symmetric(np.array([\n...     [1.0, 2.0, 3.0],\n...     [2.0, 4.0, 5.0],\n...     [3.0, 5.0, 6.0]\n...     ], order='F', dtype=float), 'U')\n>>> expected_full = alpha * r_sym + beta * (e @ t.T) + beta * (t @ e.T)\n>>> info\n0",
  "mb01pd": "Scale matrix to safe numerical range or undo scaling.\n\nScales matrix so its norm is in [SMLNUM, BIGNUM] or undoes such scaling.\nPreserves ANRM between scale and undo operations.\n\nParameters:\n  scun (str): 'S' to scale, 'U' to undo scaling\n  type (str): Matrix storage type ('G', 'L', 'U', 'H', 'B', 'Q', 'Z')\n  m (int): Number of rows\n  n (int): Number of columns\n  kl (int): Lower bandwidth (for B/Q/Z types)\n  ku (int): Upper bandwidth (for B/Q/Z types)\n  anrm (float): Norm of initial matrix (>= 0)\n  nbl (int): Number of diagonal blocks (0 = no block structure)\n  nrows (ndarray or None): Block sizes (int32)\n  a (ndarray): Matrix array (column-major, shape (m,n))\n\nReturns:\n  (a, info): Modified matrix and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb01pd\n>>> m, n = 4, 3\n>>> a = np.random.randn(m, n).astype(float, order='F')\n>>> anrm = np.linalg.norm(a, ord='fro')\n>>> a_out, info = mb01pd('S', 'G', m, n, 0, 0, anrm, 0, None, a)\n>>> info\n0",
  "mb01qd": "Multiply matrix by scalar CTO/CFROM without overflow/underflow.\n\nParameters:\n  type (str): Matrix storage type ('G', 'L', 'U', 'H', 'B', 'Q', 'Z')\n  m (int): Number of rows\n  n (int): Number of columns\n  kl (int): Lower bandwidth\n  ku (int): Upper bandwidth\n  cfrom (float): Denominator scalar\n  cto (float): Numerator scalar\n  a (ndarray): Matrix array (column-major, shape (m,n))\n  nrows (ndarray, optional): Block sizes\n\nReturns:\n  (a, info): Modified matrix and exit code\n\nExamples:\n\n>>> from slicot import mb01qd\n>>> import numpy as np\n>>> m, n = 3, 3\n>>> a = np.array([\n...     [1.0, 4.0, 7.0],\n...     [2.0, 5.0, 8.0],\n...     [3.0, 6.0, 9.0]\n...     ], dtype=np.float64, order='F')\n>>> cfrom, cto = 2.0, 4.0\n>>> a_result, info = mb01qd(b'G', m, n, 0, 0, cfrom, cto, a)\n>>> expected = np.array([\n...     [2.0, 8.0, 14.0],\n...     [4.0, 10.0, 16.0],\n...     [6.0, 12.0, 18.0]\n...     ], dtype=np.float64, order='F')\n>>> info\n0",
  "mb01rb": "Block triangular symmetric rank-k update (BLAS 3 version).\n\nComputes R = alpha*R + beta*op(A)*B or R = alpha*R + beta*B*op(A)\nwhere only the specified triangle is computed using block algorithm.\n\nParameters:\n  side (str): 'L' for left (R = alpha*R + beta*op(A)*B)\n              'R' for right (R = alpha*R + beta*B*op(A))\n  uplo (str): 'U' for upper triangle, 'L' for lower triangle\n  trans (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  m (int): Order of matrix R\n  n (int): Dimension for product\n  alpha (float): Scalar multiplier for R\n  beta (float): Scalar multiplier for product\n  r (ndarray): m-by-m matrix R (F-order), modified in place\n  a (ndarray): Matrix A (F-order)\n  b (ndarray): Matrix B (F-order)\n\nReturns:\n  (r, info): Updated R (triangle only) and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> m, n = 4, 3\n>>> alpha, beta = 2.0, 0.5\n>>> r = np.random.randn(m, m).astype(float, order='F')\n>>> r = np.triu(r)\n>>> a = np.random.randn(m, n).astype(float, order='F')\n>>> b = np.random.randn(n, m).astype(float, order='F')\n>>> from slicot import mb01rb\n>>> r_out, info = mb01rb('L', 'U', 'N', m, n, alpha, beta, r, a, b)\n>>> info\n0",
  "mb01rd": "Symmetric rank-k matrix update with symmetric matrices.\n\nComputes R = alpha*R + beta*op(A)*X*op(A)' where R and X are symmetric.\n\nParameters:\n  uplo (str): 'U' for upper, 'L' for lower triangle stored\n  trans (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  m (int): Order of R and rows of op(A)\n  n (int): Order of X and columns of op(A)\n  alpha (float): Scalar multiplier for R\n  beta (float): Scalar multiplier for quadratic term\n  r (ndarray): m-by-m symmetric matrix R (F-order)\n  a (ndarray): General matrix A (F-order)\n  x (ndarray): n-by-n symmetric matrix X (F-order)\n\nReturns:\n  (r, info): Updated R and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb01rd\n>>> m, n = 3, 2\n>>> alpha, beta = 1.0, 1.0\n>>> r = np.array([\n...     [4.0, 2.0, 1.0],\n...     [0.0, 3.0, 2.0],\n...     [0.0, 0.0, 5.0]\n...     ], order='F', dtype=float)\n>>> a = np.array([\n...     [1.0, 2.0],\n...     [3.0, 1.0],\n...     [2.0, 4.0]\n...     ], order='F', dtype=float)\n>>> x = np.array([\n...     [2.0, 0.5],\n...     [0.5, 1.0]\n...     ], order='F', dtype=float)\n>>> x_full = np.array([\n...     [2.0, 0.5],\n...     [0.5, 1.0]\n...     ], order='F', dtype=float)\n>>> r_full = np.array([\n...     [4.0, 2.0, 1.0],\n...     [2.0, 3.0, 2.0],\n...     [1.0, 2.0, 5.0]\n...     ], order='F', dtype=float)\n>>> r_out, info = mb01rd('U', 'N', m, n, alpha, beta, r, a, x)\n>>> info\n0",
  "mb01rh": "Symmetric matrix expression with Hessenberg matrix.\n\nComputes R := alpha*R + beta*op(H)*X*op(H)' where R and X are symmetric\nand H is upper Hessenberg.\n\nParameters:\n  uplo (str): 'U' for upper, 'L' for lower triangle stored\n  trans (str): 'N' for op(H)=H, 'T'/'C' for op(H)=H'\n  n (int): Order of matrices R, H, X\n  alpha (float): Scalar multiplier for R\n  beta (float): Scalar multiplier for quadratic form\n  r (ndarray): n-by-n symmetric matrix R (F-order)\n  h (ndarray): n-by-n upper Hessenberg matrix H (F-order)\n  x (ndarray): n-by-n symmetric matrix X (F-order)\n\nReturns:\n  (r, info): Updated R and exit code\n\nExamples:\n\n>>> from slicot import mb01rh\n>>> import numpy as np\n>>> n = 3\n>>> alpha = 0.5\n>>> beta = 1.0\n>>> r = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> h = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 7.0, 8.0]\n...     ], order='F', dtype=float)\n>>> x = np.array([\n...     [1.0, 1.0, 2.0],\n...     [0.0, 2.0, 1.0],\n...     [0.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> r_out, info = mb01rh('U', 'N', n, alpha, beta, r, h, x)\n>>> r_sym = make_symmetric(np.array([\n...     [1.0, 2.0, 3.0],\n...     [2.0, 4.0, 5.0],\n...     [3.0, 5.0, 6.0]\n...     ], order='F', dtype=float), 'U')\n>>> x_sym = make_symmetric(np.array([\n...     [1.0, 1.0, 2.0],\n...     [1.0, 2.0, 1.0],\n...     [2.0, 1.0, 3.0]\n...     ], order='F', dtype=float), 'U')\n>>> expected_full = alpha * r_sym + beta * (h @ x_sym @ h.T)\n>>> info\n0",
  "mb01rt": "Symmetric matrix expression with upper triangular matrix.\n\nComputes R := alpha*R + beta*op(E)*X*op(E)' where R and X are symmetric\nand E is upper triangular.\n\nParameters:\n  uplo (str): 'U' for upper, 'L' for lower triangle stored\n  trans (str): 'N' for op(E)=E, 'T'/'C' for op(E)=E'\n  n (int): Order of matrices R, E, X\n  alpha (float): Scalar multiplier for R\n  beta (float): Scalar multiplier for quadratic form\n  r (ndarray): n-by-n symmetric matrix R (F-order)\n  e (ndarray): n-by-n upper triangular matrix E (F-order)\n  x (ndarray): n-by-n symmetric matrix X (F-order)\n\nReturns:\n  (r, info): Updated R and exit code\n\nExamples:\n\n>>> from slicot import mb01rt\n>>> import numpy as np\n>>> n = 3\n>>> alpha = 0.5\n>>> beta = 1.0\n>>> r = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> x = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> r_out, info = mb01rt('U', 'N', n, alpha, beta, r, e, x)\n>>> r_sym = make_symmetric(np.array([\n...     [1.0, 2.0, 3.0],\n...     [2.0, 4.0, 5.0],\n...     [3.0, 5.0, 6.0]\n...     ], order='F', dtype=float), 'U')\n>>> x_sym = make_symmetric(np.array([\n...     [1.0, 2.0, 3.0],\n...     [2.0, 4.0, 5.0],\n...     [3.0, 5.0, 6.0]\n...     ], order='F', dtype=float), 'U')\n>>> expected_full = alpha * r_sym + beta * (e @ x_sym @ e.T)\n>>> info\n0",
  "mb01ru": "Symmetric matrix update: R = alpha*R + beta*op(A)*X*op(A)'.\n\nComputes R := alpha*R + beta*op(A)*X*op(A)' where R and X are symmetric.\n\nParameters:\n  uplo (str): 'U' for upper triangle, 'L' for lower triangle\n  trans (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  m (int): Order of R, rows of op(A)\n  n (int): Order of X, columns of op(A)\n  alpha (float): Scalar for R\n  beta (float): Scalar for product\n  r (ndarray): m-by-m symmetric R (F-order), modified in place\n  a (ndarray): Matrix A (F-order)\n  x (ndarray): n-by-n symmetric X (F-order)\n\nReturns:\n  (r, info): Updated R (triangle only) and exit code\n\nExamples:\n\n>>> from slicot import mb01ru\n>>> import numpy as np\n>>> m, n = 3, 2\n>>> alpha, beta = 1.5, 0.5\n>>> r = np.array([\n...     [4.0, 2.0, 1.0],\n...     [2.0, 5.0, 3.0],\n...     [1.0, 3.0, 6.0]\n...     ], order='F', dtype=float)\n>>> a = np.random.randn(m, n).astype(float, order='F')\n>>> x = np.array([\n...     [3.0, 1.0],\n...     [1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> r_out, info = mb01ru('U', 'N', m, n, alpha, beta, r, a, x)\n>>> info\n0",
  "mb01rw": "Symmetric matrix transformation (BLAS 2 version).\n\nComputes A := op(Z)*A*op(Z)' where A is symmetric.\n\nParameters:\n  uplo (str): 'U' for upper, 'L' for lower triangle stored\n  trans (str): 'N' for op(Z)=Z, 'T' for op(Z)=Z'\n  m (int): Order of result\n  n (int): Order of input A\n  a (ndarray): max(m,n)-by-max(m,n) symmetric matrix A (F-order)\n  z (ndarray): Transformation matrix Z (F-order)\n\nReturns:\n  (a, info): Transformed A and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb01rw\n>>> m, n = 3, 4\n>>> a = np.array([\n...     [4.0, 2.0, 1.0, 0.5],\n...     [0.0, 3.0, 2.0, 1.0],\n...     [0.0, 0.0, 5.0, 0.5],\n...     [0.0, 0.0, 0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> z = np.array([\n...     [1.0, 0.0, 1.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0],\n...     [0.0, 0.0, 1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> a_full = np.array([\n...     [4.0, 2.0, 1.0, 0.5],\n...     [2.0, 3.0, 2.0, 1.0],\n...     [1.0, 2.0, 5.0, 0.5],\n...     [0.5, 1.0, 0.5, 2.0]\n...     ], order='F', dtype=float)\n>>> expected = z @ a_full @ z.T\n>>> a_out, info = mb01rw('U', 'N', m, n, a, z)\n>>> info\n0",
  "mb01rx": "Triangular symmetric rank-k update.\n\nComputes R = alpha*R + beta*op(A)*B or R = alpha*R + beta*B*op(A)\nwhere only the specified triangle is computed.\n\nParameters:\n  side (str): 'L' for left (R = alpha*R + beta*op(A)*B)\n              'R' for right (R = alpha*R + beta*B*op(A))\n  uplo (str): 'U' for upper triangle, 'L' for lower triangle\n  trans (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  m (int): Order of matrix R\n  n (int): Dimension for product\n  alpha (float): Scalar multiplier for R\n  beta (float): Scalar multiplier for product\n  r (ndarray): m-by-m matrix R (F-order), modified in place\n  a (ndarray): Matrix A (F-order)\n  b (ndarray): Matrix B (F-order)\n\nReturns:\n  (r, info): Updated R (triangle only) and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb01rx\n>>> m, n = 3, 2\n>>> alpha, beta = 2.0, 0.5\n>>> r = np.array([\n...     [4.0, 1.0, 2.0],\n...     [0.0, 3.0, 1.0],\n...     [0.0, 0.0, 5.0]\n...     ], order='F', dtype=float)\n>>> a = np.array([\n...     [1.0, 2.0],\n...     [3.0, 1.0],\n...     [2.0, 4.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [2.0, 1.0, 3.0],\n...     [1.0, 2.0, 1.0]\n...     ], order='F', dtype=float)\n>>> r_out, info = mb01rx('L', 'U', 'N', m, n, alpha, beta, r, a, b)\n>>> info\n0",
  "mb01ry": "Hessenberg matrix product: R = alpha*R + beta*op(H)*B or beta*B*op(H).\n\nComputes upper or lower triangle of the product.\n\nParameters:\n  side (str): 'L' for op(H)*B, 'R' for B*op(H)\n  uplo (str): 'U' for upper triangle, 'L' for lower triangle\n  trans (str): 'N' for op(H)=H, 'T'/'C' for op(H)=H'\n  m (int): Order of matrices\n  alpha (float): Scalar for R\n  beta (float): Scalar for product\n  r (ndarray): m-by-m matrix R (F-order), modified in place\n  h (ndarray): m-by-m upper Hessenberg H (F-order)\n  b (ndarray): m-by-m matrix B (F-order)\n\nReturns:\n  (r, info): Updated R (triangle only) and exit code\n\nExamples:\n\n>>> from slicot import mb01ry\n>>> import numpy as np\n>>> m = 4\n>>> alpha, beta = 1.5, 0.5\n>>> r = np.random.randn(m, m).astype(float, order='F')\n>>> r = (r + r.T) / 2\n>>> h = make_hessenberg(m)\n>>> b = np.random.randn(m, m).astype(float, order='F')\n>>> r_out, info = mb01ry('L', 'U', 'N', m, alpha, beta, r, h, b)\n>>> info\n0",
  "mb01sd": "Scale rows or columns of a matrix by a diagonal matrix.\n\nComputes one of:\n  A := diag(R) * A        (jobs='R', row scaling)\n  A := A * diag(C)        (jobs='C', column scaling)\n  A := diag(R) * A * diag(C)  (jobs='B', both)\n\nParameters:\n  jobs (str): 'R' for row, 'C' for column, 'B' for both\n  a (ndarray): M-by-N matrix A (F-order), modified in-place\n  r (ndarray): Row scale factors, dimension M (not used if jobs='C')\n  c (ndarray): Column scale factors, dimension N (not used if jobs='R')\n\nReturns:\n  a: The scaled matrix\n\nExamples:\n\n>>> from slicot import mb01sd\n>>> import numpy as np\n>>> m, n = 3, 4\n>>> a = np.random.randn(m, n).astype(float, order='F')\n>>> r = np.array([2.0, 0.5, 3.0], dtype=float)\n>>> c = np.empty(0, dtype=float)\n>>> a_out = mb01sd('R', a, r, c)",
  "mb01ss": "Scale a symmetric matrix using diagonal scaling factors.\n\nComputes one of:\n  A := diag(D)*A*diag(D)           (jobs='D', scaling with D)\n  A := inv(diag(D))*A*inv(diag(D)) (jobs='I', scaling with inv(D))\n\nwhere A is an N-by-N symmetric matrix stored in upper or lower triangular form.\n\nParameters:\n  jobs (str): 'D' for scaling with D, 'I' for scaling with inv(D)\n  uplo (str): 'U' for upper triangle stored, 'L' for lower triangle stored\n  a (ndarray): N-by-N symmetric matrix A (F-order), modified in-place\n  d (ndarray): Diagonal scaling factors, dimension N\n\nReturns:\n  a: The scaled matrix (same triangle as input)\n\nExamples:\n\n>>> from slicot import mb01ss\n>>> import numpy as np\n>>> n = 3\n>>> a_full = np.random.randn(n, n)\n>>> a = (a_full + a_full.T) / 2\n>>> a = np.asfortranarray(a)\n>>> d = np.array([2.0, 3.0, 0.5])\n>>> a_result = mb01ss('D', 'U', a.copy(order='F'), d)\n>>> d_mat = np.diag(d)\n>>> expected = d_mat @ a @ d_mat\n...     np.triu(a_result), np.triu(expected), rtol=1e-14\n>>> )",
  "mb01td": "Product of upper quasi-triangular matrices B := A * B.\n\nComputes A * B where A and B are upper quasi-triangular matrices\n(block upper triangular with 1x1 or 2x2 diagonal blocks) with the\nsame structure. Result is returned in B.\n\nParameters:\n  a (ndarray): N-by-N upper quasi-triangular matrix A (F-order)\n  b (ndarray): N-by-N upper quasi-triangular matrix B (F-order)\n\nReturns:\n  (b, info): Product A*B in B, exit code (0=success, 1=structure mismatch)\n\nExamples:\n\n>>> from slicot import mb01td\n>>> import numpy as np\n>>> a = np.array([\n...     [1., 2., 6., 3., 5.],\n...     [-2., -1., -1., 0., -2.],\n...     [0., 0., 1., 5., 1.],\n...     [0., 0., 0., 0., -4.],\n...     [0., 0., 0., 20., 4.]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [5., 5., 1., 5., 1.],\n...     [-2., 1., 3., 0., -4.],\n...     [0., 0., 4., 20., 4.],\n...     [0., 0., 0., 3., 5.],\n...     [0., 0., 0., 1., -2.]\n...     ], order='F', dtype=float)\n>>> expected = np.array([\n...     [1., 7., 31., 139., 22.],\n...     [-8., -11., -9., -32., 2.],\n...     [0., 0., 4., 36., 27.],\n...     [0., 0., 0., -4., 8.],\n...     [0., 0., 0., 64., 92.]\n...     ], order='F', dtype=float)\n>>> result, info = mb01td(a, b)\n>>> info\n0",
  "mb01ud": "Hessenberg matrix product: B = alpha*op(H)*A or alpha*A*op(H).\n\nParameters:\n  side (str): 'L' for B=alpha*op(H)*A, 'R' for B=alpha*A*op(H)\n  trans (str): 'N' for op(H)=H, 'T'/'C' for op(H)=H'\n  m (int): Rows of A and B\n  n (int): Columns of A and B\n  alpha (float): Scalar multiplier\n  h (ndarray): Upper Hessenberg matrix (F-order)\n  a (ndarray): m-by-n matrix A (F-order)\n\nReturns:\n  (b, info): Output matrix B and exit code\n\nExamples:\n\n>>> from slicot import mb01ud\n>>> import numpy as np\n>>> m, n = 4, 3\n>>> alpha = 2.0\n>>> h = make_hessenberg(m)\n>>> a = np.random.randn(m, n).astype(float, order='F')\n>>> b_out, info = mb01ud('L', 'N', m, n, alpha, h, a)\n>>> info\n0",
  "mb01uw": "In-place Hessenberg matrix product: A := alpha*op(H)*A or alpha*A*op(H).\n\nParameters:\n  side (str): 'L' for A:=alpha*op(H)*A, 'R' for A:=alpha*A*op(H)\n  trans (str): 'N' for op(H)=H, 'T'/'C' for op(H)=H'\n  m (int): Rows of A\n  n (int): Columns of A\n  alpha (float): Scalar multiplier (alpha=0 sets A to zero)\n  h (ndarray): Upper Hessenberg matrix (F-order)\n  a (ndarray): m-by-n matrix A (F-order), modified in-place\n\nReturns:\n  (a, info): Modified matrix A and exit code\n\nExamples:\n\n>>> from slicot import mb01uw\n>>> import numpy as np\n>>> m, n = 3, 2\n>>> alpha = 2.0\n>>> h = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 7.0, 8.0]\n...     ], order='F', dtype=float)\n>>> a = np.array([\n...     [1.0, 2.0],\n...     [3.0, 4.0],\n...     [5.0, 6.0]\n...     ], order='F', dtype=float)\n>>> h_full = h.copy()\n>>> h_full[2, 0] = 0.0\n>>> expected = alpha * (h_full @ a)\n>>> result, info = mb01uw('L', 'N', m, n, alpha, h.copy(), a.copy())\n>>> info\n0",
  "mb01ux": "In-place quasi-triangular matrix product: A := alpha*op(T)*A or alpha*A*op(T).\n\nComputes A := alpha*op(T)*A (side='L') or A := alpha*A*op(T) (side='R')\nwhere T is a quasi-triangular matrix (upper or lower) and op(T) is T or T'.\n\nParameters:\n  side (str): 'L' for A:=alpha*op(T)*A, 'R' for A:=alpha*A*op(T)\n  uplo (str): 'U' for upper, 'L' for lower quasi-triangular T\n  trans (str): 'N' for op(T)=T, 'T'/'C' for op(T)=T'\n  m (int): Rows of A\n  n (int): Columns of A\n  alpha (float): Scalar multiplier (alpha=0 sets A to zero)\n  t (ndarray): Quasi-triangular matrix T (F-order)\n  a (ndarray): m-by-n matrix A (F-order), modified in-place\n\nReturns:\n  (a, info): Modified matrix A and exit code\n\nExamples:\n\n>>> from slicot import mb01ux\n>>> import numpy as np\n>>> m, n = 3, 2\n>>> alpha = 2.0\n>>> t = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 7.0, 8.0]\n...     ], order='F', dtype=float)\n>>> a = np.array([\n...     [1.0, 2.0],\n...     [3.0, 4.0],\n...     [5.0, 6.0]\n...     ], order='F', dtype=float)\n>>> t_full = np.triu(t, -1)\n>>> expected = alpha * (t_full @ a)\n>>> result, info = mb01ux('L', 'U', 'N', m, n, alpha, t.copy(), a.copy())\n>>> info\n0",
  "mb01uy": "Compute matrix product T := alpha*op(T)*A or T := alpha*A*op(T).\n\nParameters:\n  side (str): 'L' or 'R' - triangular matrix position\n  uplo (str): 'U' or 'L' - upper/lower triangular\n  trans (str): 'N'/'T'/'C' - transpose option\n  m (int): Number of rows of A\n  n (int): Number of columns of A\n  alpha (float): Scalar multiplier\n  t (ndarray): Triangular matrix (F-order), overwritten with result\n  a (ndarray): Matrix A (F-order)\n\nReturns:\n  (t, info): Result matrix and exit code\n\nExamples:\n\n>>> from slicot import mb01uy\n>>> import numpy as np\n>>> m, n = 3, 2\n>>> alpha = 2.0\n>>> t = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], dtype=np.float64, order='F')\n>>> a = np.array([\n...     [1.0, 4.0],\n...     [2.0, 5.0],\n...     [3.0, 6.0]\n...     ], dtype=np.float64, order='F')\n>>> result, info = mb01uy('L', 'U', 'N', m, n, alpha, t, a)\n>>> expected = alpha * t @ a\n>>> info\n0",
  "mb01uz": "Compute complex matrix product T := alpha*op(T)*A or T := alpha*A*op(T).\n\nComputes T := alpha*op(T)*A (side='L') or T := alpha*A*op(T) (side='R')\nwhere T is a triangular complex matrix and op(T) is T, T', or conj(T').\n\nParameters:\n  side (str): 'L' for T:=alpha*op(T)*A, 'R' for T:=alpha*A*op(T)\n  uplo (str): 'U' for upper triangular, 'L' for lower triangular T\n  trans (str): 'N' for op(T)=T, 'T' for op(T)=T', 'C' for op(T)=conj(T')\n  m (int): Rows of A\n  n (int): Columns of A\n  alpha (complex): Scalar multiplier (alpha=0 sets T to zero)\n  t (ndarray): Triangular complex matrix T (F-order), overwritten with result\n  a (ndarray): m-by-n complex matrix A (F-order)\n\nReturns:\n  (t, info): Result matrix T (m-by-n) and exit code\n\nExamples:\n\n>>> from slicot import mb01uz\n>>> import numpy as np\n>>> m, n = 3, 4\n>>> alpha = 1.5 + 0.5j\n>>> a = (np.random.randn(m, n) + 1j * np.random.randn(m, n)).astype(\n...     complex, order='F'\n...     )\n>>> t_input = np.zeros((m, n), dtype=complex, order='F')\n>>> t_input[:m, :m] = t\n>>> t_result, info = mb01uz('L', 'U', 'N', m, n, alpha, t_input, a)\n>>> info\n0",
  "mb01wd": "Residuals of Lyapunov or Stein equations for Cholesky factored solutions.\n\nComputes:\n  R = alpha*(op(A)'*op(T)'*op(T) + op(T)'*op(T)*op(A)) + beta*R (DICO='C')\nor\n  R = alpha*(op(A)'*op(T)'*op(T)*op(A) - op(T)'*op(T)) + beta*R (DICO='D')\n\nwhere R is symmetric, T is triangular, A is general or Hessenberg,\nand op(M) = M or M'.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  uplo (str): 'U' upper triangular parts, 'L' lower triangular parts\n  trans (str): 'N' for op(M)=M, 'T'/'C' for op(M)=M'\n  hess (str): 'F' A is full, 'H' A is Hessenberg\n  n (int): Order of R, A, T\n  alpha (float): Scalar. If 0, A and T not referenced.\n  beta (float): Scalar. If 0, R need not be set on entry.\n  r (ndarray): Symmetric matrix R (F-order), overwritten with result\n  a (ndarray): Matrix A (F-order), overwritten with intermediate product\n  t (ndarray): Triangular matrix T (F-order)\n\nReturns:\n  (a, r, info): Modified A, result R, and exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb01wd\n>>> import numpy as np\n>>> n = 3\n>>> alpha = 1.0\n>>> beta = 0.5\n>>> A = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [7.0, 8.0, 9.0]\n...     ], order='F', dtype=float)\n>>> T = np.array([\n...     [2.0, 1.0, 0.5],\n...     [0.0, 3.0, 1.0],\n...     [0.0, 0.0, 4.0]\n...     ], order='F', dtype=float)\n>>> R_init = np.array([\n...     [1.0, 0.5, 0.25],\n...     [0.5, 2.0, 0.5],\n...     [0.25, 0.5, 3.0]\n...     ], order='F', dtype=float)\n>>> TT = T.T @ T\n>>> A_work = A.copy(order='F')\n>>> R_work = R_init.copy(order='F')\n>>> A_out, R_out, info = mb01wd('C', 'U', 'N', 'F', n, alpha, beta, R_work, A_work, T)\n>>> info\n0",
  "mb01xd": "Compute U'*U or L*L' for triangular matrix (block algorithm).\n\nComputes the matrix product U'*U or L*L', where U and L are upper and\nlower triangular matrices respectively. Result overwrites input triangle.\nUses BLAS 3 block algorithm for large matrices, otherwise MB01XY.\nThis is a counterpart of LAPACK DLAUUM which computes U*U' or L'*L.\n\nParameters:\n  uplo (str): 'U' for U'*U (upper triangular), 'L' for L*L' (lower triangular)\n  a (ndarray): N-by-N triangular matrix (F-order), overwritten with result\n\nReturns:\n  (a, info): Result matrix (same triangle) and exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb01xd\n>>> import numpy as np\n>>> u = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> expected_upper = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 20.0, 26.0],\n...     [0.0, 0.0, 70.0]\n...     ], order='F', dtype=float)\n>>> result, info = mb01xd('U', u.copy(order='F'))\n>>> info\n0",
  "mb01xy": "Compute U'*U or L*L' for triangular matrix.\n\nComputes the matrix product U'*U or L*L', where U and L are upper and\nlower triangular matrices respectively. Result overwrites input triangle.\nThis is a counterpart of LAPACK DLAUU2 which computes U*U' or L'*L.\n\nParameters:\n  uplo (str): 'U' for U'*U (upper triangular), 'L' for L*L' (lower triangular)\n  a (ndarray): N-by-N triangular matrix (F-order), overwritten with result\n\nReturns:\n  (a, info): Result matrix (same triangle) and exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb01xy\n>>> import numpy as np\n>>> u = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0]\n...     ], order='F', dtype=float)\n>>> expected_upper = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 20.0, 26.0],\n...     [0.0, 0.0, 70.0]\n...     ], order='F', dtype=float)\n>>> result, info = mb01xy('U', u.copy(order='F'))\n>>> info\n0",
  "mb01yd": "Symmetric rank k operation with banded matrix.\n\nPerforms C := alpha*op(A)*op(A)' + beta*C where C is n-by-n symmetric\nand A has L nonzero codiagonals (UPLO='U': L subdiagonals, UPLO='L': L superdiagonals).\nThis is a specialization of DSYRK for banded matrices.\n\nParameters:\n  uplo (str): 'U' upper triangle of C, 'L' lower triangle\n  trans (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  n (int): Order of C\n  k (int): Columns of op(A)\n  l (int): Number of nonzero codiagonals in A\n  alpha (float): Scalar for A*A' term\n  beta (float): Scalar for C term\n  a (ndarray): Matrix A (F-order), banded structure per UPLO\n  c (ndarray): Symmetric matrix C (F-order), updated in place\n\nReturns:\n  (c, info): Updated C and exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb01yd\n>>> import numpy as np\n>>> n, k, l = 3, 3, 1\n>>> alpha, beta = 1.0, 0.0\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 7.0, 8.0]\n...     ], order='F', dtype=float)\n>>> c = np.zeros((n, n), order='F', dtype=float)\n>>> c_result, info = mb01yd('U', 'N', n, k, l, alpha, beta, a, c)\n>>> full_a = a.copy()\n>>> full_a[2, 0] = 0.0\n>>> expected_full = full_a @ full_a.T\n>>> info\n0",
  "mb01zd": "Hessenberg-triangular matrix product.\n\nComputes H := alpha*op(T)*H (SIDE='L') or H := alpha*H*op(T) (SIDE='R'),\nwhere H is m-by-n upper/lower Hessenberg-like matrix with L nonzero\nsubdiagonals/superdiagonals, T is triangular, and op(T) is T or T'.\n\nParameters:\n  side (str): 'L' for left multiply, 'R' for right multiply\n  uplo (str): 'U' for upper triangular T and upper Hessenberg H\n              'L' for lower triangular T and lower Hessenberg H\n  trans (str): 'N' for op(T)=T, 'T'/'C' for op(T)=T'\n  diag (str): 'U' for unit triangular T, 'N' for non-unit\n  m (int): Rows of H\n  n (int): Columns of H\n  l (int): Number of nonzero sub/superdiagonals in H\n  alpha (float): Scalar multiplier\n  t (ndarray): Triangular matrix T (F-order)\n  h (ndarray): Hessenberg-like matrix H (F-order), overwritten with result\n\nReturns:\n  (h, info): Result matrix and exit code (0=success)",
  "mb02cd": "Cholesky factorization of positive definite block Toeplitz matrix.\n\nComputes the Cholesky factor and the generator and/or the Cholesky factor\nof the inverse of a symmetric positive definite (s.p.d.) block Toeplitz\nmatrix T, defined by either its first block row or column.\n\nParameters:\n  job (str): 'G' = generator only\n             'R' = generator and Cholesky factor of T\n             'L' = generator and Cholesky factor of inv(T)\n             'A' = all (generator, L, R)\n             'O' = Cholesky factor of T only\n  typet (str): 'R' = T given by first block row (R upper, L lower)\n               'C' = T given by first block column (R lower, L upper)\n  k (int): Block size, k >= 0\n  n (int): Number of blocks, n >= 0\n  t (ndarray): First block row (k x n*k) or column (n*k x k), F-order\n\nReturns:\n  (g, r, l, cs, info): Generator, Cholesky of T, Cholesky of inv(T),\n    transformation info, exit code. Returns None for unrequested outputs.\n    info=1 means matrix is not positive definite.\n\nExamples:\n\n>>> from slicot import mb02cd\n>>> import numpy as np\n>>> k = 2\n>>> n = 3\n>>> m = n * k\n>>> t = np.array([\n...     [3.0, 1.0, 0.1, 0.1, 0.2, 0.05],\n...     [1.0, 4.0, 0.4, 0.1, 0.04, 0.2]\n...     ], dtype=float, order='F')\n>>> g, r, l, cs, info = mb02cd('A', 'R', k, n, t)\n>>> info\n0",
  "mb02cu": "Bring first part of generator to proper form (block or rank-deficient).\n\nBrings the first part of a generator in proper form using orthogonal\ntransformations and modified hyperbolic rotations. Used for computing\nCholesky factor of symmetric positive semi-definite block Toeplitz\nmatrices and for solving associated linear systems.\n\nParameters:\n  typeg (str): 'D' = column oriented, rank deficient\n               'C' = column oriented, not rank deficient\n               'R' = row oriented, not rank deficient\n  k (int): Number of rows in A1 to process, k >= 0\n  p (int): Columns of positive generator, p >= k\n  q (int): Columns in B. If typeg='D': q >= k; else q >= 0\n  nb (int): Block size for typeg='C' or 'R'. nb <= 0 means unblocked.\n  a1 (ndarray): K-by-K triangular matrix (F-order)\n  a2 (ndarray): Additional part of positive generator (F-order)\n  b (ndarray): Negative generator (F-order)\n  tol (float, optional): Tolerance for rank determination (typeg='D' only)\n\nReturns:\n  (a1, a2, b, rnk, ipvt, cs, info): Transformed matrices, rank,\n    pivot indices, rotation info, and exit code.\n    info=1 means matrix is not numerically positive definite.\n\nExamples:\n\n>>> import numpy as np\n>>> k = 3\n>>> p = 5\n>>> q = 2\n>>> nb = 2\n>>> a1 = np.tril(np.random.randn(k, k)).astype(float, order='F')\n...     a1[i, i] = np.abs(a1[i, i]) + 5.0\n>>> a2 = np.random.randn(k, p - k).astype(float, order='F')\n>>> b = 0.1 * np.random.randn(k, q).astype(float, order='F')\n>>> from slicot import mb02cu\n>>> a1_out, a2_out, b_out, rnk, ipvt, cs, info = mb02cu('C', k, p, q, nb, a1.copy(), a2.copy(), b.copy())\n>>> info\n0",
  "mb02cv": "Apply MB02CU transformations to other generator columns/rows.\n\nApplies the Householder transformations and hyperbolic rotations\ncomputed by MB02CU to other columns/rows of the generator in F1, F2, G.\n\nParameters:\n  typeg (str): 'D' = column rank-deficient, 'C' = column, 'R' = row\n  strucg (str): 'T' = triangular structure, 'N' = no structure\n  k (int): Rows in A1 to process, k >= 0\n  n (int): Rows in F1 (typeg='D','C') or columns (typeg='R'), n >= 0\n  p (int): Columns of positive generator, p >= k\n  q (int): Columns in B, q >= k for typeg='D'\n  nb (int): Block size for typeg='C','R'\n  rnk (int): Rank from MB02CU for typeg='D'\n  a1 (ndarray): K-by-K matrix from MB02CU (typeg='D' only)\n  a2 (ndarray): Matrix A2 from MB02CU\n  b (ndarray): Matrix B from MB02CU\n  f1 (ndarray): First part of positive generator\n  f2 (ndarray): Second part of positive generator\n  g (ndarray): Negative generator part\n  cs (ndarray): Rotation/Householder info from MB02CU\n\nReturns:\n  (f1, f2, g, info): Transformed generators and exit code\n\nExamples:\n\n>>> from slicot import mb02cv\n>>> import numpy as np\n>>> k = 2\n>>> n = 3\n>>> p = 4\n>>> q = 3\n>>> rnk = 2\n>>> nb = 0\n>>> col2 = p - k\n>>> a1 = np.array([\n...     [1.5, 0.3],\n...     [0.2, 1.2]\n...     ], order='F', dtype=float)\n>>> a2 = np.array([\n...     [0.5, 0.1],\n...     [0.3, 0.4]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.8, 0.2, 0.1],\n...     [0.1, 0.7, 0.3]\n...     ], order='F', dtype=float)\n>>> f1 = np.array([\n...     [1.0, 0.5],\n...     [0.3, 1.2],\n...     [0.2, 0.4]\n...     ], order='F', dtype=float)\n>>> f2 = np.array([\n...     [0.6, 0.2],\n...     [0.1, 0.8],\n...     [0.3, 0.1]\n...     ], order='F', dtype=float)\n>>> g = np.array([\n...     [0.4, 0.1, 0.2],\n...     [0.2, 0.5, 0.1],\n...     [0.1, 0.2, 0.3]\n...     ], order='F', dtype=float)\n>>> cs = np.array([\n...     1.1, 0.1, 1.2, 0.2,\n...     0.9, -0.1, 0.95, -0.15,\n...     0.3, 0.4\n...     ], dtype=float)\n>>> f1_out, f2_out, g_out, info = mb02cv('D', 'N', k, n, p, q, nb, rnk,\n...     a1, a2, b, f1, f2, g, cs)\n>>> info\n0",
  "mb02cx": "Bring first blocks of generator to proper form.\n\nBrings the first blocks of a generator into proper form using\nQR/LQ decomposition, Householder transformations, and modified\nhyperbolic rotations. Used for Toeplitz solvers.\n\nParameters:\n  typet (str): 'R' = row-wise, 'C' = column-wise\n  p (int): Rows/columns in A (positive generator), p >= 0\n  q (int): Rows/columns in B (negative generator), q >= 0\n  k (int): Columns/rows to process, p >= k >= 0\n  a (ndarray): Positive generator (p x k) or (k x p), F-order\n  b (ndarray): Negative generator (q x k) or (k x q), F-order\n\nReturns:\n  (a, b, cs, info): Transformed generators, rotation info, exit code\n  info=1 means matrix is not positive definite\n\nExamples:\n\n>>> import numpy as np\n>>> p = 4\n>>> q = 3\n>>> k = 3\n>>> a = np.triu(np.random.randn(p, k)).astype(float, order='F')\n...     a[i, i] = np.abs(a[i, i]) + 5.0\n>>> b = 0.1 * np.random.randn(q, k).astype(float, order='F')\n>>> from slicot import mb02cx\n>>> a_out, b_out, cs, info = mb02cx('R', p, q, k, a.copy(), b.copy())\n>>> info\n0",
  "mb02cy": "Apply hyperbolic transformations to generator columns/rows.\n\nApplies transformations computed by MB02CX on other columns/rows\nof the generator contained in arrays A and B.\n\nParameters:\n  typet (str): 'R' = row-wise, 'C' = column-wise\n  strucg (str): 'T' = triangular structure, 'N' = no special structure\n  p (int): Rows/columns in A (positive generator), p >= 0\n  q (int): Rows/columns in B (negative generator), q >= 0\n  n (int): Columns/rows to process, n >= 0\n  k (int): Columns/rows in H, p >= k >= 0\n  a (ndarray): Positive generator (p x n) or (n x p), F-order\n  b (ndarray): Negative generator (q x n) or (n x q), F-order\n  h (ndarray): Householder info from MB02CX (q x k) or (k x q), F-order\n  cs (ndarray): Rotation/Householder info from MB02CX\n\nReturns:\n  (a, b, info): Transformed generators and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> p = 3\n>>> q = 2\n>>> n = 4\n>>> k = 3\n>>> a = np.random.randn(p, n).astype(float, order='F')\n>>> b = np.random.randn(q, n).astype(float, order='F')\n>>> h = np.random.randn(q, k).astype(float, order='F')\n>>> lcs = 2 * k + min(k, q)\n>>> cs = np.random.randn(lcs).astype(float, order='F')\n>>> cs[0:2*k:2] = np.abs(cs[0:2*k:2]) + 1.0\n>>> from slicot import mb02cy\n>>> a_out, b_out, info = mb02cy('R', 'N', p, q, n, k, a.copy(), b.copy(), h.copy(), cs.copy())\n>>> info\n0",
  "mb02dd": "Update Cholesky factorization of positive definite block Toeplitz matrix.\n\nUpdates the Cholesky factor and the generator and/or the Cholesky factor\nof the inverse of a symmetric positive definite (s.p.d.) block Toeplitz\nmatrix T, given info from MB02CD and additional blocks.\n\nParameters:\n  job (str): 'R' = update generator G and new columns/rows for R\n             'A' = update G, new columns/rows for R and L\n             'O' = only new columns/rows for R\n  typet (str): 'R' = T given by first block row (R upper, L lower)\n               'C' = T given by first block column (R lower, L upper)\n  k (int): Block size, k >= 0\n  m (int): Number of additional blocks in TA, m >= 0\n  n (int): Number of initial blocks in T, n >= 0\n  ta (ndarray): Additional blocks (k x m*k) or (m*k x k), F-order\n  t (ndarray): Transformation info from MB02CD, F-order\n  g (ndarray): Generator from MB02CD, extended for output\n  r (ndarray): Last block column/row of previous R, extended for output\n  cs (ndarray): Transformation info from MB02CD, extended for output\n\nReturns:\n  (ta, g, r, l, cs, info): Updated transformation info, generator,\n    Cholesky of T, Cholesky of inv(T), transformation info, exit code.\n    info=1 means matrix is not positive definite.\n\nExamples:\n\n>>> from slicot import mb02dd\n>>> import numpy as np\n>>> k = 2\n>>> n = 3\n>>> m = 2\n>>> s = (n + m) * k\n>>> t_full = np.array([\n...     [3.0, 1.0, 0.1, 0.1, 0.2, 0.05, 0.1, 0.04, 0.01, 0.02],\n...     [1.0, 4.0, 0.4, 0.1, 0.04, 0.2, 0.03, 0.02, 0.03, 0.01]\n...     ], dtype=float, order='F')\n>>> t = t_full[:, :n*k].copy()\n>>> ta = t_full[:, n*k:].copy()\n>>> g, r, l, cs, info = mb02cd('A', 'R', k, n, t)\n>>> r_in = np.zeros((s, m * k), dtype=float, order='F')\n>>> r_in[k:n*k+k, 0:k] = r[:n*k, (n-1)*k:n*k].copy()\n>>> g_in = np.zeros((2 * k, s), dtype=float, order='F')\n>>> g_in[:, :n*k] = g.copy()\n>>> cs_in = np.zeros(3 * (n + m - 1) * k, dtype=float, order='F')\n>>> cs_in[:3*(n-1)*k] = cs.copy()\n>>> ta_out, g_out, r_out, l_out, cs_out, info = mb02dd(\n...     'A', 'R', k, m, n, ta.copy(), t, g_in, r_in, cs_in\n...     )\n>>> info\n0",
  "mb02ed": "Solve symmetric positive definite block Toeplitz system.\n\nSolves T*X = B or X*T = B where T is a symmetric positive definite\nblock Toeplitz matrix defined by its first block row or column.\n\nParameters:\n  typet (str): 'R' = first block row, solve X*T = B\n               'C' = first block column, solve T*X = B\n  k (int): Block size, k >= 0\n  n (int): Number of blocks, n >= 0\n  nrhs (int): Number of right-hand sides, nrhs >= 0\n  t (ndarray): Block Toeplitz data (k x n*k) or (n*k x k), F-order\n  b (ndarray): Right-hand side (nrhs x n*k) or (n*k x nrhs), F-order\n\nReturns:\n  (x, t_out, info): Solution matrix, modified T, exit code\n  info=1 means matrix is not positive definite\n\nExamples:\n\n>>> import numpy as np\n>>> n = 3\n>>> k = 3\n>>> nrhs = 2\n>>> t = np.array([\n...     [3.0, 1.0, 0.2],\n...     [1.0, 4.0, 0.4],\n...     [0.2, 0.4, 5.0],\n...     [0.1, 0.1, 0.2],\n...     [0.2, 0.04, 0.03],\n...     [0.05, 0.2, 0.1],\n...     [0.1, 0.03, 0.1],\n...     [0.04, 0.02, 0.2],\n...     [0.01, 0.03, 0.02],\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 2.0],\n...     [1.0, 2.0],\n...     [1.0, 2.0],\n...     [1.0, 2.0],\n...     [1.0, 2.0],\n...     [1.0, 2.0],\n...     [1.0, 2.0],\n...     [1.0, 2.0],\n...     [1.0, 2.0],\n...     ], order='F', dtype=float)\n>>> from slicot import mb02ed\n>>> x, t_out, info = mb02ed('C', k, n, nrhs, t.copy(), b.copy())\n>>> info\n0",
  "mb02fd": "Incomplete Cholesky factor of positive definite block Toeplitz matrix.\n\nComputes the incomplete Cholesky (ICC) factor of a symmetric positive\ndefinite block Toeplitz matrix T. Supports incremental computation.\n\nParameters:\n  typet (str): 'R' = first block row, R is upper trapezoidal\n               'C' = first block column, R is lower trapezoidal\n  k (int): Block size, k >= 0\n  n (int): Number of blocks, n >= 0\n  p (int): Previously computed block rows/columns, 0 <= p <= n\n  s (int): Block rows/columns to compute, 0 <= s <= n-p\n  t (ndarray): Block Toeplitz data, F-order\n               If P=0: first block row/column of T\n               If P>0: negative generator from previous call\n\nReturns:\n  (r, info): ICC factor R (upper/lower trapezoidal), exit code\n  info=1 means matrix is not positive definite\n\nExamples:\n\n>>> from slicot import mb02fd\n>>> import numpy as np\n>>> k = 2\n>>> n = 4\n>>> m = n * k\n>>> t = np.array([\n...     [3.0, 1.0, 0.1, 0.1, 0.2, 0.05, 0.2, 0.3],\n...     [1.0, 4.0, 0.4, 0.1, 0.04, 0.2, 0.1, 0.2]\n...     ], dtype=float, order='F')\n>>> r, info = mb02fd('R', k, n, 0, n, t.copy())\n>>> info\n0",
  "mb02gd": "Cholesky factorization of banded symmetric positive definite block Toeplitz matrix.\n\nComputes the Cholesky factor of a banded s.p.d. block Toeplitz matrix.\nSupports incremental block-by-block computation.\n\nParameters:\n  typet (str): 'R' = first block row, factor is upper triangular\n               'C' = first block column, factor is lower triangular\n  triu (str): 'N' = last block has no special structure\n              'T' = last block is triangular\n  k (int): Block size, k >= 0\n  n (int): Number of blocks. n >= 1 for triu='N', n >= 2 for triu='T'\n  nl (int): Lower block bandwidth (nl+1 nonzero blocks in first column)\n  p (int): Previously computed block rows/columns, 0 <= p <= n\n  s (int): Block rows/columns to compute, 0 <= s <= n-p\n  t (ndarray): Block Toeplitz data (k x (nl+1)*k) or ((nl+1)*k x k), F-order\n\nReturns:\n  (rb, info): Cholesky factor in banded storage format, exit code\n  info=1 means matrix is not positive definite\n\nExamples:\n\n>>> from slicot import mb02gd\n>>> import numpy as np\n>>> k = 2\n>>> n = 4\n>>> nl = 2\n>>> typet = 'R'\n>>> triu = 'T'\n>>> t = np.array([\n...     [3.0000, 1.0000, 0.1000, 0.4000, 0.2000, 0.0000],\n...     [0.0000, 4.0000, 0.1000, 0.1000, 0.0500, 0.2000]\n...     ], dtype=float, order='F')\n>>> rb, info = mb02gd(typet, triu, k, n, nl, 0, n, t.copy())\n>>> info\n0",
  "mb02hd": "Cholesky factorization of T'T for banded block Toeplitz matrix.\n\nComputes R*R' = T'*T where T is a banded K*M-by-L*N block Toeplitz matrix.\nThe lower triangular factor R is returned in band storage format.\nSupports incremental block-by-block computation.\n\nParameters:\n  triu (str): 'N' = TC/TR have no special structure\n              'T' = last blocks are triangular\n  k (int): Number of rows in blocks of T, k >= 0\n  l (int): Number of columns in blocks of T, l >= 0\n  m (int): Number of blocks in first block column of T, m >= 1\n  ml (int): Lower block bandwidth, 0 <= ml < m\n  n (int): Number of blocks in first block row of T, n >= 1\n  nu (int): Upper block bandwidth, 0 <= nu < n\n  p (int): Previously computed block columns of R, p >= 0\n  s (int): Block columns of R to compute, s >= 0\n  tc (ndarray): First block column data ((ml+1)*k x l, F-order)\n  tr (ndarray): Blocks 2 to nu+1 of first block row (k x nu*l, F-order)\n\nReturns:\n  (rb, info): Lower triangular factor R in band storage, exit code\n  info=1 means full rank condition not satisfied\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb02hd\n>>> k = 2\n>>> l = 2\n>>> m = 6\n>>> ml = 2\n>>> n = 5\n>>> nu = 1\n>>> p = 0\n>>> s = (min(m * k, n * l) + l - 1) // l  # s = 5\n>>> triu = 'N'\n>>> tc = np.array([\n...     [4.0, 4.0],\n...     [1.0, 3.0],\n...     [2.0, 1.0],\n...     [2.0, 2.0],\n...     [4.0, 4.0],\n...     [3.0, 4.0],\n...     ], order='F', dtype=float)\n>>> tr = np.array([\n...     [1.0, 3.0],\n...     [2.0, 1.0],\n...     ], order='F', dtype=float)\n>>> rb, info = mb02hd(triu, k, l, m, ml, n, nu, p, s, tc, tr)\n>>> x = min(ml + nu + 1, n)  # x = 4\n>>> lenr = x * l  # lenr = 8\n>>> ncols = min(s * l, min(m * k, n * l) - p * l)  # ncols = 10\n>>> info\n0",
  "mb02id": "Solve over/underdetermined linear systems with block Toeplitz matrix.\n\nSolves overdetermined or underdetermined real linear systems involving an\nM*K-by-N*L block Toeplitz matrix T specified by its first block column and row.\nAssumes T has full rank.\n\nOptions:\n  JOB='O': Least squares - minimize ||B - T*X||\n  JOB='U': Minimum norm - solve T'*X = C\n  JOB='A': Solve both problems\n\nParameters:\n  job (str): 'O' overdetermined, 'U' underdetermined, 'A' both\n  k (int): Number of rows in blocks of T, k >= 0\n  l (int): Number of columns in blocks of T, l >= 0\n  m (int): Number of blocks in first block column of T, m >= 0\n  n (int): Number of blocks in first block row of T, 0 <= n*l <= m*k\n  tc (ndarray): First block column of T (M*K x L, F-order)\n  tr (ndarray): Blocks 2 to N of first block row (K x (N-1)*L, F-order)\n  b (ndarray): RHS matrix B for overdetermined system (M*K x RB, F-order)\n  c (ndarray): RHS matrix C for underdetermined system (N*L x RC, F-order)\n\nReturns:\n  (b_out, c_out, info):\n    - b_out: Overdetermined solution (N*L x RB) if job='O' or 'A'\n    - c_out: Underdetermined solution (M*K x RC) if job='U' or 'A'\n    - info: 0=success, <0=invalid arg, 1=T not full rank\n\nExamples:\n\n>>> from slicot import mb02id\n>>> import numpy as np\n>>> k, l, m, n = 3, 2, 4, 3\n>>> rb, rc = 1, 1\n>>> tc = np.array([\n...     [5.0, 2.0],\n...     [1.0, 2.0],\n...     [4.0, 3.0],\n...     [4.0, 0.0],\n...     [2.0, 2.0],\n...     [3.0, 3.0],\n...     [5.0, 1.0],\n...     [3.0, 3.0],\n...     [1.0, 1.0],\n...     [2.0, 3.0],\n...     [1.0, 3.0],\n...     [2.0, 2.0],\n...     ], order='F', dtype=float)\n>>> tr = np.array([\n...     [1.0, 4.0, 2.0, 3.0],\n...     [2.0, 2.0, 2.0, 4.0],\n...     [3.0, 1.0, 0.0, 1.0],\n...     ], order='F', dtype=float)\n>>> b = np.ones((m*k, rb), order='F', dtype=float)\n>>> c = np.ones((n*l, rc), order='F', dtype=float)\n>>> b_out, c_out, info = mb02id('A', k, l, m, n, tc, tr, b, c)\n>>> info\n0",
  "mb02jd": "Full QR factorization of a block Toeplitz matrix of full rank.\n\nComputes lower triangular R and orthogonal Q such that T = Q * R^T,\nwhere T is a K*M-by-L*N block Toeplitz matrix with blocks of size (K,L).\nAssumes first MIN(M*K, N*L) columns of T have full rank.\n\nParameters:\n  job (str): 'Q' = compute Q and R, 'R' = only compute R\n  k (int): Number of rows in one block of T, k >= 0\n  l (int): Number of columns in one block of T, l >= 0\n  m (int): Number of blocks in one block column of T, m >= 0\n  n (int): Number of blocks in one block row of T, n >= 0\n  p (int): Previously computed block columns of R, p >= 0\n  s (int): Number of block columns of R to compute, s >= 0\n  tc (ndarray): First block column of T (M*K x L, F-order)\n  tr (ndarray): First block row without leading block (K x (N-1)*L, F-order)\n\nReturns:\n  (q, r, info): Factor Q (M*K x cols), lower triangular factor R, exit code\n  info=1 means full rank condition numerically violated\n\nExamples:\n\n>>> from slicot import mb02jd\n>>> import numpy as np\n>>> k, l, m, n = 2, 3, 4, 3\n>>> p, s = 0, 3  # Compute all 3 block columns from scratch\n>>> tc = np.array([\n...     [1.0, 4.0, 0.0],\n...     [4.0, 1.0, 2.0],\n...     [4.0, 2.0, 2.0],\n...     [5.0, 3.0, 2.0],\n...     [2.0, 4.0, 4.0],\n...     [5.0, 3.0, 4.0],\n...     [2.0, 2.0, 5.0],\n...     [4.0, 2.0, 3.0],\n...     ], order='F', dtype=float)\n>>> tr = np.array([\n...     [3.0, 4.0, 2.0, 5.0, 0.0, 4.0],\n...     [5.0, 1.0, 1.0, 2.0, 4.0, 1.0],\n...     ], order='F', dtype=float)\n>>> q, r, info = mb02jd('Q', k, l, m, n, p, s, tc, tr)\n>>> info\n0",
  "mb02jx": "Low rank QR factorization with column pivoting of a block Toeplitz matrix.\n\nComputes T*P = Q*R^T where R is lower trapezoidal, P is a block permutation\nmatrix, and Q^T*Q = I. The number of columns in R (RNK) equals the numerical\nrank of T. Only columns in the same block of T are permuted.\n\nParameters:\n  job (str): 'Q' = compute Q and R, 'R' = only compute R\n  k (int): Number of rows in one block of T, k >= 0\n  l (int): Number of columns in one block of T, l >= 0\n  m (int): Number of blocks in one block column of T, m >= 0\n  n (int): Number of blocks in one block row of T, n >= 0\n  tc (ndarray): First block column of T (M*K x L, F-order)\n  tr (ndarray): First block row without leading block (K x (N-1)*L, F-order)\n  tol1 (float): Diagonal tolerance (< 0 for default)\n  tol2 (float): Offdiagonal tolerance (< 0 for default)\n\nReturns:\n  (rnk, q, r, jpvt, info):\n    - rnk: Numerical rank of T\n    - q: Factor Q (M*K x RNK, F-order) if job='Q'\n    - r: Lower trapezoidal factor R (N*L x RNK, F-order)\n    - jpvt: Column permutation (jpvt[j]=k means col j of T*P was col k of T)\n    - info: 0=success, 1=generator indefinite, 2=columns not linearly dependent\n\nExamples:\n\n>>> from slicot import mb02jx\n>>> import numpy as np\n>>> k, l, m, n = 3, 3, 4, 4\n>>> tol1, tol2 = -1.0, -1.0  # Use defaults\n>>> tc = np.array([\n...     [1.0, 2.0, 3.0],\n...     [1.0, 2.0, 3.0],\n...     [1.0, 2.0, 3.0],\n...     [1.0, 2.0, 3.0],\n...     [1.0, 2.0, 3.0],\n...     [1.0, 2.0, 3.0],\n...     [1.0, 2.0, 3.0],\n...     [1.0, 2.0, 3.0],\n...     [1.0, 2.0, 3.0],\n...     [1.0, 0.0, 1.0],\n...     [1.0, 1.0, 0.0],\n...     [2.0, 2.0, 0.0],\n...     ], order='F', dtype=float)\n>>> tr = np.array([\n...     [1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 0.0, 1.0, 1.0],\n...     [1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 1.0, 2.0, 1.0],\n...     [1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 1.0, 1.0, 1.0],\n...     ], order='F', dtype=float)\n>>> rnk, q, r, jpvt, info = mb02jx('Q', k, l, m, n, tc, tr, tol1, tol2)\n...     qtq = q.T @ q\n>>> info\n0",
  "mb02kd": "Block Toeplitz matrix-matrix product.\n\nComputes C = alpha*op(T)*B + beta*C where T is a block Toeplitz matrix\nspecified by its first block column TC and first block row TR.\n\nParameters:\n  ldblk (str): 'C' = T(1,1) in first block of TC, 'R' = in first block of TR\n  trans (str): 'N' = op(T)=T, 'T'/'C' = op(T)=T'\n  k (int): Number of rows in blocks of T, k >= 0\n  l (int): Number of columns in blocks of T, l >= 0\n  m (int): Number of blocks in first block column, m >= 0\n  n (int): Number of blocks in first block row, n >= 0\n  r (int): Number of columns in B and C, r >= 0\n  alpha (float): Scalar multiplier\n  beta (float): Scalar for C. If zero, C not referenced on entry\n  tc (ndarray): First block column of T (M*K x L or (M-1)*K x L, F-order)\n  tr (ndarray): First block row of T (K x (N-1)*L or K x N*L, F-order)\n  b (ndarray): Input matrix B (N*L x R or M*K x R, F-order)\n  c (ndarray, optional): Input matrix C (for beta != 0)\n\nReturns:\n  (c, info): Result matrix C = alpha*op(T)*B + beta*C, exit code\n\nExamples:\n\n>>> from slicot import mb02kd\n>>> import numpy as np\n>>> k, l, m, n, r = 3, 2, 4, 5, 1\n>>> tc = np.array([\n...     [4.0, 1.0],\n...     [3.0, 5.0],\n...     [2.0, 1.0],\n...     [4.0, 1.0],\n...     [3.0, 4.0],\n...     [2.0, 4.0],\n...     [3.0, 1.0],\n...     [3.0, 0.0],\n...     [4.0, 4.0],\n...     [5.0, 1.0],\n...     [3.0, 1.0],\n...     [4.0, 3.0],\n...     ], order='F', dtype=float)\n>>> tr = np.array([\n...     [5.0, 2.0, 2.0, 2.0, 2.0, 1.0, 1.0, 3.0],\n...     [4.0, 1.0, 5.0, 4.0, 5.0, 4.0, 1.0, 2.0],\n...     [2.0, 3.0, 4.0, 1.0, 3.0, 3.0, 3.0, 3.0],\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0],\n...     [2.0],\n...     [2.0],\n...     [2.0],\n...     [1.0],\n...     [3.0],\n...     [3.0],\n...     [4.0],\n...     [2.0],\n...     [3.0],\n...     ], order='F', dtype=float)\n>>> c, info = mb02kd('C', 'N', k, l, m, n, r, 1.0, 0.0, tc, tr, b)\n>>> info\n0",
  "mb02md": "Total Least Squares solution using SVD approach.\n\nSolves the TLS problem AX = B where both A and B are inaccurate.\nComputes minimum norm solution for overdetermined, determined,\nor underdetermined systems.\n\nParameters:\n  job (str): 'R' compute RANK only, 'T' compute TOL only,\n             'B' compute both, 'N' compute neither\n  m (int): Number of rows in A and B, m >= 0\n  n (int): Number of columns in A, n >= 0\n  l (int): Number of columns in B, l >= 0\n  c (ndarray): Matrix [A|B] (m x (n+l), F-order)\n  tol (float): Tolerance (or sdev for job='T'/'B')\n  rank (int, optional): Input rank for job='T'/'N'\n\nReturns:\n  (c_out, s, x, rank, rcond, iwarn, info):\n    - c_out: Transformed right singular vectors\n    - s: Singular values (descending order)\n    - x: TLS solution (n x l)\n    - rank: Computed/adjusted rank\n    - rcond: Reciprocal condition number of F\n    - iwarn: 0=ok, 1=multiplicity, 2=F singular\n    - info: Exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb02md\n>>> m, n, l = 6, 3, 1\n>>> c = np.array([\n...     [0.80010, 0.39985, 0.60005, 0.89999],\n...     [0.29996, 0.69990, 0.39997, 0.82997],\n...     [0.49994, 0.60003, 0.20012, 0.79011],\n...     [0.90013, 0.20016, 0.79995, 0.85002],\n...     [0.39998, 0.80006, 0.49985, 0.99016],\n...     [0.20002, 0.90007, 0.70009, 1.02994],\n...     ], order='F', dtype=float)\n>>> tol = 0.0\n>>> c_out, s, x, rank, rcond, iwarn, info = mb02md('B', m, n, l, c, tol)\n>>> info\n0",
  "mb02nd": "Total Least Squares solution using Partial SVD approach.\n\nSolves the TLS problem AX = B using partial singular value decomposition\nwhere both A and B are inaccurate. More efficient than full SVD for\nlarge problems when only a subset of singular values is needed.\n\nParameters:\n  m (int): Number of rows in A and B, m >= 0\n  n (int): Number of columns in A, n >= 0\n  l (int): Number of columns in B, l >= 0\n  rank (int): If < 0, compute rank. Otherwise, specify rank. rank <= min(m,n)\n  theta (float): If rank < 0, threshold for singular values (>= 0).\n                 If rank >= 0 and theta < 0, compute theta.\n  c (ndarray): Matrix [A|B] (max(m,n+l) x (n+l), F-order)\n  tol (float): Tolerance for singular value multiplicity (0 for default)\n  reltol (float): Relative tolerance for bisection (0 for default)\n\nReturns:\n  (x, rank, theta, q, inul, iwarn, info):\n    - x: TLS solution (n x l)\n    - rank: Computed/adjusted rank\n    - theta: Computed singular value bound\n    - q: Bidiagonal matrix elements (2*p-1 where p=min(m,n+l))\n    - inul: Boolean list indicating singular subspace columns\n    - iwarn: 0=ok, 1=multiplicity, 2=F singular\n    - info: Exit code (0=success, 1=max iterations, 2=rank too large)\n\nExamples:\n\n>>> from slicot import mb02nd\n>>> import numpy as np\n>>> m, n, l = 6, 3, 1\n>>> c = np.array([\n...     [0.80010, 0.39985, 0.60005, 0.89999],\n...     [0.29996, 0.69990, 0.39997, 0.82997],\n...     [0.49994, 0.60003, 0.20012, 0.79011],\n...     [0.90013, 0.20016, 0.79995, 0.85002],\n...     [0.39998, 0.80006, 0.49985, 0.99016],\n...     [0.20002, 0.90007, 0.70009, 1.02994],\n...     ], dtype=float, order='F')\n>>> rank = -1\n>>> theta = 0.001\n>>> tol = 0.0\n>>> reltol = 0.0\n>>> x, rank_out, theta_out, q, inul, iwarn, info = mb02nd(\n...     m, n, l, rank, theta, c, tol, reltol\n...     )\n>>> info\n0",
  "mb02ny": "Separate zero singular value of bidiagonal submatrix.\n\nAnnihilates superdiagonal elements E(i-1) and/or E(i) when diagonal\nentry Q(i) is negligible, using Givens rotations.\n\nParameters:\n  updatu (bool): True to update U with left Givens rotations\n  updatv (bool): True to update V with right Givens rotations\n  m (int): Number of rows of matrix U, m >= 0\n  n (int): Number of rows of matrix V, n >= 0\n  i (int): Index of negligible diagonal entry Q(i), 1-based\n  k (int): Last index of bidiagonal submatrix, 1-based\n  q (ndarray): Diagonal entries of J (p,), p = min(m,n)\n  e (ndarray): Superdiagonal entries of J (p-1,)\n  u (ndarray): Left transformation matrix (m x p, F-order)\n  v (ndarray): Right transformation matrix (n x p, F-order)\n\nReturns:\n  (q, e, u, v): Transformed diagonal, superdiagonal, and matrices\n\nExamples:\n\n>>> from slicot import mb02ny\n>>> import numpy as np\n>>> m, n = 5, 5\n>>> p = min(m, n)\n>>> i_idx = 2  # Q(2) is negligible (1-based index)\n>>> k = 4      # Consider submatrix up to index 4\n>>> q = np.array([2.0, 1.5, 0.8, 1.2, 0.9], dtype=np.float64, order='F')\n>>> e = np.array([0.5, 0.3, 0.7, 0.4], dtype=np.float64, order='F')\n>>> u = np.eye(m, p, dtype=np.float64, order='F')\n>>> v = np.eye(n, p, dtype=np.float64, order='F')\n>>> q_out, e_out, u_out, v_out = mb02ny(True, True, m, n, i_idx, k, q, e, u, v)",
  "mb02od": "Solve triangular matrix equation with condition estimation.\n\nSolves op(A)*X = alpha*B or X*op(A) = alpha*B where A is triangular.\nOnly solves if reciprocal condition number RCOND > TOL.\n\nParameters:\n  side (str): 'L' for op(A)*X = alpha*B, 'R' for X*op(A) = alpha*B\n  uplo (str): 'U' for upper triangular, 'L' for lower triangular\n  trans (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  diag (str): 'U' for unit triangular, 'N' for non-unit\n  norm (str): '1' or 'O' for 1-norm, 'I' for infinity-norm\n  alpha (float): Scalar multiplier\n  a (ndarray): Triangular matrix (k x k, F-order) where k=m if side='L'\n  b (ndarray): RHS matrix B (m x n, F-order), overwritten with solution X\n  tol (float, optional): Tolerance. If <= 0, uses k*k*eps.\n\nReturns:\n  (x, rcond, info): Solution X, reciprocal condition number, exit code\n  info=1 means matrix is singular (rcond <= tol)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb02od\n>>> m, n = 3, 2\n>>> alpha = 1.0\n>>> a = np.triu(np.random.rand(m, m).astype(float, order='F')) + np.eye(m) * 2.0\n>>> b = np.random.rand(m, n).astype(float, order='F')\n>>> x, rcond, info = mb02od('L', 'U', 'N', 'N', '1', alpha, a, b)\n>>> info\n0",
  "mb02pd": "Solve linear system op(A)*X = B with LU factorization.\n\nUses LU factorization with optional equilibration and\niterative refinement for improved accuracy.\n\nParameters:\n  fact (str): 'N' factor A, 'E' equilibrate+factor, 'F' factored\n  trans (str): 'N' solve A*X=B, 'T'/'C' solve A'*X=B\n  a (ndarray): N-by-N coefficient matrix A (F-order)\n  b (ndarray): N-by-NRHS right-hand side B (F-order)\n\nReturns:\n  (x, ferr, berr, rcond, info): Solution X, forward/backward error,\n                                condition number, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb02pd\n>>> n = 4\n>>> nrhs = 2\n>>> A = np.eye(n) + 0.5 * np.random.randn(n, n)\n>>> A = np.asfortranarray(A)\n>>> X_true = np.random.randn(n, nrhs)\n>>> B = A @ X_true\n>>> B = np.asfortranarray(B)\n>>> X, ferr, berr, rcond, info = mb02pd('N', 'N', A.copy(order='F'), B.copy(order='F'))\n>>> info\n0",
  "mb02qd": "Linear least squares solution using complete orthogonal factorization.\n\nComputes a solution to minimize ||A*X - B|| for rank-deficient matrices.\n\nParameters:\n  job (str): 'L' standard least squares, 'F' with free elements in Y\n  iniper (str): 'P' use initial permutation in jpvt, 'N' no initial perm\n  m (int): Number of rows of A\n  n (int): Number of columns of A\n  nrhs (int): Number of right-hand sides\n  rcond (float): Tolerance for rank determination, 0 <= rcond <= 1\n  svlmax (float): Estimate of largest singular value, use 0.0 if unknown\n  a (ndarray): M-by-N matrix A (F-order)\n  b (ndarray): M-by-NRHS right-hand side B (F-order)\n  y (ndarray, optional): Free elements for job='F' ((n-rank)*nrhs,)\n  jpvt (ndarray, optional): Initial permutation for iniper='P' (n,)\n\nReturns:\n  (x, rank, sval, jpvt, info): Solution X (N-by-NRHS), effective rank,\n                               singular value estimates [3], permutation, exit code\n\nExamples:\n\n>>> from slicot import mb02qd\n>>> import numpy as np\n>>> m, n, nrhs = 4, 3, 2\n>>> rcond = 2.3e-16\n>>> svlmax = 0.0\n>>> a = np.array([\n...     [2.0, 2.0, -3.0],\n...     [3.0, 3.0, -1.0],\n...     [4.0, 4.0, -5.0],\n...     [-1.0, -1.0, -2.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> expected_rank = 2\n>>> expected_sval = np.array([7.8659, 2.6698, 0.0000], dtype=float)\n>>> expected_x = np.array([\n...     [-0.0034, -0.1054],\n...     [-0.0034, -0.1054],\n...     [-0.0816, -0.1973]\n...     ], order='F', dtype=float)\n>>> x, rank, sval, jpvt, info = mb02qd('L', 'N', m, n, nrhs, rcond, svlmax, a, b)\n>>> info\n0",
  "mb02rd": "Solve linear system with Hessenberg LU factorization.\n\nSolves H*X=B or H'*X=B using LU from mb02sd.\n\nParameters:\n  trans (str): 'N' for H*X=B, 'T'/'C' for H'*X=B\n  n (int): Order of H\n  nrhs (int): Number of RHS columns\n  h (ndarray): LU factors from mb02sd (n x n, F-order)\n  ipiv (ndarray): Pivots from mb02sd (n)\n  b (ndarray): RHS matrix (n x nrhs, F-order)\n\nReturns:\n  (x, info): Solution X, exit code",
  "mb02rz": "Solve complex Hessenberg system using LU factorization.\n\nSolves H*X=B, H'*X=B, or H^H*X=B using factorization from mb02sz.\n\nParameters:\n  trans (str): 'N' (no transpose), 'T' (transpose), 'C' (conjugate transpose)\n  h (ndarray): LU factors from mb02sz (n x n, F-order)\n  ipiv (ndarray): Pivot indices from mb02sz (n elements)\n  b (ndarray): Right-hand side matrix (n x nrhs, F-order)\n\nReturns:\n  (x, info): Solution matrix and exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb02rz\n>>> import numpy as np\n>>> h = np.array([\n...     [2.0 + 1.0j, 3.0 + 0.0j],\n...     [1.0 + 0.0j, 4.0 + 2.0j]\n...     ], order='F', dtype=complex)\n>>> b = np.array([\n...     [1.0 + 0.0j],\n...     [2.0 + 1.0j]\n...     ], order='F', dtype=complex)\n>>> h_lu, ipiv, info_lu = mb02sz(h)\n>>> x, info = mb02rz('N', h_lu, ipiv, b)\n>>> info\n0",
  "mb02sd": "LU factorization of upper Hessenberg matrix.\n\nComputes H = P*L*U for upper Hessenberg H.\n\nParameters:\n  n (int): Order of H\n  h (ndarray): Upper Hessenberg matrix (n x n, F-order)\n\nReturns:\n  (h, ipiv, info): LU factors, pivots (1-based), exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb02sd\n>>> n = 4\n>>> h = np.zeros((n, n), order='F', dtype=float)\n...     h[i, j] = np.random.randn()\n>>> h_out, ipiv, info = mb02sd(n, h)\n>>> info\n0",
  "mb02sz": "LU factorization of complex upper Hessenberg matrix.\n\nComputes LU factorization H = P*L*U where:\n  - P is permutation matrix\n  - L is unit lower bidiagonal\n  - U is upper triangular\n\nParameters:\n  h (ndarray): Complex upper Hessenberg matrix (n x n, F-order)\n\nReturns:\n  (h_lu, ipiv, info):\n    - h_lu: LU factors (L stored below diagonal, U on/above diagonal)\n    - ipiv: Pivot indices (1-based, n elements)\n    - info: Exit code (0=success, >0=singular U)\n\nExamples:\n\n>>> from slicot import mb02sz\n>>> import numpy as np\n>>> h = np.array([\n...     [2.0 + 1.0j, 3.0 + 0.0j],\n...     [1.0 + 0.0j, 4.0 + 2.0j]\n...     ], order='F', dtype=complex)\n>>> h_result, ipiv, info = mb02sz(h)\n>>> u = np.triu(h_result)\n>>> l = np.eye(2, dtype=complex)\n>>> l[1, 0] = h_result[1, 0]\n>>> p = np.eye(2, dtype=complex)\n...     p = np.array([[0, 1], [1, 0]], dtype=complex)\n>>> h_reconstructed = p @ l @ u\n>>> info\n0",
  "mb02td": "Estimate reciprocal condition number of upper Hessenberg matrix.\n\nUses LU factorization from mb02sd to estimate 1/cond(H).\n\nParameters:\n  norm (str): '1' or 'O' for 1-norm, 'I' for infinity-norm\n  n (int): Order of matrix H\n  hnorm (float): Norm of original matrix H (before factorization)\n  h (ndarray): LU factors from mb02sd (n x n, F-order)\n  ipiv (ndarray): Pivot indices from mb02sd (n elements)\n\nReturns:\n  (rcond, info): Reciprocal condition estimate and exit code (0=success)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb02td\n>>> n = 5\n>>> h = np.array([\n...     [1.0, 2.0, 6.0, 3.0, 5.0],\n...     [-2.0, -1.0, -1.0, 0.0, -2.0],\n...     [0.0, 3.0, 1.0, 5.0, 1.0],\n...     [0.0, 0.0, 2.0, 0.0, -4.0],\n...     [0.0, 0.0, 0.0, 1.0, 4.0]\n...     ], order='F', dtype=float)\n>>> hnorm_1 = np.max(np.sum(np.abs(h), axis=0))\n>>> h_lu, ipiv, info_sd = mb02sd(n, h)\n>>> rcond, info = mb02td('O', n, hnorm_1, h_lu, ipiv)\n>>> info\n0",
  "mb02tz": "Estimate reciprocal condition number of complex Hessenberg matrix.\n\nUses LU factorization from mb02sz to estimate 1/cond(H).\n\nParameters:\n  norm (str): '1' or 'O' for 1-norm, 'I' for infinity-norm\n  hnorm (float): Norm of original matrix H (before factorization)\n  h (ndarray): LU factors from mb02sz (n x n, F-order)\n  ipiv (ndarray): Pivot indices from mb02sz (n elements)\n\nReturns:\n  (rcond, info): Reciprocal condition estimate and exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb02tz\n>>> import numpy as np\n>>> h = np.array([\n...     [2.0 + 0.0j, 1.0 + 0.0j],\n...     [0.0 + 0.0j, 2.0 + 0.0j]\n...     ], order='F', dtype=complex)\n>>> hnorm = np.linalg.norm(h, 1)\n>>> h_lu, ipiv, info_lu = mb02sz(h)\n>>> rcond, info = mb02tz('1', hnorm, h_lu, ipiv)\n>>> actual_cond = np.linalg.cond(np.array([\n...     [2.0 + 0.0j, 1.0 + 0.0j],\n...     [0.0 + 0.0j, 2.0 + 0.0j]\n...     ]), 1)\n>>> info\n0",
  "mb02ud": "Minimum norm least squares solution using SVD.\n\nSolves op(R)*X = alpha*B (side='L') or X*op(R) = alpha*B (side='R')\nwhere R is upper triangular, using singular value decomposition.\n\nParameters:\n  fact (str): 'N' to compute SVD, 'F' if SVD already available\n  side (str): 'L' for left, 'R' for right\n  trans (str): 'N' for op(R)=R, 'T'/'C' for op(R)=R'\n  jobp (str): 'P' to compute/use pseudoinverse, 'N' otherwise\n  m (int): Number of rows of B\n  n (int): Number of columns of B\n  alpha (float): Scalar multiplier\n  rcond (float): Rank threshold (not used if fact='F')\n  r (ndarray): L-by-L upper triangular matrix R (F-order)\n  b (ndarray): M-by-N matrix B (F-order)\n  q (ndarray, optional): Q matrix (required if fact='F')\n  sv (ndarray, optional): Singular values (required if fact='F')\n  rank (int, optional): Rank (required if fact='F')\n  rp (ndarray, optional): Pseudoinverse (if fact='F' and jobp='P')\n  ldwork (int, optional): Workspace size\n\nReturns:\n  (x, q, sv, rank, rp, info): Solution, Q matrix, singular values, rank, pseudoinverse, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> m, n = 4, 3\n>>> l = m\n>>> r = np.triu(np.random.randn(l, l)).astype(float, order='F')\n>>> r[l-1, l-1] = 1e-16\n>>> b = np.random.randn(m, n).astype(float, order='F')\n>>> from slicot import mb02ud\n>>> alpha = 1.0\n>>> rcond = 1e-10\n>>> x, q, sv, rank, rp, info = mb02ud(\n...     'N', 'L', 'N', 'N', m, n, alpha, rcond, r.copy(), b.copy()\n...     )\n>>> info\n0",
  "mb02uu": "Solve linear system using LU factorization with complete pivoting.\n\nSolves A*x = scale*rhs using the LU factorization from mb02uv.\n\nParameters:\n  n (int): Order of matrix A\n  a (ndarray): LU factors from mb02uv (n x n, F-order)\n  rhs (ndarray): Right-hand side vector (n,)\n  ipiv (ndarray): Row pivot indices from mb02uv (n,)\n  jpiv (ndarray): Column pivot indices from mb02uv (n,)\n\nReturns:\n  (x, scale): Solution vector and scale factor (0 < scale <= 1)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb02uu\n>>> n = 4\n>>> a = np.array([\n...     [4.0, 2.0, 1.0, 3.0],\n...     [2.0, 5.0, 3.0, 1.0],\n...     [1.0, 3.0, 6.0, 2.0],\n...     [3.0, 1.0, 2.0, 7.0]\n...     ], order='F', dtype=float)\n>>> rhs = np.array([10.0, 11.0, 12.0, 13.0], dtype=float)\n>>> a_lu, ipiv, jpiv, info = mb02uv(n, a)\n>>> x, scale = mb02uu(n, a_lu, rhs, ipiv, jpiv)",
  "mb02uv": "LU factorization with complete pivoting.\n\nComputes A = P*L*U*Q where P, Q are permutation matrices.\n\nParameters:\n  n (int): Order of matrix A\n  a (ndarray): n-by-n matrix A (F-order)\n\nReturns:\n  (a_lu, ipiv, jpiv, info): LU factors, row pivots, column pivots, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb02uv\n>>> n = 4\n>>> a = np.array([\n...     [2.0, 1.0, 3.0, 4.0],\n...     [4.0, 3.0, 2.0, 1.0],\n...     [1.0, 4.0, 2.0, 3.0],\n...     [3.0, 2.0, 4.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a_lu, ipiv, jpiv, info = mb02uv(n, a)\n>>> info\n0",
  "mb02uw": "Solve 1x1 or 2x2 linear system with scaling and perturbation.\n\nSolves A*X = s*B or A'*X = s*B where A is 1x1 or 2x2. The scale factor\ns is computed to prevent overflow. Near-singular A is perturbed.\n\nParameters:\n  ltrans (bool): True for A', False for A\n  par (ndarray): Machine parameters [eps, sfmin, smin]\n  a (ndarray): Matrix A (n x n, F-order), n=1 or 2\n  b (ndarray): RHS matrix B (n x m, F-order)\n\nReturns:\n  (x, scale, iwarn): Solution, scale factor, warning (1=A perturbed)\n\nExamples:\n\n>>> from slicot import mb02uw\n>>> import numpy as np\n>>> a = np.array([[4.0]], order='F', dtype=float)\n>>> b = np.array([[2.0]], order='F', dtype=float)\n>>> par = np.array([2.22e-16, 2.23e-308, 1e-10], dtype=float)\n>>> x, scale, iwarn = mb02uw(False, par, a, b)",
  "mb02vd": "Solve X * op(A) = B using LU factorization.\n\nParameters:\n  trans (str): 'N' for X*A=B, 'T'/'C' for X*A'=B\n  a (ndarray): Matrix A (n x n, F-order), overwritten with LU factors\n  b (ndarray): RHS matrix B (m x n, F-order), overwritten with solution X\n\nReturns:\n  (x, ipiv, info): Solution X, pivots, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb02vd\n>>> n = 4\n>>> m = 3\n>>> a = np.array([\n...     [4.0, 2.0, 1.0, 3.0],\n...     [1.0, 5.0, 2.0, 1.0],\n...     [2.0, 1.0, 6.0, 2.0],\n...     [1.0, 2.0, 1.0, 7.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 2.0, 3.0, 4.0],\n...     [5.0, 6.0, 7.0, 8.0],\n...     [9.0, 10.0, 11.0, 12.0]\n...     ], order='F', dtype=float)\n>>> x, ipiv, info = mb02vd('N', a.copy(order='F'), b.copy(order='F'))\n>>> info\n0",
  "mb02wd": "Solve symmetric linear system using conjugate gradient.\n\nSolves A*x = b for symmetric positive definite A using the\npreconditioned conjugate gradient method.\n\nParameters:\n  form (str): 'U' (upper triangular), 'L' (lower triangular)\n  itmax (int): Maximum iterations\n  a (ndarray): Symmetric matrix A (n x n, F-order)\n  b (ndarray): Right-hand side vector (n,)\n  x (ndarray): Initial guess (n,), modified in place\n  tol (float): Convergence tolerance\n\nReturns:\n  (x, iterations, residual, iwarn, info): Solution, iteration count,\n    residual norm, warning code, exit code\n\nExamples:\n\n>>> from slicot import mb02wd\n>>> import numpy as np\n>>> a = np.array([\n...     [4.0, 2.0, 1.0],\n...     [0.0, 5.0, 2.0],\n...     [0.0, 0.0, 6.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([1.0, 2.0, 3.0], dtype=np.float64)\n>>> x = np.zeros(3, dtype=np.float64)\n>>> x_out, iterations, residual, iwarn, info = slicot.mb02wd('U', 100, a, b, x, 1e-12)\n>>> info\n0",
  "mb02yd": "Solve augmented system A*x = b, D*x = 0 in least squares sense.\n\nParameters:\n  cond (str): 'E' = estimate condition, 'N' = check zeros, 'U' = use rank\n  n (int): Order of matrix R\n  r (ndarray): Upper triangular matrix R (n x n, F-order)\n  ipvt (ndarray): Permutation vector (1-based indices)\n  diag (ndarray): Diagonal elements of D\n  qtb (ndarray): First n elements of Q'*b\n  rank (int): Input rank (COND='U') or 0 otherwise\n  tol (float): Tolerance for rank determination (COND='E')\n\nReturns:\n  (x, rank, info): Solution vector, estimated rank, exit code\n\nExamples:\n\n>>> from slicot import mb02yd\n>>> import numpy as np\n>>> n = 3\n>>> r = np.array([\n...     [3.0, 2.0, 1.0],\n...     [0.0, 2.0, 1.0],\n...     [0.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> ipvt = np.array([1, 2, 3], dtype=np.int32)\n>>> diag = np.array([0.1, 0.2, 0.3], dtype=np.float64)\n>>> qtb = np.array([1.0, 2.0, 3.0], dtype=np.float64)\n>>> x, rank, info = mb02yd('N', n, r, ipvt, diag, qtb, 0, 0.0)\n>>> info\n0",
  "mb03ab": "Compute Givens rotations for Wilkinson shift polynomial.\n\nComputes two Givens rotations (C1,S1) and (C2,S2) such that the orthogonal\nmatrix Z makes the first column of the real Wilkinson shift polynomial of\na product of matrices in periodic upper Hessenberg form parallel to the\nfirst unit vector.\n\nParameters:\n  shft (str): Shift type: 'C'=complex conjugate, 'D'=real identical,\n              'R'=real distinct, 'S'=single real shift\n  k (int): Number of factors (K >= 1)\n  n (int): Order of factors (N >= 2 for single, N >= 3 for double shift)\n  amap (ndarray): Factor access map (K,), 1-based indices\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  sinv (int): Signature multiplier\n  a (ndarray): Matrix factors (N x N x K, F-order)\n  w1 (float): Real part of first eigenvalue (unused for SHFT='S')\n  w2 (float): Second eigenvalue (real) or imaginary part (complex)\n\nReturns:\n  (c1, s1, c2, s2): Givens rotation parameters.\n    For SHFT='S': c2=1, s2=0\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03ab\n>>> k = 2\n>>> n = 3\n>>> lda1, lda2 = n, n\n>>> a = np.zeros((lda1, lda2, k), dtype=float, order='F')\n>>> a[:, :, 0] = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 8.0, 9.0]\n...     ], order='F')\n>>> a[:, :, 1] = np.array([\n...     [2.0, 1.0, 0.5],\n...     [0.0, 3.0, 1.5],\n...     [0.0, 0.0, 4.0]\n...     ], order='F')\n>>> amap = np.array([1, 2], dtype=np.int32)\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> sinv = 1\n>>> w1 = 0.0\n>>> w2 = 1.5\n>>> c1, s1, c2, s2 = mb03ab('S', k, n, amap, s, sinv, a, w1, w2)",
  "mb03ad": "Compute Givens rotations for Wilkinson shift polynomial (implicit shifts).\n\nComputes two Givens rotations (C1,S1) and (C2,S2) such that the orthogonal\nmatrix Z makes the first column of the real Wilkinson double/single shift\npolynomial parallel to the first unit vector. Unlike MB03AB, this routine\ncomputes the shifts implicitly from the trailing submatrices.\n\nParameters:\n  shft (str): Shift type: 'D'=double shift (N>2), 'S'=single real shift\n  k (int): Number of factors (K >= 1)\n  n (int): Order of factors (N >= 2 for single, N >= 3 for double shift)\n  amap (ndarray): Factor access map (K,), 1-based indices\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  sinv (int): Signature multiplier\n  a (ndarray): Matrix factors (N x N x K, F-order) in periodic Hessenberg form\n\nReturns:\n  (c1, s1, c2, s2): Givens rotation parameters.\n    For SHFT='S': c2=1, s2=0\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03ad\n>>> k = 2\n>>> n = 4\n>>> a = np.zeros((n, n, k), dtype=float, order='F')\n>>> a[:, :, 0] = np.array([\n...     [1.0, 2.0, 3.0, 4.0],\n...     [0.5, 1.5, 2.5, 3.5],\n...     [0.0, 0.3, 0.8, 1.2],\n...     [0.0, 0.0, 0.2, 0.6]\n...     ], order='F')\n>>> a[:, :, 1] = np.array([\n...     [2.0, 1.0, 0.5, 0.2],\n...     [0.0, 1.5, 1.0, 0.5],\n...     [0.0, 0.0, 2.0, 1.0],\n...     [0.0, 0.0, 0.0, 3.0]\n...     ], order='F')\n>>> amap = np.array([1, 2], dtype=np.int32)\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> sinv = 1\n>>> c1, s1, c2, s2 = mb03ad('D', k, n, amap, s, sinv, a)\n...     err_msg=\"First Givens rotation must be normalized\")\n...     err_msg=\"Second Givens rotation must be normalized\")",
  "mb03ae": "Compute Givens rotations for Wilkinson shift polynomial (variant).\n\nComputes two Givens rotations (C1,S1) and (C2,S2) such that the orthogonal\nmatrix Z makes the first column of the real Wilkinson double/single shift\npolynomial parallel to the first unit vector. Unlike MB03AB, this routine\ncomputes shifts from the trailing 2x2 submatrix rather than explicit values.\n\nParameters:\n  shft (str): 'D'=double shift (assumes N>2), 'S'=single real shift\n  k (int): Number of factors (K >= 1)\n  n (int): Order of factors (N >= 2)\n  amap (ndarray): Factor access map (K,), 1-based indices\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  sinv (int): Signature multiplier\n  a (ndarray): Matrix factors (N x N x K, F-order) in periodic Hessenberg form\n\nReturns:\n  (c1, s1, c2, s2): Givens rotation parameters.\n    For SHFT='S' or N==2: c2=1, s2=0\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03ae\n>>> k = 2\n>>> n = 3\n>>> lda1, lda2 = n, n\n>>> a = np.zeros((lda1, lda2, k), dtype=float, order='F')\n>>> a[:, :, 0] = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 8.0, 9.0]\n...     ], order='F')\n>>> a[:, :, 1] = np.array([\n...     [2.0, 1.0, 0.5],\n...     [0.0, 3.0, 1.5],\n...     [0.0, 0.0, 4.0]\n...     ], order='F')\n>>> amap = np.array([1, 2], dtype=np.int32)\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> sinv = 1\n>>> c1, s1, c2, s2 = mb03ae('S', k, n, amap, s, sinv, a)",
  "mb03ag": "Compute Givens rotations for Wilkinson shift polynomial (full evaluation).\n\nComputes two Givens rotations (C1,S1) and (C2,S2) using full evaluation of\nthe matrix product and DLAHQR for eigenvalue computation. Makes the first\ncolumn of the Wilkinson shift polynomial parallel to the first unit vector.\nThe Hessenberg matrix is the first factor (AMAP[0]).\n\nMore robust but slower. Used when convergence difficulties are encountered\nfor small order matrices (N, K <= 6).\n\nParameters:\n  shft (str): 'D'=double shift (N>2), 'S'=single real shift\n  k (int): Number of factors (K >= 1)\n  n (int): Order of factors (N >= 2)\n  amap (ndarray): Factor access map (K,), 1-based indices. AMAP[0] is Hessenberg.\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  sinv (int): Signature multiplier\n  a (ndarray): Matrix factors (N x N x K, F-order) in periodic Hessenberg form\n\nReturns:\n  (c1, s1, c2, s2): Givens rotation parameters.\n    For SHFT='S': c2=1, s2=0\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03ag\n>>> k = 2\n>>> n = 3\n>>> lda1, lda2 = n, n\n>>> a = np.zeros((lda1, lda2, k), dtype=float, order='F')\n>>> a[:, :, 0] = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 8.0, 9.0]\n...     ], order='F')\n>>> a[:, :, 1] = np.array([\n...     [2.0, 1.0, 0.5],\n...     [0.0, 3.0, 1.5],\n...     [0.0, 0.0, 4.0]\n...     ], order='F')\n>>> amap = np.array([1, 2], dtype=np.int32)\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> sinv = 1\n>>> c1, s1, c2, s2 = mb03ag('S', k, n, amap, s, sinv, a)",
  "mb03ah": "Compute Givens rotations for real Wilkinson shift polynomial (partial evaluation).\n\nComputes two Givens rotations (C1,S1) and (C2,S2) such that the orthogonal\nmatrix Q makes the first column of the real Wilkinson double/single shift\npolynomial parallel to the first unit vector. The Hessenberg matrix is the\nlast factor (AMAP[K-1]).\n\nUses partial evaluation of the matrix product (trailing 2x2 and first two\ncolumns). Called when convergence difficulties are encountered. For double\nshift with two real eigenvalues, both shifts equal the eigenvalue with\nminimum modulus.\n\nParameters:\n  shft (str): 'D'=double shift (assumes N>2), 'S'=single real shift\n  k (int): Number of factors (K >= 1)\n  n (int): Order of factors (N >= 2)\n  amap (ndarray): Factor access map (K,), 1-based indices. AMAP[K-1] is Hessenberg.\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  sinv (int): Signature multiplier\n  a (ndarray): Matrix factors (N x N x K, F-order) in periodic Hessenberg form\n\nReturns:\n  (c1, s1, c2, s2, info): Givens rotation parameters and exit code.\n    For SHFT='S' or N==2: c2=1, s2=0. info=0 always (no error checking).\n\nExamples:\n\n>>> from slicot import mb03ah\n>>> import numpy as np\n>>> k = 2  # number of factors\n>>> n = 3  # order of factors\n>>> a = np.zeros((n, n, k), order='F', dtype=float)\n>>> a[:, :, 0] = np.array([\n...     [2.0, 1.0, 0.5],\n...     [0.0, 1.5, 0.3],\n...     [0.0, 0.0, 1.0]\n...     ], order='F')\n>>> a[:, :, 1] = np.array([\n...     [1.0, 0.5, 0.2],\n...     [0.4, 1.2, 0.3],\n...     [0.0, 0.3, 0.8]\n...     ], order='F')\n>>> amap = np.array([1, 2], dtype=np.int32)\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> sinv = 1\n>>> c1, s1, c2, s2, info = mb03ah('S', k, n, amap, s, sinv, a)\n...     err_msg=\"First rotation not normalized\")\n...     err_msg=\"C2 should be 1 for single shift\")\n...     err_msg=\"S2 should be 0 for single shift\")\n>>> info\n0",
  "mb03ai": "Compute Givens rotations for Wilkinson shift polynomial (full evaluation).\n\nComputes two Givens rotations (C1,S1) and (C2,S2) using full evaluation of\nthe trailing submatrix elements. Makes the first column of the Wilkinson\nshift polynomial parallel to the first unit vector.\n\nParameters:\n  shft (str): 'D'=double shift, 'S'=single real shift\n  k (int): Number of factors (K >= 1)\n  n (int): Order of factors (N >= 2)\n  amap (ndarray): Factor access map (K,), 1-based indices\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  sinv (int): Signature multiplier\n  a (ndarray): Matrix factors (N x N x K, F-order) in periodic Hessenberg form\n\nReturns:\n  (c1, s1, c2, s2): Givens rotation parameters.\n    For SHFT='S' or N==2: c2=1, s2=0\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03ai\n>>> k = 2\n>>> n = 3\n>>> lda1, lda2 = n, n\n>>> a = np.zeros((lda1, lda2, k), dtype=float, order='F')\n>>> a[:, :, 0] = np.array([\n...     [2.0, 1.0, 0.5],\n...     [0.0, 3.0, 1.5],\n...     [0.0, 0.0, 4.0]\n...     ], order='F')\n>>> a[:, :, 1] = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [0.0, 8.0, 9.0]\n...     ], order='F')\n>>> amap = np.array([1, 2], dtype=np.int32)\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> sinv = 1\n>>> c1, s1, c2, s2 = mb03ai('S', k, n, amap, s, sinv, a)",
  "mb03ba": "Compute maps for Hessenberg index and signature array.\n\nAuxiliary routine for periodic QZ algorithms. Computes suitable maps\n(AMAP, QMAP) based on Hessenberg index H and signature array S.\n\nParameters:\n  k (int): Number of factors (K >= 1)\n  h (int): Index corresponding to A_1 (1-based)\n  s (ndarray): Signature array, dimension (K). Each entry must be 1 or -1.\n\nReturns:\n  (smult, amap, qmap): Signature multiplier, factor access map, Q access map\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03ba\n>>> k = 4\n>>> h = 2\n>>> s = np.array([1, 1, -1, 1], dtype=np.int32, order='F')\n>>> smult, amap, qmap = mb03ba(k, h, s)\n>>> expected_amap = np.array([2, 3, 4, 1], dtype=np.int32)\n>>> expected_qmap = np.array([2, 3, 4, 1], dtype=np.int32)",
  "mb03bc": "Product SVD of 2x2 triangular factors.\n\nComputes Givens rotations for the product singular value decomposition of K-1\ntriangular factors corresponding to a 2-by-2 product of K factors in upper\nHessenberg-triangular form.\n\nFor a product of 2-by-2 triangular matrices\n  A = A(:,:,2)^S(2) * A(:,:,3)^S(3) * ... * A(:,:,K)^S(K)\n\nGivens rotations are computed so that the product is diagonalized.\n\nParameters:\n  k (int): Number of factors (K >= 1)\n  amap (ndarray): Factor access map (K,), 1-based indices\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  sinv (int): Signature multiplier\n  a (ndarray): Matrix factors (2 x 2 x K, F-order), upper triangular\n  macpar (ndarray): Machine parameters (5,):\n    - MACPAR(0): overflow threshold (DLAMCH('O'))\n    - MACPAR(1): underflow threshold (DLAMCH('U'))\n    - MACPAR(2): safe minimum (DLAMCH('S'))\n    - MACPAR(3): relative precision (DLAMCH('E'))\n    - MACPAR(4): base (DLAMCH('B'))\n\nReturns:\n  (a, cv, sv):\n    - a: Modified triangular factors (product is diagonal)\n    - cv: Cosines of Givens rotations (K,)\n    - sv: Sines of Givens rotations (K,)\n\nExamples:\n\n>>> from slicot import mb03bc\n>>> import numpy as np\n>>> k = 2\n>>> a = np.zeros((2, 2, k), dtype=float, order='F')\n>>> a[:, :, 0] = np.array([[1.0, 0.5], [0.0, 0.8]], dtype=float)\n>>> a[:, :, 1] = np.array([[2.0, -0.3], [0.0, 1.5]], dtype=float)\n>>> amap = np.array([1, 2], dtype=np.int32, order='F')\n>>> s = np.array([1, 1], dtype=np.int32, order='F')\n>>> sinv = 1\n>>> macpar = get_macpar()\n>>> a_out, cv, sv = mb03bc(k, amap, s, sinv, a, macpar)\n...     norm = cv[i]**2 + sv[i]**2",
  "mb03bd": "Compute eigenvalues of periodic Hessenberg matrix product.\n\nFinds eigenvalues of the generalized matrix product:\n  A(:,:,1)^S(1) * A(:,:,2)^S(2) * ... * A(:,:,K)^S(K)\nwhere A(:,:,H) is upper Hessenberg and other factors are upper triangular.\n\nUses double-shift periodic QZ algorithm. Can reduce to periodic Schur form.\n\nParameters:\n  job (str): 'E' eigenvalues only, 'S' periodic Schur, 'T' standardized Schur\n  defl (str): 'C' careful deflation, 'A' aggressive deflation\n  compq (str): 'N' no Q, 'U' update Q, 'I' initialize Q, 'P' partial\n  k (int): Number of factors (K >= 1)\n  n (int): Order of each factor (N >= 0)\n  h (int): Hessenberg index (1 <= H <= K)\n  ilo (int): Lower index for active block (1-based)\n  ihi (int): Upper index for active block (1-based)\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  a (ndarray): Matrix factors (N x N x K, F-order)\n\nReturns:\n  (a, q, alphar, alphai, beta, scal, iwarn, info):\n    - a: Transformed matrices\n    - q: Orthogonal factors (if COMPQ != 'N')\n    - alphar, alphai: Scaled eigenvalue real/imaginary parts\n    - beta: Eigenvalue indicator (0 = infinite)\n    - scal: Eigenvalue scaling factors\n    - iwarn: Warning code\n    - info: Exit code (0 = success)\n\nEigenvalue formula: (alphar + alphai*j) / beta * 2^scal\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03bd\n>>> k = 3\n>>> n = 3\n>>> h = 2\n>>> ilo = 1\n>>> ihi = 3\n>>> s = np.array([-1, 1, -1], dtype=np.int32)\n>>> a0 = np.array([\n...     [2.0, 0.0, 1.0],\n...     [0.0, -2.0, -1.0],\n...     [0.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> a1 = np.array([\n...     [1.0, 2.0, 0.0],\n...     [4.0, -1.0, 3.0],\n...     [0.0, 3.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a2 = np.array([\n...     [1.0, 0.0, 1.0],\n...     [0.0, 4.0, -1.0],\n...     [0.0, 0.0, -2.0]\n...     ], order='F', dtype=float)\n>>> a = np.zeros((n, n, k), order='F', dtype=float)\n>>> a[:, :, 0] = a0\n>>> a[:, :, 1] = a1\n>>> a[:, :, 2] = a2\n>>> a_out, q_out, alphar, alphai, beta, scal, iwarn, info = mb03bd(\n...     'S', 'C', 'I', k, n, h, ilo, ihi, s, a\n...     )\n>>> expected_alphar = np.array([0.3230, 0.3230, -0.8752])\n>>> expected_alphai = np.array([0.5694, -0.5694, 0.0])\n>>> expected_beta = np.array([1.0, 1.0, 1.0])\n>>> expected_scal = np.array([0, 0, -1], dtype=np.int32)\n>>> base = 2.0\n>>> eig = []\n>>> i = 0\n...     val = (alphar[i] / beta[i]) * (base ** scal[i])\n...     eig.append(val)\n...     i += 1\n...     else:\n...     val = (complex(alphar[i], alphai[i]) / beta[i]) * (base ** scal[i])\n...     eig.append(val)\n...     eig.append(val.conjugate())\n...     i += 2\n>>> eig = np.array(sorted(eig, key=lambda x: (x.real, x.imag)))\n>>> expected = np.array(sorted([0.3230 + 0.5694j, 0.3230 - 0.5694j, -0.4376], key=lambda x: (x.real, x.imag)))\n>>> info\n0",
  "mb03be": "Apply periodic QZ iterations to 2x2 matrix product.\n\nApplies at most 20 iterations of a real single shifted periodic QZ algorithm\nto the 2-by-2 product of matrices stored in array A. Drives the subdiagonal\nelement A(2,1) of the first factor toward zero.\n\nParameters:\n  k (int): Number of factors (K >= 1)\n  amap (ndarray): Factor access map (K,), 1-based indices\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  sinv (int): Signature multiplier\n  a (ndarray): Matrix factors (2 x 2 x K, F-order)\n\nReturns:\n  a: Modified matrix factors with quasi-triangular first factor\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03be\n>>> k = 2\n>>> a = np.zeros((2, 2, k), dtype=float, order='F')\n>>> a[:, :, 0] = np.array([\n...     [2.0, 1.5],\n...     [0.8, 1.2]\n...     ], order='F')\n>>> a[:, :, 1] = np.array([\n...     [1.5, 0.5],\n...     [0.0, 2.0]\n...     ], order='F')\n>>> amap = np.array([1, 2], dtype=np.int32)\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> sinv = 1\n>>> a_out = mb03be(k, amap, s, sinv, a)\n>>> ai = amap[0] - 1\n>>> subdiag_after = abs(a_out[1, 0, ai])",
  "mb03bf": "Apply periodic QZ iterations to 2x2 matrix product with ULP tolerance.\n\nApplies at most 20 iterations of a real single shifted periodic QZ algorithm\nto the 2-by-2 product of matrices stored in array A. Drives the subdiagonal\nelement A(2,1) of the Hessenberg factor (last one) toward zero.\n\nParameters:\n  k (int): Number of factors (K >= 1)\n  amap (ndarray): Factor access map (K,), 1-based indices\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  sinv (int): Signature multiplier\n  a (ndarray): Matrix factors (2 x 2 x K, F-order)\n  ulp (float): Machine precision for convergence test\n\nReturns:\n  a: Modified matrix factors with quasi-triangular Hessenberg factor\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03bf\n>>> k = 2\n>>> a = np.zeros((2, 2, k), dtype=float, order='F')\n>>> a[:, :, 0] = np.array([\n...     [2.0, 1.5],\n...     [0.8, 1.2]\n...     ], order='F')\n>>> a[:, :, 1] = np.array([\n...     [1.5, 0.5],\n...     [0.0, 2.0]\n...     ], order='F')\n>>> amap = np.array([1, 2], dtype=np.int32)\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> sinv = 1\n>>> ulp = np.finfo(float).eps\n>>> a_out = mb03bf(k, amap, s, sinv, a, ulp)\n>>> ai = amap[k - 1] - 1\n>>> subdiag_after = abs(a_out[1, 0, ai])",
  "mb03bg": "Compute eigenvalues of 2x2 trailing submatrix of matrix product.\n\nComputes the eigenvalues of the 2-by-2 trailing submatrix of the product\nA(:,:,1)^S(1) * A(:,:,2)^S(2) * ... * A(:,:,K)^S(K), where A(:,:,AMAP(K))\nis upper Hessenberg and A(:,:,AMAP(i)) for i < K are upper triangular.\n\nParameters:\n  k (int): Number of factors (K >= 1)\n  n (int): Order of factors (N >= 2)\n  amap (ndarray): Factor access map (K,), 1-based indices\n  s (ndarray): Signature array (K,), each entry 1 or -1\n  sinv (int): Signature multiplier\n  a (ndarray): Matrix factors (N x N x K, F-order)\n\nReturns:\n  (wr, wi): Real and imaginary parts of the two eigenvalues\n\nExamples:\n\n>>> from slicot import mb03bg\n>>> import numpy as np\n>>> k = 1\n>>> n = 2\n>>> amap = np.array([1], dtype=np.int32)\n>>> s = np.array([1], dtype=np.int32)\n>>> sinv = 1\n>>> a = np.zeros((2, 2, 1), dtype=float, order='F')\n>>> a[:, :, 0] = np.array([[3.0, 1.0],\n...     [2.0, 4.0]], order='F')\n>>> wr, wi = mb03bg(k, n, amap, s, sinv, a)\n>>> eigs_computed = wr + 1j * wi\n...     sorted(eigs_computed.real),\n...     rtol=1e-14\n>>> )\n...     sorted(np.abs(eigs_computed.imag)),\n...     rtol=1e-14\n>>> )",
  "mb03bz": "Complex periodic QZ algorithm for eigenvalues of generalized matrix products.\n\nComputes eigenvalues of the complex generalized matrix product:\n  A(:,:,1)^S(1) * A(:,:,2)^S(2) * ... * A(:,:,K)^S(K), S(1) = 1\n\nwhere A(:,:,1) is upper Hessenberg and A(:,:,i), i=2,...,K are upper triangular.\nCan optionally reduce A to periodic Schur form.\n\nParameters:\n  job (str): 'E' eigenvalues only, 'S' Schur form + eigenvalues\n  compq (str): 'N' no Q, 'V' update Q, 'I' initialize Q to identity\n  k (int): Number of factors (K >= 1)\n  n (int): Order of factors (N >= 0)\n  ilo (int): Lower bound of active block (1-based)\n  ihi (int): Upper bound of active block (1-based)\n  s (ndarray): Signature array (K,), S(1)=1, others +1 or -1\n  a (ndarray): Matrix factors (N x N x K, F-order, complex128)\n  q (ndarray, optional): Initial Q matrices (N x N x K) if COMPQ='V'\n\nReturns:\n  (a, q, alpha, beta, scal, info):\n    - a: Transformed matrices (Schur form if JOB='S')\n    - q: Unitary factors (if COMPQ != 'N')\n    - alpha: Scaled eigenvalues (complex, dimension N)\n    - beta: Infinite eigenvalue indicator (complex, dimension N)\n    - scal: Scaling exponents (int, dimension N)\n    - info: Exit code (0=success, <0=param error, >0=convergence failure)\n\nEigenvalue formula: alpha(i) / beta(i) * BASE^scal(i)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03bz\n>>> k = 3\n>>> n = 4\n>>> ilo = 1\n>>> ihi = 4\n>>> a1 = np.array([\n...     [0.8637+0.9326j, 0.8819+0.4850j, 0.5920+0.8826j, 0.8991+0.9040j],\n...     [0.6994+0.8588j, 0.9527+0.2672j, 0.5087+0.0621j, 0.9653+0.5715j],\n...     [0.0+0.0j,       0.1561+0.1898j, 0.9514+0.9266j, 0.6582+0.3102j],\n...     [0.0+0.0j,       0.0+0.0j,       0.8649+0.1265j, 0.1701+0.0013j]\n...     ], dtype=np.complex128, order='F')\n>>> a2 = np.array([\n...     [0.5113+0.7375j, 0.6869+0.7692j, 0.7812+0.1467j, 0.7216+0.9498j],\n...     [0.0+0.0j,       0.1319+0.9137j, 0.5879+0.0201j, 0.9834+0.0549j],\n...     [0.0+0.0j,       0.0+0.0j,       0.7711+0.2422j, 0.9468+0.3280j],\n...     [0.0+0.0j,       0.0+0.0j,       0.0+0.0j,       0.2219+0.3971j]\n...     ], dtype=np.complex128, order='F')\n>>> a3 = np.array([\n...     [0.0158+0.4042j, 0.0082+0.2033j, 0.1028+0.9913j, 0.6954+0.1987j],\n...     [0.0+0.0j,       0.5066+0.4587j, 0.1060+0.6949j, 0.5402+0.0970j],\n...     [0.0+0.0j,       0.0+0.0j,       0.4494+0.3700j, 0.8492+0.4882j],\n...     [0.0+0.0j,       0.0+0.0j,       0.0+0.0j,       0.2110+0.5824j]\n...     ], dtype=np.complex128, order='F')\n>>> a = np.zeros((n, n, k), dtype=np.complex128, order='F')\n>>> a[:, :, 0] = a1\n>>> a[:, :, 1] = a2\n>>> a[:, :, 2] = a3\n>>> s = np.array([1, -1, 1], dtype=np.int32)\n>>> a_out, q_out, alpha, beta, scal, info = mb03bz('S', 'I', k, n, ilo, ihi, s, a)\n...     f\"a_out[{i},{i},{l}] diagonal should be real\"\n...     f\"a_out[{i},{i},{l}] diagonal should be non-negative\"\n...     qh = np.conj(q_out[:, :, l].T)\n...     identity_check = qh @ q_out[:, :, l]\n>>> info\n0",
  "mb03cd": "Exchange eigenvalues in block triangular pencils.\n\nComputes orthogonal matrices Q1, Q2, Q3 for a real 2-by-2, 3-by-3, or 4-by-4\nregular block upper triangular pencil aAB - bD such that the eigenvalues in\nSpec(A11*B11, D11) and Spec(A22*B22, D22) are exchanged.\n\nFor UPLO='U': Upper block triangular, eigenvalues are exchanged.\nFor UPLO='L': Lower block triangular, eigenvalues are NOT exchanged.\n\nParameters:\n  uplo (str): 'U' upper block triangular, 'L' lower block triangular\n  n1 (int): Size of upper left block (N1 <= 2)\n  n2 (int): Size of lower right block (N2 <= 2)\n  prec (float): Machine precision (from DLAMCH)\n  a (ndarray): Matrix A of pencil (n1+n2 x n1+n2, F-order)\n  b (ndarray): Matrix B of pencil (n1+n2 x n1+n2, F-order)\n  d (ndarray): Matrix D of pencil (n1+n2 x n1+n2, F-order)\n\nReturns:\n  (a, b, d, q1, q2, q3, n1, n2, info):\n    - a, b, d: Transformed matrices\n    - q1, q2, q3: Orthogonal transformation matrices\n    - n1, n2: Exchanged block sizes (if UPLO='U')\n    - info: Exit code (0=success, 1-5=algorithm error)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03cd\n>>> n1, n2 = 1, 1\n>>> m = n1 + n2\n>>> a = np.array([\n...     [2.0, 0.5],\n...     [0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.2],\n...     [0.0, 1.5]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [1.0, 0.1],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> prec = np.finfo(float).eps\n>>> a_out, b_out, d_out, q1, q2, q3, n1_out, n2_out, info = mb03cd(\n...     uplo='U', n1=n1, n2=n2, prec=prec, a=a, b=b, d=d\n...     )\n>>> info\n0",
  "mb03cz": "Exchange eigenvalues of complex 2x2 upper triangular pencil.\n\nComputes unitary matrices Q1, Q2, Q3 for a complex 2-by-2 regular pencil\naAB - bD, with A, B, D upper triangular, such that Q3' A Q2, Q2' B Q1,\nQ3' D Q1 are still upper triangular, but the eigenvalues are in reversed order.\n\nThe matrices Q1, Q2, Q3 are represented by:\n  Q = [[co, si], [-conj(si), co]]\n\nParameters:\n  a (ndarray): Complex 2x2 upper triangular matrix A (F-order, complex128)\n  b (ndarray): Complex 2x2 upper triangular matrix B (F-order, complex128)\n  d (ndarray): Complex 2x2 upper triangular matrix D (F-order, complex128)\n\nReturns:\n  (co1, si1, co2, si2, co3, si3): Unitary matrix parameters\n    - co1, co2, co3: Cosines (real)\n    - si1, si2, si3: Sines (complex)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03cz\n>>> a = np.array([\n...     [1.0 + 0.5j, 0.3 - 0.2j],\n...     [0.0 + 0.0j, 2.0 - 1.0j]\n...     ], dtype=np.complex128, order='F')\n>>> b = np.array([\n...     [0.5 + 0.1j, -0.4 + 0.3j],\n...     [0.0 + 0.0j, 1.5 - 0.5j]\n...     ], dtype=np.complex128, order='F')\n>>> d = np.array([\n...     [1.0 + 0.0j, 0.2 + 0.1j],\n...     [0.0 + 0.0j, 0.8 - 0.2j]\n...     ], dtype=np.complex128, order='F')\n>>> co1, si1, co2, si2, co3, si3 = mb03cz(a, b, d)\n>>> q1 = np.array([\n...     [co1, si1],\n...     [-np.conj(si1), co1]\n...     ], dtype=np.complex128)\n>>> q2 = np.array([\n...     [co2, si2],\n...     [-np.conj(si2), co2]\n...     ], dtype=np.complex128)\n>>> q3 = np.array([\n...     [co3, si3],\n...     [-np.conj(si3), co3]\n...     ], dtype=np.complex128)\n...     q1 @ q1.conj().T, np.eye(2), rtol=1e-14, atol=1e-14\n>>> )\n...     q2 @ q2.conj().T, np.eye(2), rtol=1e-14, atol=1e-14\n>>> )\n...     q3 @ q3.conj().T, np.eye(2), rtol=1e-14, atol=1e-14\n>>> )\n>>> a_trans = q3.conj().T @ a @ q2\n>>> b_trans = q2.conj().T @ b @ q1\n>>> d_trans = q3.conj().T @ d @ q1",
  "mb03dd": "Exchange eigenvalues of real block upper triangular pencil.\n\nComputes orthogonal matrices Q1 and Q2 for a real 2-by-2, 3-by-3, or 4-by-4\nregular block upper triangular pencil aA - bB such that the pencil\na(Q2' A Q1) - b(Q2' B Q1) is still in block upper triangular form, but\nthe eigenvalues in Spec(A11, B11), Spec(A22, B22) are exchanged.\n\nOptionally, upper triangularizes the real regular pencil in block lower\ntriangular form while keeping eigenvalues in the same diagonal position.\n\nParameters:\n  uplo (str): 'U' upper block triangular (eigenvalues exchanged),\n              'T' upper block triangular with B triangular (eigenvalues exchanged),\n              'L' lower block triangular (eigenvalues NOT exchanged)\n  n1 (int): Size of upper left block (N1 <= 2)\n  n2 (int): Size of lower right block (N2 <= 2)\n  prec (float): Machine precision (from DLAMCH)\n  a (ndarray): Matrix A of pencil (n1+n2 x n1+n2, F-order)\n  b (ndarray): Matrix B of pencil (n1+n2 x n1+n2, F-order)\n\nReturns:\n  (a, b, q1, q2, n1, n2, info):\n    - a, b: Transformed matrices\n    - q1, q2: Orthogonal transformation matrices\n    - n1, n2: Exchanged block sizes (if UPLO='U'/'T' and INFO=0)\n    - info: Exit code (0=success, 3=QZ failed, 4=DHGEQZ error, 5=DTGSEN reorder failed)\n\nExamples:\n\n>>> from slicot import mb03dd\n>>> import numpy as np\n>>> n1, n2 = 1, 1\n>>> m = n1 + n2\n>>> prec = np.finfo(float).eps\n>>> a = np.array([[2.0, 1.0],\n...     [0.0, 3.0]], order='F', dtype=float)\n>>> b = np.array([[1.0, 0.5],\n...     [0.0, 2.0]], order='F', dtype=float)\n>>> a_out, b_out, q1, q2, n1_out, n2_out, info = mb03dd('U', n1, n2, prec, a, b)\n>>> eig_trans = np.linalg.eigvals(a_out @ np.linalg.inv(b_out))\n>>> info\n0",
  "mb03dz": "Exchange eigenvalues of complex 2x2 upper triangular pencil.\n\nComputes unitary matrices Q1 and Q2 for a complex 2-by-2 regular pencil\naA - bB with A, B upper triangular, such that Q2' (aA - bB) Q1 is still\nupper triangular but the eigenvalues are in reversed order.\n\nThe matrices Q1 and Q2 are represented by:\n     (  CO1  SI1  )       (  CO2  SI2  )\nQ1 = (            ), Q2 = (            ).\n     ( -SI1' CO1  )       ( -SI2' CO2  )\n\nwhere ' denotes conjugate transpose.\n\nParameters:\n  a (ndarray): Complex 2x2 upper triangular matrix A (F-order)\n  b (ndarray): Complex 2x2 upper triangular matrix B (F-order)\n\nReturns:\n  (co1, si1, co2, si2):\n    - co1 (float): Cosine of Q1\n    - si1 (complex): Sine of Q1\n    - co2 (float): Cosine of Q2\n    - si2 (complex): Sine of Q2\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03dz\n>>> a = np.array([\n...     [1.0 + 0.5j, 0.3 - 0.2j],\n...     [0.0 + 0.0j, 2.0 - 1.0j]\n...     ], dtype=np.complex128, order='F')\n>>> b = np.array([\n...     [0.5 + 0.1j, -0.4 + 0.3j],\n...     [0.0 + 0.0j, 1.5 - 0.5j]\n...     ], dtype=np.complex128, order='F')\n>>> co1, si1, co2, si2 = mb03dz(a, b)\n>>> q1 = np.array([\n...     [co1, si1],\n...     [-np.conj(si1), co1]\n...     ], dtype=np.complex128)\n>>> q2 = np.array([\n...     [co2, si2],\n...     [-np.conj(si2), co2]\n...     ], dtype=np.complex128)\n...     q1 @ q1.conj().T, np.eye(2), rtol=1e-14, atol=1e-14\n>>> )\n...     q2 @ q2.conj().T, np.eye(2), rtol=1e-14, atol=1e-14\n>>> )\n>>> a_trans = q2.conj().T @ a @ q1\n>>> b_trans = q2.conj().T @ b @ q1",
  "mb03ed": "Compute orthogonal matrices for 2x2 or 4x4 skew-Hamiltonian/Hamiltonian pencil.\n\nComputes orthogonal matrices Q1, Q2, Q3 for a real 2-by-2 or 4-by-4 regular\npencil aAB - bD, such that Q3' A Q2 and Q2' B Q1 are upper triangular,\nQ3' D Q1 is upper quasi-triangular, and eigenvalues with negative real parts\n(if any) are allocated on top.\n\nThe pencil has the form:\n    ( A11  0  ) ( B11  0  )     (  0  D12 )\na * (         ) (         ) - b (         )\n    (  0  A22 ) (  0  B22 )     ( D21  0  )\n\nwhere A11, A22, B11, B22, D12 are upper triangular.\n\nParameters:\n  n (int): Order of the input pencil, N = 2 or N = 4\n  prec (float): Machine precision (relative machine precision * base)\n  a (ndarray): N-by-N upper triangular matrix A of pencil (F-order)\n  b (ndarray): N-by-N upper triangular matrix B of pencil (F-order)\n  d (ndarray): N-by-N matrix D of pencil (F-order)\n\nReturns:\n  (d, q1, q2, q3, info):\n    - d: Transformed D (Schur form if N=4, unchanged if N=2)\n    - q1: First orthogonal transformation matrix (N x N)\n    - q2: Second orthogonal transformation matrix (N x N)\n    - q3: Third orthogonal transformation matrix (N x N)\n    - info: Exit code (0=success, 1=QZ failed, 2=other DGGES error)\n\nExamples:\n\n>>> from slicot import mb03ed\n>>> import numpy as np\n>>> prec = np.finfo(float).eps\n>>> n = 2\n>>> a = np.array([[2.0, 0.0],\n...     [0.0, 3.0]], order='F', dtype=float)\n>>> b = np.array([[1.0, 0.0],\n...     [0.0, 2.0]], order='F', dtype=float)\n>>> d = np.array([[0.0, 1.0],\n...     [2.0, 0.0]], order='F', dtype=float)\n>>> d_out, q1, q2, q3, info = mb03ed(n, prec, a, b, d)\n>>> info\n0",
  "mb03fd": "Reduce 2x2 or 4x4 block diagonal skew-Hamiltonian/Hamiltonian pencil to Schur form.\n\nComputes orthogonal matrices Q1 and Q2 for a real 2-by-2 or 4-by-4 regular\npencil aA - bB where:\n  A = [A11 0; 0 A22] (block diagonal, upper triangular blocks)\n  B = [0 B12; B21 0] (anti-block-diagonal)\n\nsuch that Q2' A Q1 is upper triangular, Q2' B Q1 is upper quasi-triangular,\nand eigenvalues with negative real parts (if any) are allocated on top.\n\nFor N=2 with real eigenvalues, computes Givens rotations. For N=4, uses\nDGGES (generalized Schur decomposition) with balancing fallback.\n\nParameters:\n  n (int): Order of the pencil, N = 2 or N = 4\n  prec (float): Machine precision (relative machine precision * base)\n  a (ndarray): N-by-N block diagonal matrix A (F-order)\n  b (ndarray): N-by-N anti-block-diagonal matrix B (F-order)\n\nReturns:\n  (a, b, q1, q2, info):\n    - a: Transformed A (upper triangular if N=4, unchanged if N=2)\n    - b: Transformed B (quasi-triangular if N=4, unchanged if N=2)\n    - q1: First orthogonal transformation matrix (N x N)\n    - q2: Second orthogonal transformation matrix (N x N)\n    - info: Exit code (0=success, 1=QZ failed in DGGES, 2=other DGGES error)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03fd\n>>> n = 2\n>>> prec = np.finfo(float).eps\n>>> a = np.array([\n...     [2.0, 0.0],\n...     [0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0, 1.5],\n...     [2.0, 0.0]\n...     ], order='F', dtype=float)\n>>> a_out, b_out, q1, q2, info = mb03fd(n=n, prec=prec, a=a, b=b)\n>>> info\n0",
  "mb03fz": "Eigenvalues and deflating subspace of complex skew-Hamiltonian/Hamiltonian pencil.\n\nComputes eigenvalues of a complex N-by-N skew-Hamiltonian/Hamiltonian pencil\naS - bH with S = J*Z'*J'*Z and H = [[B,F],[G,-B']] where J = [[0,I],[-I,0]].\n\nOptionally computes orthonormal basis of right deflating subspace (Q) and\ncompanion subspace (U) corresponding to eigenvalues with strictly negative\nreal part.\n\nParameters:\n  compq (str): 'N'=no Q, 'C'=compute deflating subspace Q\n  compu (str): 'N'=no U, 'C'=compute companion subspace U\n  orth (str): Orthogonalization method: 'P'=QR with pivoting, 'S'=SVD, 'Q'=QR\n  n (int): Order of pencil (n >= 0, must be even)\n  z (ndarray): N-by-N complex matrix Z (F-order)\n  b (ndarray): N/2-by-N/2 complex matrix B (F-order)\n  fg (ndarray): N/2-by-(N/2+1) packed F and G (F-order)\n\nReturns:\n  (z, b, fg, neig, d, c, q, u, alphar, alphai, beta, info):\n    Transformed matrices, number of negative eigenvalues, output matrices,\n    deflating/companion subspaces, eigenvalue components, exit code.\n    Eigenvalue = (alphar + i*alphai) / beta\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03fz\n>>> n = 4\n>>> m = n // 2\n>>> z = np.array([\n...     [0.0328 + 0.9611j, 0.6428 + 0.2585j, 0.7033 + 0.4254j, 0.2552 + 0.7053j],\n...     [0.0501 + 0.2510j, 0.2827 + 0.8865j, 0.4719 + 0.5387j, 0.0389 + 0.5676j],\n...     [0.5551 + 0.4242j, 0.0643 + 0.2716j, 0.1165 + 0.7875j, 0.9144 + 0.3891j],\n...     [0.0539 + 0.7931j, 0.0408 + 0.2654j, 0.9912 + 0.0989j, 0.0991 + 0.6585j]\n...     ], dtype=np.complex128, order='F')\n>>> b = np.array([\n...     [0.0547 + 0.8726j, 0.4008 + 0.8722j],\n...     [0.7423 + 0.6166j, 0.2631 + 0.5872j]\n...     ], dtype=np.complex128, order='F')\n>>> fg = np.array([\n...     [0.8740 + 0.0j,         0.3697 + 0.0j,         0.9178 + 0.6418j],\n...     [0.7748 + 0.5358j,      0.1652 + 0.0j,         0.2441 + 0.0j]\n...     ], dtype=np.complex128, order='F')\n>>> (z_out, b_out, fg_out, neig, d, c, q, u,\n...     alphar, alphai, beta, info) = mb03fz('C', 'C', 'P', n, z, b, fg)",
  "mb03gd": "Exchange eigenvalues of 2x2 or 4x4 skew-Hamiltonian/Hamiltonian pencil (factored).\n\nComputes orthogonal matrix Q and orthogonal symplectic matrix U for a real\nregular 2-by-2 or 4-by-4 skew-Hamiltonian/Hamiltonian pencil a J B' J' B - b D\nwith B = [[B11,B12],[0,B22]], D = [[D11,D12],[0,-D11']], J = [[0,I],[-I,0]].\n\nSuch that J Q' J' D Q and U' B Q keep block triangular form, but eigenvalues\nare reordered.\n\nParameters:\n  n (int): Order of pencil, N = 2 or N = 4\n  b (ndarray): N-by-N upper block triangular matrix B (F-order)\n  d (ndarray): (N/2)-by-N array, first block row of Hamiltonian D (F-order)\n  macpar (ndarray): Machine parameters [DLAMCH('P'), DLAMCH('S')]. Not used for N=2.\n\nReturns:\n  (q, u, info):\n    - q (ndarray): N-by-N orthogonal transformation matrix Q\n    - u (ndarray): N-by-N orthogonal symplectic transformation matrix U\n    - info (int): 0=success, 1=B11 or B22 numerically singular\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03gd\n>>> n = 2\n>>> b = np.array([\n...     [2.0, 0.5],\n...     [0.0, 1.5]\n...     ], order='F', dtype=float)\n>>> d = np.array([[1.0, 0.3]], order='F', dtype=float)\n>>> macpar = np.array([2.2e-16, 2.2e-308], dtype=float)\n>>> q, u, info = mb03gd(n, b, d, macpar)\n>>> info\n0",
  "mb03gz": "Compute unitary matrices for 2x2 skew-Hamiltonian/Hamiltonian pencil.\n\nComputes a unitary matrix Q and a unitary symplectic matrix U for a complex\nregular 2-by-2 skew-Hamiltonian/Hamiltonian pencil aS - bH with S = J Z' J' Z,\nwhere Z and H are upper triangular.\n\nThe matrices Q and U are represented by:\n  Q = [[CO1, SI1], [-conj(SI1), CO1]]\n  U = [[CO2, SI2], [-conj(SI2), CO2]]\n\nSuch that U' Z Q and (J Q J')' H Q are both upper triangular, but the\neigenvalues are in reversed order.\n\nParameters:\n  z11 (complex): Upper left element of Z\n  z12 (complex): Upper right element of Z\n  z22 (complex): Lower right element of Z\n  h11 (complex): Upper left element of H\n  h12 (complex): Upper right element of H\n\nReturns:\n  (co1, si1, co2, si2):\n    - co1 (float): Cosine element of Q\n    - si1 (complex): Sine element of Q\n    - co2 (float): Cosine element of U\n    - si2 (complex): Sine element of U\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03gz\n>>> z11 = 1.0 + 0.5j\n>>> z12 = 0.3 - 0.2j\n>>> z22 = 2.0 - 1.0j\n>>> h11 = 0.5 + 0.1j\n>>> h12 = -0.4 + 0.3j\n>>> co1, si1, co2, si2 = mb03gz(z11, z12, z22, h11, h12)\n>>> q = np.array([\n...     [co1, si1],\n...     [-np.conj(si1), co1]\n...     ], dtype=np.complex128)\n>>> u = np.array([\n...     [co2, si2],\n...     [-np.conj(si2), co2]\n...     ], dtype=np.complex128)\n...     q @ q.conj().T, np.eye(2), rtol=1e-14, atol=1e-14\n>>> )\n...     u @ u.conj().T, np.eye(2), rtol=1e-14, atol=1e-14\n>>> )",
  "mb03hd": "Exchange eigenvalues of 2x2 or 4x4 skew-Hamiltonian/Hamiltonian pencil.\n\nComputes an orthogonal matrix Q for a real regular 2-by-2 or 4-by-4\nskew-Hamiltonian/Hamiltonian pencil in structured Schur form:\n\n              ( A11 A12  )     ( B11  B12  )\n  aA - bB = a (          ) - b (           )\n              (  0  A11' )     (  0  -B11' )\n\nsuch that J Q' J' (aA - bB) Q is still in structured Schur form but the\neigenvalues are exchanged.\n\nParameters:\n  n (int): Order of the pencil, N = 2 or N = 4\n  a (ndarray): N/2-by-N array. First block row of skew-Hamiltonian A.\n               Only (1,1), (1,2), (1,4), (2,2) referenced for N=4. Not used for N=2.\n  b (ndarray): N/2-by-N array. First block row of Hamiltonian B.\n  macpar (ndarray): Machine parameters [DLAMCH('P'), DLAMCH('S')]. Not used for N=2.\n\nReturns:\n  (q, info):\n    - q (ndarray): N-by-N orthogonal transformation matrix Q\n    - info (int): 0=success, 1=B11 nearly singular (perturbed values used)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03hd\n>>> n = 2\n>>> b = np.array([\n...     [1.0, 0.5],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> a = np.zeros((1, 2), order='F', dtype=float)\n>>> macpar = np.array([1e-16, 1e-308], dtype=float)\n>>> q, info = mb03hd(n, a, b, macpar)\n>>> info\n0",
  "mb03hz": "Exchange eigenvalues of complex 2x2 skew-Hamiltonian/Hamiltonian pencil.\n\nComputes a unitary matrix Q for a complex regular 2-by-2\nskew-Hamiltonian/Hamiltonian pencil aS - bH with\n\n    (  S11  S12  )        (  H11  H12  )\nS = (            ),   H = (            ),\n    (   0   S11' )        (   0  -H11' )\n\nsuch that J Q' J' (aS - bH) Q is upper triangular but the eigenvalues\nare in reversed order. The matrix Q is represented by\n\n    (  CO  SI  )\nQ = (          ).\n    ( -SI' CO  )\n\nThe notation M' denotes the conjugate transpose of the matrix M.\n\nParameters:\n  s11 (complex): Upper left element of skew-Hamiltonian matrix S\n  s12 (complex): Upper right element of skew-Hamiltonian matrix S\n  h11 (complex): Upper left element of Hamiltonian matrix H\n  h12 (complex): Upper right element of Hamiltonian matrix H\n\nReturns:\n  (co, si):\n    - co (float): Upper left element of Q (real)\n    - si (complex): Upper right element of Q\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03hz\n>>> s11 = 1.0 + 0.5j\n>>> s12 = 0.3 - 0.2j\n>>> h11 = 0.5 + 0.1j\n>>> h12 = -0.4 + 0.3j\n>>> co, si = mb03hz(s11, s12, h11, h12)\n>>> q = np.array([\n...     [co, si],\n...     [-np.conj(si), co]\n...     ], dtype=np.complex128)\n...     q @ q.conj().T, np.eye(2), rtol=1e-14, atol=1e-14\n>>> )",
  "mb03id": "Reorder eigenvalues of real skew-Hamiltonian/Hamiltonian pencil (factored version).\n\nMoves eigenvalues with strictly negative real parts of an N-by-N real\nskew-Hamiltonian/Hamiltonian pencil aS - bH in structured Schur form to the\nleading principal subpencil, while keeping the triangular form.\n\nOn entry: S = J Z' J' Z, J = [[0, I], [-I, 0]], Z = [[A, D], [0, C]], H = [[B, F], [0, -B']]\nwhere A is upper triangular, B is upper quasi-triangular, C is lower triangular.\n\nParameters:\n  compq (str): 'N'=no Q, 'I'=init Q to identity, 'U'=update Q\n  compu (str): 'N'=no U, 'I'=init U to identity, 'U'=update U\n  n (int): Order of the pencil (n >= 0, even)\n  a (ndarray): Upper triangular matrix A (n/2 x n/2, F-order)\n  c (ndarray): Lower triangular matrix C (n/2 x n/2, F-order)\n  d (ndarray): Matrix D (n/2 x n/2, F-order)\n  b (ndarray): Upper quasi-triangular matrix B (n/2 x n/2, F-order)\n  f (ndarray): Symmetric matrix F upper part (n/2 x n/2, F-order)\n  q (ndarray, optional): Orthogonal matrix Q (n x n, F-order)\n  u1 (ndarray, optional): Upper left block of orthogonal symplectic U (n/2 x n/2, F-order)\n  u2 (ndarray, optional): Upper right block of orthogonal symplectic U (n/2 x n/2, F-order)\n\nReturns:\n  (a, c, d, b, f, q, u1, u2, neig, info):\n    a, c, d, b, f: Transformed matrices\n    q: Orthogonal matrix Q\n    u1, u2: Blocks of orthogonal symplectic U\n    neig (int): Number of eigenvalues with negative real part\n    info (int): 0 = success, <0 = -i means i-th argument invalid, 1=QZ failed, 2=MB03CD error, 3=MB03GD error\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03id\n>>> n = 4\n>>> m = n // 2  # m = 2\n>>> a = np.zeros((m, m), dtype=float, order='F')\n>>> a[0, 0] = 2.0\n>>> a[0, 1] = 0.5\n>>> a[1, 1] = 3.0\n>>> c = np.zeros((m, m), dtype=float, order='F')\n>>> c[0, 0] = 1.0\n>>> c[1, 0] = 0.3\n>>> c[1, 1] = 2.0\n>>> d = np.array([[0.1, 0.2], [0.3, 0.4]], dtype=float, order='F')\n>>> b = np.zeros((m, m), dtype=float, order='F')\n>>> b[0, 0] = -1.0  # Negative eigenvalue\n>>> b[0, 1] = 0.2\n>>> b[1, 1] = 1.0   # Positive eigenvalue\n>>> f = np.array([[0.5, 0.1], [0.0, 0.6]], dtype=float, order='F')\n>>> (a_out, c_out, d_out, b_out, f_out, q_out, u1_out, u2_out,\n...     neig, info) = mb03id('I', 'I', n, a, c, d, b, f)\n>>> qtq = q_out.T @ q_out\n>>> u1tu1_u2tu2 = u1_out.T @ u1_out + u2_out.T @ u2_out\n>>> u1tu2 = u1_out.T @ u2_out\n>>> u2tu1 = u2_out.T @ u1_out",
  "mb03iz": "Reorder eigenvalues of complex skew-Hamiltonian/Hamiltonian pencil.\n\nMoves eigenvalues with strictly negative real parts of an N-by-N complex\nskew-Hamiltonian/Hamiltonian pencil aS - bH in structured Schur form to the\nleading principal subpencil, while keeping the triangular form.\n\nParameters:\n  compq (str): 'N'=no Q, 'I'=init Q to identity, 'U'=update Q\n  compu (str): 'N'=no U, 'I'=init U to identity, 'U'=update U\n  n (int): Order of the pencil (n >= 0, even)\n  a (ndarray): Upper triangular matrix A (n/2 x n/2, complex, F-order)\n  c (ndarray): Lower triangular matrix C (n/2 x n/2, complex, F-order)\n  d (ndarray): Matrix D (n/2 x n/2, complex, F-order)\n  b (ndarray): Upper triangular matrix B (n/2 x n/2, complex, F-order)\n  f (ndarray): Hermitian matrix F upper part (n/2 x n/2, complex, F-order)\n  tol (float): Tolerance for eigenvalue sign (tol <= 0 uses default)\n  q (ndarray, optional): Unitary matrix Q (n x n, complex, F-order)\n  u1 (ndarray, optional): Upper left block of U (n/2 x n/2, complex, F-order)\n  u2 (ndarray, optional): Upper right block of U (n/2 x n/2, complex, F-order)\n\nReturns:\n  (a, c, d, b, f, q, u1, u2, neig, info):\n    a, c, d, b, f: Transformed matrices\n    q: Unitary matrix Q\n    u1, u2: Blocks of unitary symplectic U\n    neig (int): Number of eigenvalues with negative real part\n    info (int): 0 = success, <0 = -i means i-th argument invalid\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03iz\n>>> n = 4\n>>> m = n // 2\n>>> a = np.array([\n...     [1.0 + 0.5j, 0.3 - 0.2j],\n...     [0.0 + 0.0j, -0.5 + 0.1j]\n...     ], dtype=np.complex128, order='F')\n>>> c = np.array([\n...     [0.8 + 0.1j, 0.0 + 0.0j],\n...     [0.2 - 0.3j, 0.6 + 0.2j]\n...     ], dtype=np.complex128, order='F')\n>>> d = np.array([\n...     [0.4 + 0.2j, -0.1 + 0.1j],\n...     [0.1 - 0.2j, 0.3 + 0.1j]\n...     ], dtype=np.complex128, order='F')\n>>> b = np.array([\n...     [0.7 + 0.3j, 0.2 - 0.1j],\n...     [0.0 + 0.0j, 0.4 + 0.2j]\n...     ], dtype=np.complex128, order='F')\n>>> f = np.array([\n...     [1.0 + 0.0j, 0.1 - 0.05j],\n...     [0.1 + 0.05j, 0.8 + 0.0j]\n...     ], dtype=np.complex128, order='F')\n>>> tol = 0.0\n>>> a_out, c_out, d_out, b_out, f_out, q, u1, u2, neig, info = mb03iz(\n...     'I', 'I', n, a, c, d, b, f, tol\n...     )\n...     q @ q.conj().T, np.eye(n), rtol=1e-13, atol=1e-14\n>>> )\n>>> u_full = np.block([\n...     [u1, u2],\n...     [-np.conj(u2), np.conj(u1)]\n...     ])\n...     u_full @ u_full.conj().T, np.eye(n), rtol=1e-13, atol=1e-14\n>>> )\n>>> info\n0",
  "mb03jd": "Reorder eigenvalues of real skew-Hamiltonian/Hamiltonian pencil.\n\nMoves eigenvalues with strictly negative real parts of an N-by-N real\nskew-Hamiltonian/Hamiltonian pencil aS - bH in structured Schur form to the\nleading principal subpencil, while keeping the triangular form.\n\nParameters:\n  compq (str): 'N'=no Q, 'I'=init Q to identity, 'U'=update Q\n  n (int): Order of the pencil (n >= 0, even)\n  a (ndarray): Upper triangular matrix A (n/2 x n/2, F-order)\n  d (ndarray): Skew-symmetric matrix D upper part (n/2 x n/2, F-order)\n  b (ndarray): Upper quasi-triangular matrix B (n/2 x n/2, F-order)\n  f (ndarray): Symmetric matrix F upper part (n/2 x n/2, F-order)\n  q (ndarray, optional): Orthogonal matrix Q (n x n, F-order)\n\nReturns:\n  (a, d, b, f, q, neig, info):\n    a, d, b, f: Transformed matrices\n    q: Orthogonal matrix Q\n    neig (int): Number of eigenvalues with negative real part\n    info (int): 0 = success, <0 = -i means i-th argument invalid\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03jd\n>>> n = 4\n>>> m = n // 2\n>>> a = np.array([\n...     [1.0, 0.5],\n...     [0.0, -0.8]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0, 0.3],\n...     [-0.3, 0.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.7, 0.2],\n...     [0.0, 0.4]\n...     ], order='F', dtype=float)\n>>> f = np.array([\n...     [1.0, 0.1],\n...     [0.1, 0.8]\n...     ], order='F', dtype=float)\n>>> a_out, d_out, b_out, f_out, q, neig, info = mb03jd('I', n, a, d, b, f)\n>>> info\n0",
  "mb03jp": "Reorder eigenvalues of real skew-Hamiltonian/Hamiltonian pencil (panel variant).\n\nPanel-based blocked variant of MB03JD for better performance on large matrices.\nMoves eigenvalues with strictly negative real parts of an N-by-N real\nskew-Hamiltonian/Hamiltonian pencil aS - bH in structured Schur form to the\nleading principal subpencil, while keeping the triangular form.\n\nParameters:\n  compq (str): 'N'=no Q, 'I'=init Q to identity, 'U'=update Q\n  n (int): Order of the pencil (n >= 0, even)\n  a (ndarray): Upper triangular matrix A (n/2 x n/2, F-order)\n  d (ndarray): Skew-symmetric matrix D upper part (n/2 x n/2, F-order)\n  b (ndarray): Upper quasi-triangular matrix B (n/2 x n/2, F-order)\n  f (ndarray): Symmetric matrix F upper part (n/2 x n/2, F-order)\n  q (ndarray, optional): Orthogonal matrix Q (n x n, F-order)\n\nReturns:\n  (a, d, b, f, q, neig, info):\n    a, d, b, f: Transformed matrices\n    q: Orthogonal matrix Q\n    neig (int): Number of eigenvalues with negative real part\n    info (int): 0 = success, <0 = -i means i-th argument invalid\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03jp\n>>> n = 4\n>>> m = n // 2\n>>> a = np.array([\n...     [1.0, 0.5],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0, 0.3],\n...     [0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [-1.0, 0.2],\n...     [0.0, 0.5]\n...     ], order='F', dtype=float)\n>>> f = np.array([\n...     [0.5, 0.1],\n...     [0.0, 0.3]\n...     ], order='F', dtype=float)\n>>> a_out, d_out, b_out, f_out, q_out, neig, info = mb03jp(\n...     compq='I', n=n, a=a, d=d, b=b, f=f\n...     )\n>>> qtq = q_out.T @ q_out\n...     err_msg=\"Q should be orthogonal\")\n>>> info\n0",
  "mb03jz": "Reorder eigenvalues of complex skew-Hamiltonian/Hamiltonian pencil.\n\nMoves eigenvalues with strictly negative real parts of an N-by-N complex\nskew-Hamiltonian/Hamiltonian pencil aS - bH in structured Schur form to the\nleading principal subpencil, while keeping the triangular form.\n\nOn entry: S = [[A, D], [0, A']], H = [[B, F], [0, -B']]\nwhere A, B are upper triangular, D is skew-Hermitian, F is Hermitian.\n\nParameters:\n  compq (str): 'N'=no Q, 'I'=init Q to identity, 'U'=update Q\n  n (int): Order of the pencil (n >= 0, even)\n  a (ndarray): Upper triangular matrix A (n/2 x n/2, F-order, complex)\n  d (ndarray): Skew-Hermitian matrix D upper part (n/2 x n/2, F-order, complex)\n  b (ndarray): Upper triangular matrix B (n/2 x n/2, F-order, complex)\n  f (ndarray): Hermitian matrix F upper part (n/2 x n/2, F-order, complex)\n  q (ndarray, optional): Unitary matrix Q (n x n, F-order, complex)\n  tol (float, optional): Tolerance for eigenvalue sign (default: MIN(N,10)*EPS)\n\nReturns:\n  (a, d, b, f, q, neig, info):\n    a, d, b, f: Transformed matrices (complex)\n    q: Unitary matrix Q (complex)\n    neig (int): Number of eigenvalues with negative real part\n    info (int): 0 = success, <0 = -i means i-th argument invalid\n\nExamples:\n\n>>> from slicot import mb03jz\n>>> import numpy as np\n>>> m = 2  # n = 2*m = 4\n>>> n = 2 * m\n>>> a = np.array([[1.0 + 0.0j, 0.3 - 0.2j],\n...     [0.0, 2.0 + 0.0j]], dtype=complex, order='F')\n>>> b = np.array([[1.0 + 0.0j, 0.2 + 0.1j],\n...     [0.0, 3.0 + 0.0j]], dtype=complex, order='F')\n>>> d = np.array([[0.5j, 0.1 + 0.2j],\n...     [0.0, -0.3j]], dtype=complex, order='F')\n>>> f = np.array([[1.0, 0.2 - 0.1j],\n...     [0.0, 0.8]], dtype=complex, order='F')\n>>> a_out, d_out, b_out, f_out, q_out, neig, info = mb03jz(\n...     'I', n, a.copy(order='F'), d.copy(order='F'),\n...     b.copy(order='F'), f.copy(order='F')\n...     )\n...     rtol=1e-14, atol=1e-14)\n>>> info\n0",
  "mb03ka": "Move diagonal blocks in generalized periodic Schur form.\n\nReorders diagonal blocks of formal matrix product T22_K^S(K) * ... * T22_1^S(1)\nby moving the block at row index IFST to row index ILST.\n\nParameters:\n  compq (str): 'N'=no Q, 'U'=update Q, 'W'=selective via WHICHQ\n  whichq (ndarray): Array(K) specifying Q_k computation when COMPQ='W' (int32)\n  ws (bool): If True, perform strong stability tests\n  k (int): Period of sequences (K >= 2)\n  nc (int): Number of core eigenvalues\n  kschur (int): Index where T22_kschur is upper quasi-triangular (1-based)\n  ifst (int): Starting row index of block to move (1-based)\n  ilst (int): Target row index for block (1-based)\n  n (ndarray): Array(K) of matrix dimensions (int32)\n  ni (ndarray): Array(K) of T11_k dimensions (int32)\n  s (ndarray): Array(K) of signatures +1 or -1 (int32)\n  t (ndarray): Flattened array containing K matrices T_k at positions IXT(k)\n  ldt (ndarray): Array(K) of leading dimensions for T_k (int32)\n  ixt (ndarray): Array(K) of 1-based start indices for T_k in t (int32)\n  q (ndarray): Flattened array containing K matrices Q_k at positions IXQ(k)\n  ldq (ndarray): Array(K) of leading dimensions for Q_k (int32)\n  ixq (ndarray): Array(K) of 1-based start indices for Q_k in q (int32)\n  tol (ndarray): Array(3) [c, EPS, SMLNUM] tolerance parameters\n  ldwork (int, optional): Workspace size. -1 for query.\n\nReturns:\n  (t, q, ifst, ilst, info): Updated T matrices, updated Q matrices, final IFST, final ILST, exit code\n  info=0: success, info=1: reordering failed, info=-21: workspace too small\n\nExamples:\n\n>>> from slicot import mb03ka\n>>> import numpy as np\n>>> k = 2\n>>> nc = 3\n>>> kschur = 1\n>>> ifst = 1\n>>> ilst = 3\n>>> n = np.array([nc, nc], dtype=np.int32)\n>>> ni = np.array([0, 0], dtype=np.int32)\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> t1 = np.array([\n...     [2.0, 0.5, 0.3],\n...     [0.0, 3.0, 0.4],\n...     [0.0, 0.0, 4.0]\n...     ], dtype=np.float64, order='F')\n>>> t2 = np.array([\n...     [1.5, 0.2, 0.1],\n...     [0.0, 2.5, 0.3],\n...     [0.0, 0.0, 3.5]\n...     ], dtype=np.float64, order='F')\n>>> t = np.concatenate([t1.ravel('F'), t2.ravel('F')])\n>>> ldt = np.array([nc, nc], dtype=np.int32)\n>>> ixt = np.array([1, nc*nc + 1], dtype=np.int32)\n>>> q = np.eye(nc, dtype=np.float64, order='F').ravel('F')\n>>> q = np.concatenate([q, np.eye(nc, dtype=np.float64, order='F').ravel('F')])\n>>> ldq = np.array([nc, nc], dtype=np.int32)\n>>> ixq = np.array([1, nc*nc + 1], dtype=np.int32)\n>>> whichq = np.array([1, 1], dtype=np.int32)\n>>> eps = np.finfo(np.float64).eps\n>>> smlnum = np.finfo(np.float64).tiny / eps\n>>> tol = np.array([10.0, eps, smlnum], dtype=np.float64)\n>>> t_out, q_out, ifst_out, ilst_out, info = mb03ka(\n...     'U', whichq, False, k, nc, kschur, ifst, ilst,\n...     n, ni, s, t.copy(), ldt, ixt, q.copy(), ldq, ixq, tol\n...     )\n>>> info\n0",
  "mb03kb": "Swap pairs of adjacent diagonal blocks in generalized periodic Schur form.\n\nReorders diagonal blocks of formal matrix product T22_K^S(K) * ... * T22_1^S(1)\nby swapping pairs of adjacent diagonal blocks of sizes 1 and/or 2.\n\nParameters:\n  compq (str): 'N'=no Q, 'U'=update Q, 'W'=selective via WHICHQ\n  whichq (ndarray): Array(K) specifying Q_k computation when COMPQ='W' (int32)\n  ws (bool): If True, perform strong stability tests\n  k (int): Period of sequences (K >= 2)\n  nc (int): Number of core eigenvalues\n  kschur (int): Index where T22_kschur is upper quasi-triangular (1-based)\n  j1 (int): First row/column of first block to swap (1-based)\n  n1 (int): Order of first block (0, 1, or 2)\n  n2 (int): Order of second block (0, 1, or 2)\n  n (ndarray): Array(K) of matrix dimensions (int32)\n  ni (ndarray): Array(K) of T11_k dimensions (int32)\n  s (ndarray): Array(K) of signatures +1 or -1 (int32)\n  t (ndarray): Flattened array containing K matrices T_k at positions IXT(k)\n  ldt (ndarray): Array(K) of leading dimensions for T_k (int32)\n  ixt (ndarray): Array(K) of 1-based start indices for T_k in t (int32)\n  q (ndarray): Flattened array containing K matrices Q_k at positions IXQ(k)\n  ldq (ndarray): Array(K) of leading dimensions for Q_k (int32)\n  ixq (ndarray): Array(K) of 1-based start indices for Q_k in q (int32)\n  tol (ndarray): Array(3) [c, EPS, SMLNUM] tolerance parameters\n  ldwork (int, optional): Workspace size. -1 for query.\n\nReturns:\n  (t, q, info): Updated T matrices, updated Q matrices, exit code\n  info=0: success, info=1: swap rejected, info=-22: workspace too small\n\nExamples:\n\n>>> from slicot import mb03kb\n>>> import numpy as np\n>>> k = 2\n>>> nc = 3\n>>> kschur = 1\n>>> j1 = 1\n>>> n1 = 1\n>>> n2 = 1\n>>> n = np.array([nc, nc], dtype=np.int32)\n>>> ni = np.array([0, 0], dtype=np.int32)\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> t1 = np.array([\n...     [2.0, 0.5, 0.3],\n...     [0.0, 3.0, 0.4],\n...     [0.0, 0.0, 4.0]\n...     ], dtype=np.float64, order='F')\n>>> t2 = np.array([\n...     [1.5, 0.2, 0.1],\n...     [0.0, 2.5, 0.3],\n...     [0.0, 0.0, 3.5]\n...     ], dtype=np.float64, order='F')\n>>> t = np.concatenate([t1.ravel('F'), t2.ravel('F')])\n>>> ldt = np.array([nc, nc], dtype=np.int32)\n>>> ixt = np.array([1, nc*nc + 1], dtype=np.int32)\n>>> q = np.eye(nc, dtype=np.float64, order='F').ravel('F')\n>>> q = np.concatenate([q, np.eye(nc, dtype=np.float64, order='F').ravel('F')])\n>>> ldq = np.array([nc, nc], dtype=np.int32)\n>>> ixq = np.array([1, nc*nc + 1], dtype=np.int32)\n>>> whichq = np.array([1, 1], dtype=np.int32)\n>>> eps = np.finfo(np.float64).eps\n>>> smlnum = np.finfo(np.float64).tiny / eps\n>>> tol = np.array([10.0, eps, smlnum], dtype=np.float64)\n>>> t_out, q_out, info = mb03kb(\n...     'U', whichq, False, k, nc, kschur, j1, n1, n2,\n...     n, ni, s, t.copy(), ldt, ixt, q.copy(), ldq, ixq, tol\n...     )\n>>> info\n0",
  "mb03kc": "Reduce 2x2 formal matrix product to periodic Hessenberg-triangular form.\n\nReduces a 2-by-2 general, formal matrix product A of length K,\n  A_K^s(K) * A_{K-1}^s(K-1) * ... * A_1^s(1),\nto periodic Hessenberg-triangular form using K-periodic sequence of\nelementary reflectors (Householder matrices).\n\nEach reflector H_k = I - tau_k * v_k * v_k' is constructed such that\nall T_k are upper triangular except T_{khess} which is full.\n\nParameters:\n  k (int): Number of matrices in sequence (k >= 2)\n  khess (int): Index for Hessenberg matrix (1 <= khess <= k)\n  n (int): Order of extended matrices (n = 3 or n = 4)\n  r (int): Starting row/column for 2x2 submatrices (r = 1 or r = n-1)\n  s (ndarray): Signature array of length k (+1 or -1 each, int32)\n  a (ndarray): Array of k N-by-N matrices (N x N x K, F-order)\n  lda (int): Leading dimension of matrices (lda >= n)\n\nReturns:\n  (v, tau, a):\n    - v (ndarray): Array of length 2*k containing K 2-vectors v_k\n    - tau (ndarray): Array of length k containing tau_k values\n    - a (ndarray): Transformed matrices Te_k (N x N x K, F-order)\n\nExamples:\n\n>>> from slicot import mb03kc\n>>> import numpy as np\n>>> k = 2\n>>> khess = 1\n>>> n = 3\n>>> r = 1\n>>> lda = n\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> a = np.random.randn(n, n, k).astype(np.float64, order='F')\n>>> v, tau, a_out = mb03kc(k, khess, n, r, s, a, lda)\n...     a_block = a_out[r-1:r+1, r-1:r+1, i]",
  "mb03kd": "Reorder diagonal blocks in generalized periodic Schur form.\n\nReorders the diagonal blocks of a formal matrix product\nT22_K^S(K) * T22_K-1^S(K-1) * ... * T22_1^S(1) of length K,\nsuch that the M selected eigenvalues end up in the leading part.\n\nParameters:\n  compq (str): 'N'=no Q, 'I'=identity Q, 'U'=update Q\n  strong (str): 'N'=no strong tests, 'S'=strong stability tests\n  k (int): Period of matrix sequences (K >= 2)\n  nc (int): Number of core eigenvalues\n  kschur (int): Index for quasi-triangular factor (1 <= KSCHUR <= K)\n  n (ndarray): Dimensions array (K,) int32\n  ni (ndarray): T11 dimensions array (K,) int32\n  s (ndarray): Signatures array (K,) int32 (+1 or -1)\n  select (ndarray): Eigenvalue selection (NC,) bool\n  t (ndarray): Packed T matrices (F-order)\n  ldt (ndarray): Leading dimensions (K,) int32\n  ixt (ndarray): Start indices in t, 1-based (K,) int32\n  ldq (ndarray): Q leading dimensions (K,) int32\n  ixq (ndarray): Start indices in q, 1-based (K,) int32\n  tol (float): Tolerance (>= 10)\n  q (ndarray, optional): Packed Q matrices (F-order)\n\nReturns:\n  (t, q, m, info):\n    t: Reordered T matrices\n    q: Orthogonal transformation matrices\n    m: Number of selected eigenvalues reordered\n    info: 0=success, <0=param error, 1=reordering failed\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03kd\n>>> k = 3\n>>> n = 3\n>>> nc = n\n>>> kschur = 2\n>>> nd = np.array([n, n, n], dtype=np.int32)\n>>> ni = np.array([0, 0, 0], dtype=np.int32)\n>>> s = np.array([1, -1, 1], dtype=np.int32)\n>>> t1 = np.array([\n...     [1.8451, 0.0, 0.0],\n...     [0.9260, 1.3976, 0.0],\n...     [1.2717, -2.3544, -3.1023]\n...     ], dtype=np.float64, order='F')\n>>> t2 = np.array([\n...     [-2.0990, 0.0, 0.0],\n...     [-1.0831, 3.4838, 3.4552],\n...     [-2.5601, 0.2950, -2.1690]\n...     ], dtype=np.float64, order='F')\n>>> t3 = np.array([\n...     [2.5997, 0.0, 0.0],\n...     [-0.0087, 1.9846, 0.0],\n...     [1.6898, 0.1942, 2.3259]\n...     ], dtype=np.float64, order='F')\n>>> t_size = n * n * k\n>>> t = np.zeros(t_size, dtype=np.float64, order='F')\n>>> t[:n*n] = t1.ravel('F')\n>>> t[n*n:2*n*n] = t2.ravel('F')\n>>> t[2*n*n:] = t3.ravel('F')\n>>> ldt = np.array([n, n, n], dtype=np.int32)\n>>> ixt = np.array([1, n*n + 1, 2*n*n + 1], dtype=np.int32)\n>>> ldq = np.array([n, n, n], dtype=np.int32)\n>>> ixq = np.array([1, n*n + 1, 2*n*n + 1], dtype=np.int32)\n>>> select = np.array([False, False, True], dtype=np.bool_)\n>>> tol = 100.0\n>>> t_out, q_out, m, info = mb03kd(\n...     'I', 'N', k, nc, kschur, nd, ni, s, select,\n...     t.copy(), ldt, ixt, ldq, ixq, tol\n...     )\n>>> info\n0",
  "mb03ke": "Solve small periodic Sylvester-like equations.\n\nSolves periodic Sylvester-like equations (PSLE):\n  op(A(i))*X(i)   + isgn*X(i+1)*op(B(i)) = -scale*C(i), S(i) =  1\n  op(A(i))*X(i+1) + isgn*X(i)  *op(B(i)) = -scale*C(i), S(i) = -1\n\nfor i = 1, ..., K, where op(A) means A or A**T, for the K-periodic\nmatrix sequence X(i) = X(i+K). A(i) are M-by-M and B(i) are N-by-N,\nwith 1 <= M, N <= 2.\n\nParameters:\n  trana (bool): If True, op(A) = A**T; otherwise op(A) = A\n  tranb (bool): If True, op(B) = B**T; otherwise op(B) = B\n  isgn (int): Sign variant: 1 or -1\n  k (int): Period of sequences (k >= 2)\n  m (int): Order of A matrices (1 <= m <= 2)\n  n (int): Order of B matrices (1 <= n <= 2)\n  s (ndarray): Array of K signatures (+1 or -1 each, int32)\n  a (ndarray): Array of K M-by-M matrices (length M*M*K)\n  b (ndarray): Array of K N-by-N matrices (length N*N*K)\n  c (ndarray): Array of K M-by-N matrices C(i) (length M*N*K)\n  ldwork (int, optional): Workspace size. -1 for query.\n\nReturns:\n  (x, scale, info):\n    - x (ndarray): Solution sequence X(i) (length M*N*K)\n    - scale (float): Scale factor (<= 1) to avoid overflow\n    - info (int): 0=success, -21=ldwork too small, 1=scaled\n\nExamples:\n\n>>> from slicot import mb03ke\n>>> import numpy as np\n>>> k, m, n = 2, 1, 1\n>>> trana, tranb = False, False\n>>> isgn = 1\n>>> a = np.array([2.0, 3.0], dtype=float, order='F')\n>>> b = np.array([1.5, 0.5], dtype=float, order='F')\n>>> c = np.array([1.0, 2.0], dtype=float, order='F')\n>>> s = np.array([1, 1], dtype=np.int32)\n>>> x, scale, info = mb03ke(trana, tranb, isgn, k, m, n, s, a, b, c)\n...     i_next = (i + 1) % k\n...     lhs = a[i] * x[i] + isgn * x[i_next] * b[i]\n...     else:\n...     lhs = a[i] * x[i_next] + isgn * x[i] * b[i]\n>>> info\n0",
  "mb03ld": "Eigenvalues and right deflating subspace of real skew-Hamiltonian/Hamiltonian pencil.\n\nComputes eigenvalues of aS - bH with S = [[A,D],[E,A']] (D,E skew-symmetric)\nand H = [[B,F],[G,-B']] (F,G symmetric). Optionally computes orthonormal\nbasis of right deflating subspace for eigenvalues with negative real part.\n\nParameters:\n  compq (str): 'N'=eigenvalues only, 'C'=compute deflating subspace\n  orth (str): 'P'=QR with pivoting, 'S'=SVD (only if compq='C')\n  n (int): Order of pencil (n >= 0, must be even)\n  a (ndarray): N/2-by-N/2 matrix A\n  de (ndarray): N/2-by-(N/2+1) packed D and E matrices\n  b (ndarray): N/2-by-N/2 matrix B\n  fg (ndarray): N/2-by-(N/2+1) packed F and G matrices\n\nReturns:\n  (a, de, b, fg, neig, q, alphar, alphai, beta, info):\n    a, de, b, fg: Modified matrices\n    neig: Number of eigenvalues with negative real part\n    q: N-by-NEIG deflating subspace (if compq='C' and neig>0)\n    alphar, alphai, beta: Eigenvalue components (lambda=alpha/beta)\n    info: 0=success, 1=MB04BD/HD QZ failed, 2=MB04HD/MB03DD failed, 3=singular, 4=SVD failed, 5=eigenvalues may be inaccurate\n\nExamples:\n\n>>> from slicot import mb03ld\n>>> import numpy as np\n>>> n = 8\n>>> m = n // 2\n>>> a = np.array([\n...     [3.1472, 1.3236, 4.5751, 4.5717],\n...     [4.0579, -4.0246, 4.6489, -0.1462],\n...     [-3.7301, -2.2150, -3.4239, 3.0028],\n...     [4.1338, 0.4688, 4.7059, -3.5811]\n...     ], order='F', dtype=float)\n>>> de = np.array([\n...     [0.0000, 0.0000, -1.5510, -4.5974, -2.5127],\n...     [3.5071, 0.0000, 0.0000, 1.5961, 2.4490],\n...     [-3.1428, 2.5648, 0.0000, 0.0000, -0.0596],\n...     [3.0340, 2.4892, -1.1604, 0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.6882, -3.3782, -3.3435, 1.8921],\n...     [-0.3061, 2.9428, 1.0198, 2.4815],\n...     [-4.8810, -1.8878, -2.3703, -0.4946],\n...     [-1.6288, 0.2853, 1.5408, -4.1618]\n...     ], order='F', dtype=float)\n>>> fg = np.array([\n...     [-2.4013, -2.7102, 0.3834, -3.9335, 3.1730],\n...     [-3.1815, -2.3620, 4.9613, 4.6190, 3.6869],\n...     [3.6929, 0.7970, 0.4986, -4.9537, -4.1556],\n...     [3.5303, 1.2206, -1.4905, 0.1325, -1.0022]\n...     ], order='F', dtype=float)\n>>> a_out, de_out, b_out, fg_out, neig, q, alphar, alphai, beta, info = mb03ld(\n...     'C', 'P', n, a, de, b, fg\n...     )\n>>> q_sub = q[:n, :neig]\n>>> qtq = q_sub.T @ q_sub\n>>> info\n0",
  "mb03lf": "Eigenvalues and deflating subspace of skew-Hamiltonian/Hamiltonian pencil in factored form.\n\nComputes eigenvalues of aS - bH with S = J*Z'*J'*Z (factored) and H = [[B,F],[G,-B']].\nOptionally computes orthogonal basis of right deflating subspace (compq='C') and\ncompanion subspace (compu='C') for eigenvalues with strictly negative real part.\n\nParameters:\n  compq (str): 'N'=no deflating subspace, 'C'=compute and store in Q\n  compu (str): 'N'=no companion subspace, 'C'=compute and store in U\n  orth (str): 'P'=QR with pivoting, 'S'=SVD (only if compq='C' or compu='C')\n  z (ndarray): N-by-N factor Z in S = J*Z'*J'*Z\n  b (ndarray): N/2-by-N/2 matrix B\n  fg (ndarray): N/2-by-(N/2+1) packed G (lower tri) and F (upper tri cols 2:N/2+1)\n  n (int, optional): Order of pencil (derived from z if not given)\n\nReturns:\n  (z_out, neig, q, u, alphar, alphai, beta, iwarn, info):\n    z_out: Transformed upper triangular matrix Z11\n    neig: Number of eigenvalues with negative real part\n    q: N-by-NEIG deflating subspace (if compq='C')\n    u: N-by-NEIG companion subspace (if compu='C')\n    alphar, alphai, beta: Eigenvalue components (lambda=alpha/beta)\n    iwarn: 0=ok, 1=some eigenvalues may be unreliable\n    info: 0=success, 1=QZ failed, 2=QZ iteration failed, 3=singular, 4=SVD failed\n\nExamples:\n\n>>> from slicot import mb03lf\n>>> import numpy as np\n>>> n = 8\n>>> m = n // 2\n>>> z = np.array([\n...     [3.1472, 4.5751, -0.7824, 1.7874, -2.2308, -0.6126, 2.0936, 4.5974],\n...     [4.0579, 4.6489, 4.1574, 2.5774, -4.5383, -1.1844, 2.5469, -1.5961],\n...     [-3.7301, -3.4239, 2.9221, 2.4313, -4.0287, 2.6552, -2.2397, 0.8527],\n...     [4.1338, 4.7059, 4.5949, -1.0777, 3.2346, 2.9520, 1.7970, -2.7619],\n...     [1.3236, 4.5717, 1.5574, 1.5548, 1.9483, -3.1313, 1.5510, 2.5127],\n...     [-4.0246, -0.1462, -4.6429, -3.2881, -1.8290, -0.1024, -3.3739, -2.4490],\n...     [-2.2150, 3.0028, 3.4913, 2.0605, 4.5022, -0.5441, -3.8100, 0.0596],\n...     [0.4688, -3.5811, 4.3399, -4.6817, -4.6555, 1.4631, -0.0164, 1.9908]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.6882, -3.3782, -3.3435, 1.8921],\n...     [-0.3061, 2.9428, 1.0198, 2.4815],\n...     [-4.8810, -1.8878, -2.3703, -0.4946],\n...     [-1.6288, 0.2853, 1.5408, -4.1618]\n...     ], order='F', dtype=float)\n>>> fg = np.array([\n...     [-2.4013, -2.7102, 0.3834, -3.9335, 3.1730],\n...     [-3.1815, -2.3620, 4.9613, 4.6190, 3.6869],\n...     [3.6929, 0.7970, 0.4986, -4.9537, -4.1556],\n...     [3.5303, 1.2206, -1.4905, 0.1325, -1.0022]\n...     ], order='F', dtype=float)\n>>> z_out, neig, q, u, alphar, alphai, beta, iwarn, info = mb03lf(\n...     'C', 'C', 'P', z, b, fg\n...     )\n>>> info\n0",
  "mb03lp": "Eigenvalues and right deflating subspace of real skew-Hamiltonian/Hamiltonian pencil (panel-based).\n\nSame as MB03LD but applies transformations on panels of columns for better\nperformance on large matrices. Uses MB04BP instead of MB04BD internally.\n\nComputes eigenvalues of aS - bH with S = [[A,D],[E,A']] (D,E skew-symmetric)\nand H = [[B,F],[G,-B']] (F,G symmetric). Optionally computes orthonormal\nbasis of right deflating subspace for eigenvalues with negative real part.\n\nParameters:\n  compq (str): 'N'=eigenvalues only, 'C'=compute deflating subspace\n  orth (str): 'P'=QR with pivoting, 'S'=SVD (only if compq='C')\n  a (ndarray): N/2-by-N/2 matrix A\n  de (ndarray): N/2-by-(N/2+1) packed D and E matrices\n  b (ndarray): N/2-by-N/2 matrix B\n  fg (ndarray): N/2-by-(N/2+1) packed F and G matrices\n\nReturns:\n  (a, de, b, fg, neig, q, alphar, alphai, beta, info):\n    a, de, b, fg: Modified matrices\n    neig: Number of eigenvalues with negative real part\n    q: 2N-by-NEIG deflating subspace (if compq='C' and neig>0), or None\n    alphar, alphai, beta: Eigenvalue components (lambda=alpha/beta)\n    info: 0=success, 1=MB04BP/HD QZ failed, 2=MB04HD/MB03DD failed, 3=singular, 4=SVD failed, 5=eigenvalues may be inaccurate\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03lp\n>>> n = 8\n>>> m = n // 2\n>>> a = np.array([\n...     [3.1472, 1.3236, 4.5751, 4.5717],\n...     [4.0579, -4.0246, 4.6489, -0.1462],\n...     [-3.7301, -2.2150, -3.4239, 3.0028],\n...     [4.1338, 0.4688, 4.7059, -3.5811]\n...     ], dtype=float, order='F')\n>>> de = np.array([\n...     [0.0000, 0.0000, -1.5510, -4.5974, -2.5127],\n...     [3.5071, 0.0000, 0.0000, 1.5961, 2.4490],\n...     [-3.1428, 2.5648, 0.0000, 0.0000, -0.0596],\n...     [3.0340, 2.4892, -1.1604, 0.0000, 0.0000]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [0.6882, -3.3782, -3.3435, 1.8921],\n...     [-0.3061, 2.9428, 1.0198, 2.4815],\n...     [-4.8810, -1.8878, -2.3703, -0.4946],\n...     [-1.6288, 0.2853, 1.5408, -4.1618]\n...     ], dtype=float, order='F')\n>>> fg = np.array([\n...     [-2.4013, -2.7102, 0.3834, -3.9335, 3.1730],\n...     [-3.1815, -2.3620, 4.9613, 4.6190, 3.6869],\n...     [3.6929, 0.7970, 0.4986, -4.9537, -4.1556],\n...     [3.5303, 1.2206, -1.4905, 0.1325, -1.0022]\n...     ], dtype=float, order='F')\n>>> result = mb03lp('C', 'P', a, de, b, fg)\n>>> a_out, de_out, b_out, fg_out, neig, q, alphar, alphai, beta, info = result",
  "mb03lz": "Eigenvalues and right deflating subspace of complex skew-Hamiltonian/Hamiltonian pencil.\n\nComputes eigenvalues of aS - bH with S = [[A,D],[E,A']] (D,E skew-Hermitian)\nand H = [[B,F],[G,-B']] (F,G Hermitian). Optionally computes orthonormal\nbasis of right deflating subspace for eigenvalues with negative real part.\n\nParameters:\n  compq (str): 'N'=eigenvalues only, 'C'=compute deflating subspace\n  orth (str): 'P'=QR with pivoting, 'S'=SVD (only if compq='C')\n  n (int): Order of pencil (n >= 0, must be even)\n  a (ndarray): N/2-by-N/2 complex matrix A\n  de (ndarray): N/2-by-(N/2+1) packed D and E matrices\n  b (ndarray): N/2-by-N/2 complex matrix B\n  fg (ndarray): N/2-by-(N/2+1) packed F and G matrices\n\nReturns:\n  (a, de, b, fg, q, alphar, alphai, beta, neig, info):\n    a, de, b, fg: Modified matrices (if compq='C')\n    q: N-by-NEIG deflating subspace (if compq='C' and neig>0)\n    alphar, alphai, beta: Eigenvalue components (lambda=alpha/beta)\n    neig: Number of eigenvalues with negative real part\n    info: 0=success, 1=MB04FD failed, 2=ZHGEQZ failed, 3=SVD failed, 4=singular\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03lz\n>>> n = 4\n>>> m = n // 2\n>>> a = np.array([\n...     [0.0604 + 0.6568j, 0.5268 + 0.2919j],\n...     [0.3992 + 0.6279j, 0.4167 + 0.4316j]\n...     ], dtype=np.complex128, order='F')\n>>> de = np.array([\n...     [0.0 + 0.4896j, 0.0 + 0.9516j, 0.3724 + 0.0526j],\n...     [0.9840 + 0.3394j, 0.0 + 0.9203j, 0.0 + 0.7378j]\n...     ], dtype=np.complex128, order='F')\n>>> b = np.array([\n...     [0.2691 + 0.4177j, 0.5478 + 0.3014j],\n...     [0.4228 + 0.9830j, 0.9427 + 0.7010j]\n...     ], dtype=np.complex128, order='F')\n>>> fg = np.array([\n...     [0.6663 + 0.0j, 0.6981 + 0.0j, 0.1781 + 0.8818j],\n...     [0.5391 + 0.1711j, 0.6665 + 0.0j, 0.1280 + 0.0j]\n...     ], dtype=np.complex128, order='F')\n>>> result = mb03lz('C', 'P', n, a, de, b, fg)\n>>> a_out, de_out, b_out, fg_out, q, alphar, alphai, beta, neig, info = result\n>>> actual_eig = (alphar + 1j * alphai) / beta\n>>> q_sub = q[:, :neig]\n>>> qtq = np.conj(q_sub.T) @ q_sub",
  "mb03md": "Compute upper bound for L singular values of bidiagonal matrix.\n\nComputes an upper bound THETA using bisection such that the bidiagonal\nmatrix J has precisely L singular values <= THETA + TOL.\n\nParameters:\n  n (int): Order of bidiagonal matrix J (n >= 0)\n  l (int): Number of singular values <= bound (0 <= l <= n)\n  theta (float): Initial estimate (negative for default)\n  q (ndarray): Diagonal elements (n,)\n  e (ndarray): Superdiagonal elements (n-1,)\n  q2 (ndarray): Squared diagonal elements (n,)\n  e2 (ndarray): Squared superdiagonal elements (n-1,)\n  pivmin (float): Minimum pivot value\n  tol (float): Tolerance for singular value coincidence\n  reltol (float): Relative tolerance for bisection\n\nReturns:\n  (theta, l, iwarn, info):\n    - theta (float): Computed upper bound\n    - l (int): May be increased if multiplicity > 1\n    - iwarn (int): 0=ok, 1=L increased due to coinciding singular values\n    - info (int): 0=success, <0=parameter error\n\nExamples:\n\n>>> from slicot import mb03md\n>>> import numpy as np\n>>> pass\n>>> n = 5\n>>> l_in = 3\n>>> theta_in = -3.0  # negative means use default estimate\n>>> tol = 0.0\n>>> reltol = 0.0  # will use default\n>>> q = np.array([1.0, 2.0, 3.0, 4.0, 5.0], dtype=float)\n>>> e = np.array([2.0, 3.0, 4.0, 5.0], dtype=float)\n>>> q2, e2, pivmin = compute_pivmin_and_squares(q, e)\n>>> theta_out, l_out, iwarn, info = mb03md(\n...     n, l_in, theta_in, q, e, q2, e2, pivmin, tol, reltol\n...     )\n>>> info\n0",
  "mb03od": "Incremental rank estimation for QR factorization.\n\nParameters:\n  m (int): Number of rows\n  n (int): Number of columns\n  a (ndarray): Matrix array (column-major, shape (m,n))\n  rcond (float): Rank threshold\n  svlmax (float): Parent matrix singular value estimate\n  jobqr (str, optional): 'Q' = perform QR (default), 'N' = use existing\n\nReturns:\n  (jpvt, rank, sval, info): Pivot indices, rank, singular values, exit code\n\nExamples:\n\n>>> from slicot import mb03od\n>>> import numpy as np\n>>> m, n = 6, 5\n>>> a = np.array([\n...     [ 1.,  2.,  6.,  3.,  5.],\n...     [-2., -1., -1.,  0., -2.],\n...     [ 5.,  5.,  1.,  5.,  1.],\n...     [-2., -1., -1.,  0., -2.],\n...     [ 4.,  8.,  4., 20.,  4.],\n...     [-2., -1., -1.,  0., -2.]\n...     ], dtype=float, order='F')\n>>> rcond = 5e-16\n>>> svlmax = 0.0\n>>> expected_rank = 4\n>>> expected_jpvt = np.array([4, 3, 1, 5, 2], dtype=np.int32)\n>>> expected_sval = np.array([22.7257, 1.4330, 0.0])\n>>> jpvt, rank, sval, info = mb03od(m, n, a, rcond, svlmax, jobqr='Q')\n>>> info\n0",
  "mb03oy": "Matrix rank determination by incremental condition estimation.\n\nParameters:\n  m (int): Number of rows\n  n (int): Number of columns\n  a (ndarray): Matrix array (column-major, shape (m,n))\n  rcond (float): Threshold for rank determination\n  svlmax (float): Estimate of largest singular value\n\nReturns:\n  (a, rank, info, sval, jpvt, tau): QR factorization results\n\nExamples:\n\n>>> from slicot import mb03oy\n>>> import numpy as np\n>>> m, n = 6, 4\n>>> rcond = 1.0e-10\n>>> svlmax = 0.0\n>>> U = np.linalg.qr(np.random.randn(m, m))[0]  # Orthogonal m x m\n>>> V = np.linalg.qr(np.random.randn(n, n))[0]  # Orthogonal n x n\n>>> sigma = np.array([10.0, 5.0, 2.0, 1e-14])\n>>> Sigma = np.zeros((m, n))\n...     Sigma[i, i] = sigma[i]\n>>> a = U @ Sigma @ V.T\n>>> a = np.asfortranarray(a)\n>>> true_rank = np.linalg.matrix_rank(a, tol=rcond * sigma[0])\n>>> a_result, rank, info, sval, jpvt, tau = mb03oy(m, n, a.copy(), rcond, svlmax)\n>>> cond_estimate = sval[0] / sval[1]\n>>> true_svd = np.linalg.svd(a, compute_uv=False)\n>>> info\n0",
  "mb03pd": "Rank-revealing RQ factorization with row pivoting.\n\nComputes (optionally) a rank-revealing RQ factorization P*A = R*Q with\nrow pivoting, determining effective rank via incremental condition estimation.\n\nParameters:\n  jobrq (str): 'R' = perform RQ factorization, 'N' = use existing\n  m (int): Number of rows (>= 0)\n  n (int): Number of columns (>= 0)\n  a (ndarray): Input matrix (m x n, F-order)\n  rcond (float): Reciprocal condition threshold (>= 0)\n  svlmax (float): Max singular value estimate (>= 0)\n\nReturns:\n  (a, rank, info, sval, jpvt, tau):\n    - a: RQ factorization result\n    - rank: Effective rank (order of R22)\n    - info: Exit code (0 = success, <0 = param error)\n    - sval: Singular value estimates (3 values)\n    - jpvt: Row pivot indices (1-based)\n    - tau: Elementary reflector factors\n\nExamples:\n\n>>> from slicot import mb03pd\n>>> import numpy as np\n>>> m, n = 6, 5\n>>> a = np.array([\n...     [1., 2., 6., 3., 5.],\n...     [-2., -1., -1., 0., -2.],\n...     [5., 5., 1., 5., 1.],\n...     [-2., -1., -1., 0., -2.],\n...     [4., 8., 4., 20., 4.],\n...     [-2., -1., -1., 0., -2.]\n...     ], dtype=float, order='F')\n>>> rcond = 5e-16\n>>> svlmax = 0.0\n>>> a_out, rank, info, sval, jpvt, tau = mb03pd('R', m, n, a.copy(order='F'), rcond, svlmax)\n>>> expected_jpvt = np.array([2, 4, 6, 3, 1, 5], dtype=np.int32)\n>>> expected_sval = np.array([24.5744, 0.9580, 0.0000])\n>>> info\n0",
  "mb03py": "Rank-revealing RQ factorization with row pivoting.\n\nComputes truncated RQ factorization P*A = R*Q with row pivoting,\ndetermining effective rank via incremental condition estimation.\n\nParameters:\n  m (int): Number of rows (>= 0)\n  n (int): Number of columns (>= 0)\n  a (ndarray): Input matrix (m x n, F-order)\n  rcond (float): Reciprocal condition threshold (0 <= rcond <= 1)\n  svlmax (float): Max singular value estimate (>= 0)\n\nReturns:\n  (a, rank, info, sval, jpvt, tau):\n    - a: RQ factorization result\n    - rank: Effective rank\n    - info: Exit code (0 = success)\n    - sval: Singular value estimates (3 values)\n    - jpvt: Row pivot indices (1-based)\n    - tau: Elementary reflector factors\n\nExamples:\n\n>>> from slicot import mb03py\n>>> import numpy as np\n>>> m, n = 4, 4\n>>> a = np.random.randn(m, n).astype(float, order='F')\n>>> rcond = 1e-10\n>>> svlmax = 0.0\n>>> a_out, rank, info, sval, jpvt, tau = mb03py(m, n, a.copy(order='F'), rcond, svlmax)\n>>> info\n0",
  "mb03qd": "Reorder eigenvalues in quasi-triangular matrix.\n\nParameters:\n  dico (str): 'C' for continuous, 'D' for discrete\n  stdom (str): 'S' for stable, 'U' for unstable\n  jobu (str): 'I' to initialize U, 'U' to update U\n  a (ndarray): Quasi-triangular matrix (n x n, F-order)\n  nlow (int): Lowest block index (1-based)\n  nsup (int): Highest block index (1-based)\n  alpha (float): Stability boundary\n\nReturns:\n  (a, u, ndim, info): Reordered A, updated U, invariant subspace dim, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03qd\n>>> a = np.array([\n...     [ 1.0,  0.5,  0.2,  0.1],\n...     [ 0.0,  2.0,  0.3,  0.2],\n...     [ 0.0,  0.0, -1.0,  0.4],\n...     [ 0.0,  0.0,  0.0, -2.0]\n...     ], order='F', dtype=float)\n>>> n = 4\n>>> nlow = 1\n>>> nsup = 4\n>>> alpha = 0.0  # Boundary: Re(lambda) < 0 is stable\n>>> a_out, u, ndim, info = mb03qd('C', 'S', 'I', a.copy(order='F'), nlow, nsup, alpha)\n>>> eig_after = np.sort(np.linalg.eigvals(a_out).real)\n>>> info\n0",
  "mb03qg": "Reorder diagonal blocks of upper quasi-triangular matrix pencil.\n\nReorders the diagonal blocks of a principal subpencil of an upper\nquasi-triangular matrix pencil A-lambda*E together with their\ngeneralized eigenvalues, by constructing orthogonal similarity\ntransformations UT and VT.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  stdom (str): 'S' for stability domain, 'U' for instability domain\n  jobu (str): 'I' to initialize U to identity, 'U' to update given U\n  jobv (str): 'I' to initialize V to identity, 'U' to update given V\n  a (ndarray): N-by-N Schur form matrix (F-order, modified in place)\n  e (ndarray): N-by-N upper triangular matrix (F-order, modified in place)\n  nlow (int): Lower boundary index for subpencil (1-based)\n  nsup (int): Upper boundary index for subpencil (1-based)\n  alpha (float): Boundary of domain of interest (>=0 for DICO='D')\n  u (ndarray, optional): N-by-N transformation matrix (when jobu='U')\n  v (ndarray, optional): N-by-N transformation matrix (when jobv='U')\n\nReturns:\n  (a, e, u, v, ndim, info):\n    a (ndarray): Reordered Schur form matrix\n    e (ndarray): Reordered upper triangular matrix\n    u (ndarray): Accumulated transformation matrix UT\n    v (ndarray): Accumulated transformation matrix VT\n    ndim (int): Number of eigenvalues in domain of interest\n    info (int): 0=success, <0=param error, 1=block boundary error, 2=swap failed\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03qg\n>>> n = 4\n>>> nlow = 1\n>>> nsup = 4\n>>> alpha = 0.0\n>>> a_schur = np.array([\n...     [-1.4394,  2.5550, -12.5655, -4.0714],\n...     [ 2.8887, -1.1242,   9.2819, -2.6724],\n...     [ 0.0000,  0.0000, -19.7785, 36.4447],\n...     [ 0.0000,  0.0000,   0.0000,  3.5537]\n...     ], order='F', dtype=float)\n>>> e_schur = np.array([\n...     [-16.0178,  0.0000,  2.3850,  4.7645],\n...     [  0.0000,  3.2809, -1.5640,  1.9954],\n...     [  0.0000,  0.0000, -3.0652,  0.3039],\n...     [  0.0000,  0.0000,  0.0000,  1.1671]\n...     ], order='F', dtype=float)\n>>> a_out, e_out, u_out, v_out, ndim, info = mb03qg(\n...     'C', 'S', 'I', 'I', a_schur.copy(), e_schur.copy(), nlow, nsup, alpha\n...     )\n>>> info\n0",
  "mb03qv": "Compute eigenvalues of upper quasi-triangular matrix pencil.\n\nComputes generalized eigenvalues of (S, T) where S is upper\nquasi-triangular and T is upper triangular.\n\nParameters:\n  s (ndarray): Upper quasi-triangular matrix S (n x n, F-order)\n  t (ndarray): Upper triangular matrix T (n x n, F-order)\n\nReturns:\n  (alphar, alphai, beta, info):\n    alphar (ndarray): Real parts of eigenvalue numerators\n    alphai (ndarray): Imaginary parts of eigenvalue numerators\n    beta (ndarray): Eigenvalue denominators\n    info (int): 0 = success, <0 = -i means i-th argument invalid\n\nExamples:\n\n>>> from slicot import mb03qv\n>>> import numpy as np\n>>> n = 3\n>>> s = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 2.0, 0.0],\n...     [0.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> t = np.array([\n...     [2.0, 0.0, 0.0],\n...     [0.0, 3.0, 0.0],\n...     [0.0, 0.0, 4.0]\n...     ], order='F', dtype=float)\n>>> alphar, alphai, beta, info = mb03qv(s, t)\n>>> eigenvalues = alphar / beta\n>>> expected_eigenvalues = np.array([0.5, 2.0/3.0, 0.75])\n>>> info\n0",
  "mb03qw": "Reduce 2-by-2 diagonal block pair of quasi-triangular pencil.\n\nComputes eigenvalues of a selected 2-by-2 diagonal block pair of an upper\nquasi-triangular pencil, reduces it to standard form, and splits it if\neigenvalues are real.\n\nParameters:\n  n (int): Order of matrices A, E, U, V (n >= 2)\n  l (int): Position of the 2-by-2 block (1 <= l < n)\n  a (ndarray): Upper quasi-triangular matrix A (n x n, F-order)\n  e (ndarray): Upper triangular matrix E (n x n, F-order)\n  u (ndarray): Transformation matrix U (n x n, F-order)\n  v (ndarray): Transformation matrix V (n x n, F-order)\n\nReturns:\n  (a, e, u, v, alphar, alphai, beta, info):\n    a (ndarray): Transformed matrix A\n    e (ndarray): Transformed matrix E\n    u (ndarray): Updated transformation matrix U*UT\n    v (ndarray): Updated transformation matrix V*VT\n    alphar (ndarray): Real parts of eigenvalue numerators (2,)\n    alphai (ndarray): Imaginary parts of eigenvalue numerators (2,)\n    beta (ndarray): Eigenvalue denominators (2,)\n    info (int): 0 = success, <0 = -i means i-th argument invalid\n\nExamples:\n\n>>> from slicot import mb03qw\n>>> import numpy as np\n>>> n = 3\n>>> l = 1\n>>> a = np.array([\n...     [1.0, 2.0, 0.5],\n...     [3.0, 1.0, 0.3],\n...     [0.0, 0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [2.0, 1.0, 0.2],\n...     [0.0, 1.5, 0.1],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> u = np.eye(n, order='F', dtype=float)\n>>> v = np.eye(n, order='F', dtype=float)\n>>> a_out, e_out, u_out, v_out, alphar, alphai, beta, info = mb03qw(n, l, a, e, u, v)\n>>> eig1 = (alphar[0] + 1j * alphai[0]) / beta[0] if beta[0] != 0 else np.inf\n>>> eig2 = (alphar[1] + 1j * alphai[1]) / beta[1] if beta[1] != 0 else np.inf\n>>> info\n0",
  "mb03qx": "Compute eigenvalues of upper quasi-triangular matrix.\n\nExtracts eigenvalues from diagonal and 2x2 blocks of quasi-triangular matrix.\n\nParameters:\n  t (ndarray): Upper quasi-triangular matrix (n x n, F-order)\n\nReturns:\n  (wr, wi, info): Real parts, imaginary parts, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03qx\n>>> n = 4\n>>> t = np.array([\n...     [1.0, 0.5, 0.2, 0.1],\n...     [0.0, 2.0, 0.3, 0.2],\n...     [0.0, 0.0, 3.0, 0.4],\n...     [0.0, 0.0, 0.0, 4.0]\n...     ], order='F', dtype=float)\n>>> wr, wi, info = mb03qx(t)\n>>> expected_wr = np.array([1.0, 2.0, 3.0, 4.0])\n>>> expected_wi = np.zeros(4)\n>>> info\n0",
  "mb03qy": "Process 2x2 diagonal block of quasi-triangular matrix.\n\nComputes eigenvalues of a selected 2x2 diagonal block, reduces to\nstandard form, and splits in case of real eigenvalues.\n\nParameters:\n  n (int): Order of matrices A and U. N >= 2.\n  l (int): Position of block (1 <= L < N). 1-based.\n  a (ndarray): Upper quasi-triangular matrix (n x n, F-order)\n  u (ndarray): Transformation matrix (n x n, F-order)\n\nReturns:\n  (a, u, e1, e2, info): Transformed matrices, eigenvalue parts, exit code\n\nExamples:\n\n>>> from slicot import mb03qy\n>>> import numpy as np\n>>> n = 3\n>>> l = 1  # 1-based position\n>>> a = np.array([\n...     [2.0, 3.0, 1.5],\n...     [-1.0, 2.0, 0.5],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> u = np.eye(n, order='F', dtype=float)\n>>> a_out, u_out, e1, e2, info = mb03qy(n, l, a, u)\n>>> info\n0",
  "mb03rd": "Reduce real Schur form matrix to block-diagonal form.\n\nParameters:\n  jobx (str): 'N' no accumulation, 'U' accumulate transformations\n  sort (str): 'N'/'C'/'S'/'B' - sorting/clustering options\n  a (ndarray): Real Schur form matrix (n x n, F-order)\n  pmax (float): Max element bound for transformations (>= 1.0)\n  x (ndarray, optional): Transformation matrix (n x n, F-order)\n  tol (float, optional): Clustering tolerance\n\nReturns:\n  (a, x, nblcks, blsize, wr, wi, info): Block-diagonal A, transformation X,\n   number of blocks, block sizes, real/imag eigenvalues, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03rd\n>>> n = 4\n>>> pmax = 1.0e3\n>>> a = np.array([\n...     [1.0, 0.5, 0.2, 0.1],\n...     [0.0, 2.0, 0.3, 0.2],\n...     [0.0, 0.0, 3.0, 0.4],\n...     [0.0, 0.0, 0.0, 4.0]\n...     ], order='F', dtype=float)\n>>> x = np.eye(n, order='F', dtype=float)\n>>> a_out, x_out, nblcks, blsize, wr, wi, info = mb03rd('U', 'N', a, pmax, x)\n>>> total_size = 0\n...     total_size += blsize[i]\n>>> info\n0",
  "mb03rw": "Solve complex Sylvester equation -AX + XB = C.\n\nSolves the Sylvester equation -AX + XB = C where A (M-by-M) and B (N-by-N)\nare complex upper triangular matrices in Schur form. Aborts if any element\nof X exceeds PMAX in absolute value.\n\nParameters:\n  m (int): Order of A, number of rows of C and X (M >= 0)\n  n (int): Order of B, number of columns of C and X (N >= 0)\n  pmax (float): Upper bound for absolute value of X elements\n  a (ndarray): M-by-M complex upper triangular matrix A (F-order)\n  b (ndarray): N-by-N complex upper triangular matrix B (F-order)\n  c (ndarray): M-by-N RHS matrix C (F-order, modified in place)\n\nReturns:\n  (x, info):\n    x (ndarray): Solution matrix X (M-by-N, complex)\n    info (int): 0=success, 1=element of X exceeds PMAX, 2=perturbed values used\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03rw\n>>> m, n = 3, 3\n>>> a = np.array([\n...     [1.0 + 0.5j, 0.2 + 0.1j, 0.1 - 0.2j],\n...     [0.0 + 0.0j, 2.0 - 0.3j, 0.3 + 0.1j],\n...     [0.0 + 0.0j, 0.0 + 0.0j, 3.0 + 0.2j]\n...     ], dtype=np.complex128, order='F')\n>>> b = np.array([\n...     [4.0 + 0.1j, 0.1 + 0.2j, 0.2 - 0.1j],\n...     [0.0 + 0.0j, 5.0 - 0.2j, 0.1 + 0.3j],\n...     [0.0 + 0.0j, 0.0 + 0.0j, 6.0 + 0.4j]\n...     ], dtype=np.complex128, order='F')\n>>> pmax = 1e6\n>>> x, info = mb03rw(m, n, pmax, a, b, c)\n...     atol=1e-10, rtol=1e-10)\n>>> info\n0",
  "mb03rx": "Reorder diagonal blocks of a real Schur form matrix.\n\nMoves the diagonal block at position KU to position KL using\northogonal similarity transformations (LAPACK DTREXC).\n\nParameters:\n  jobv (str): 'N' no accumulation, 'V' accumulate in X\n  kl (int): Target position (1-based)\n  ku (int): Source position (1-based)\n  a (ndarray): Real Schur matrix (n x n, F-order)\n  x (ndarray): Transformation matrix (n x n, F-order)\n  wr (ndarray): Real parts of eigenvalues (n,)\n  wi (ndarray): Imaginary parts of eigenvalues (n,)\n\nReturns:\n  (a, x, wr, wi, ku_out): Reordered matrix, transformation, eigenvalues, new ku\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03rx\n>>> n = 3\n>>> a = np.array([\n...     [1.0, 0.5, 0.3],\n...     [0.0, 2.0, 0.4],\n...     [0.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> x = np.eye(n, order='F', dtype=float)\n>>> wr = np.array([1.0, 2.0, 3.0], dtype=float)\n>>> wi = np.zeros(n, dtype=float)\n>>> kl = 1\n>>> ku = 3\n>>> a_out, x_out, wr_out, wi_out, ku_out = mb03rx('V', kl, ku, a, x, wr, wi)\n>>> eig_before = sorted([1.0, 2.0, 3.0])\n>>> eig_after = sorted(wr_out.tolist())",
  "mb03ry": "Solve Sylvester equation -AX + XB = C with norm bound.\n\nSolves -AX + XB = C where A (M-by-M) and B (N-by-N) are in real Schur form.\nAborts if any elementary submatrix of X has infinity norm > PMAX.\n\nParameters:\n  a (ndarray): M-by-M matrix in real Schur form, column-major\n  b (ndarray): N-by-N matrix in real Schur form, column-major\n  c (ndarray): M-by-N right-hand side matrix (modified in-place)\n  pmax (float): Upper bound for infinity norm of elementary submatrices\n\nReturns:\n  (x, info): Solution X (same array as c), exit code (0=ok, 1=norm exceeded)\n\nExamples:\n\n>>> from slicot import mb03ry\n>>> import numpy as np\n>>> a = np.array([[2.0]], order='F', dtype=float)\n>>> b = np.array([[3.0]], order='F', dtype=float)\n>>> pmax = 1000.0\n>>> x, info = mb03ry(a, b, c, pmax)\n>>> residual = -a @ x + x @ b\n>>> info\n0",
  "mb03rz": "Reduce complex Schur form matrix to block-diagonal form.\n\nReduces an upper triangular complex matrix A (Schur form) to a\nblock-diagonal form using well-conditioned non-unitary similarity\ntransformations. The condition numbers of the transformations are\nroughly bounded by PMAX.\n\nParameters:\n  jobx (str): N = no transformation accumulation, U = accumulate in X\n  sort (str): N = no reordering, S = cluster eigenvalues,\n              C = closest-neighbour, B = both\n  a (ndarray): N-by-N complex upper triangular matrix (F-order)\n  pmax (float): Upper bound for transformation elements (>= 1.0)\n  tol (float): Tolerance for eigenvalue clustering\n  x (ndarray, optional): N-by-N transformation matrix (F-order)\n\nReturns:\n  (a_out, x_out, nblcks, blsize, w, info):\n    a_out (ndarray): Block-diagonal matrix (N-by-N, complex)\n    x_out (ndarray): Accumulated transformation (N-by-N, complex)\n    nblcks (int): Number of diagonal blocks\n    blsize (ndarray): Block sizes (nblcks,)\n    w (ndarray): Eigenvalues (N,)\n    info (int): 0=success, <0=param error\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03rz\n>>> n = 3\n>>> a = np.array([\n...     [1.0 + 2.0j, 0.0 + 0.0j, 0.0 + 0.0j],\n...     [0.0 + 0.0j, 3.0 + 4.0j, 0.0 + 0.0j],\n...     [0.0 + 0.0j, 0.0 + 0.0j, 5.0 + 6.0j]\n...     ], dtype=np.complex128, order='F')\n>>> pmax = 1000.0\n>>> tol = 0.0\n>>> a_out, x_out, nblcks, blsize, w, info = mb03rz('N', 'N', a, pmax, tol)\n>>> expected_eig = np.array([1.0+2.0j, 3.0+4.0j, 5.0+6.0j])\n>>> info\n0",
  "mb03sd": "Eigenvalues of a square-reduced Hamiltonian matrix.\n\nComputes the eigenvalues of an N-by-N square-reduced Hamiltonian matrix H'\nwhere eigenvalues of H' are the square roots of eigenvalues of A'' = A'^2 + G'Q'.\n\nParameters:\n  jobscl (str): 'N' = no balancing, 'S' = scale for equilibration\n  a (ndarray): N-by-N upper left block A' of H' (F-order)\n  qg (ndarray): N-by-(N+1) array with Q' (lower tri col 0) and G' (upper tri cols 1:N+1)\n\nReturns:\n  (wr, wi, info):\n    wr (ndarray): Real parts of N eigenvalues with non-negative real part\n    wi (ndarray): Imaginary parts of N eigenvalues\n    info (int): 0=success, <0=param error, >0=DHSEQR failed at i-th eigenvalue\n\nExamples:\n\n>>> from slicot import mb03sd\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([\n...     [2.0,  0.0,  0.0],\n...     [0.0,  1.0,  2.0],\n...     [0.0, -1.0,  3.0]\n...     ], order='F', dtype=float)\n>>> qg = np.zeros((3, 4), order='F', dtype=float)\n>>> qg[0, 0] = -2.0  # Q'(1,1)\n>>> qg[1, 0] = 0.0   # Q'(2,1)\n>>> qg[2, 0] = 0.0   # Q'(3,1)\n>>> qg[1, 1] = 0.0   # Q'(2,2) - wait, this conflicts with G' storage\n>>> qg[2, 1] = 0.0   # Q'(3,2)\n>>> qg[2, 2] = 0.0   # Q'(3,3)\n>>> qg[0, 1] = 1.0   # G'(1,1)\n>>> qg[0, 2] = 0.0   # G'(2,1)\n>>> qg[0, 3] = 0.0   # G'(3,1)\n>>> qg[1, 2] = 2.0   # G'(2,2)\n>>> qg[1, 3] = 3.0   # G'(3,2)\n>>> qg[2, 3] = 4.0   # G'(3,3)\n>>> wr, wi, info = mb03sd('S', a, qg)\n>>> expected_wr = np.array([2.0, 2.0, np.sqrt(2)])\n>>> expected_wi = np.array([1.0, -1.0, 0.0])\n>>> info\n0",
  "mb03td": "Reorder diagonal blocks of (skew-)Hamiltonian Schur form.\n\nReorders a matrix X in skew-Hamiltonian Schur form (X = [A G; 0 A^T], G = -G^T)\nor Hamiltonian Schur form (X = [A G; 0 -A^T], G = G^T) so that selected\neigenvalues appear in leading diagonal blocks of A.\n\nParameters:\n  typ (str): 'S'=skew-Hamiltonian, 'H'=Hamiltonian\n  compu (str): 'U'=update U1 and U2, 'N'=do not update\n  select (ndarray): Boolean array (n,), eigenvalue selection\n  lower (ndarray): Boolean array (n,), controls which eigenvalue copy\n  a (ndarray): N-by-N upper quasi-triangular matrix in Schur form (F-order)\n  g (ndarray): N-by-N symmetric (H) or skew-symmetric (S) matrix (F-order)\n  u1 (ndarray): N-by-N matrix U1 (F-order, if compu='U')\n  u2 (ndarray): N-by-N matrix U2 (F-order, if compu='U')\n\nReturns:\n  (a, g, u1, u2, wr, wi, m, info):\n    a (ndarray): Reordered matrix A in Schur form\n    g (ndarray): Updated matrix G\n    u1 (ndarray): Updated matrix U1\n    u2 (ndarray): Updated matrix U2\n    wr (ndarray): Real parts of eigenvalues (n,)\n    wi (ndarray): Imaginary parts of eigenvalues (n,)\n    m (int): Dimension of specified invariant subspace\n    info (int): 0=success, <0=param error, 1=reordering failed\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03td\n>>> n = 5\n>>> select = np.array([False, True, True, False, False], dtype=bool)\n>>> lower = np.array([False, True, True, False, False], dtype=bool)\n>>> a = np.array([\n...     [0.9501, 0.7621, 0.6154, 0.4057, 0.0579],\n...     [0.0,    0.4565, 0.7919, 0.9355, 0.3529],\n...     [0.0,   -0.6822, 0.4565, 0.9169, 0.8132],\n...     [0.0,    0.0,    0.0,    0.4103, 0.0099],\n...     [0.0,    0.0,    0.0,    0.0,    0.1389]\n...     ], order='F', dtype=float)\n>>> g = np.array([\n...     [0.0,   -0.1834, -0.1851,  0.5659,  0.3040],\n...     [0.0,    0.0,     0.4011, -0.9122,  0.2435],\n...     [0.0,    0.0,     0.0,     0.4786, -0.2432],\n...     [0.0,    0.0,     0.0,     0.0,    -0.5272],\n...     [0.0,    0.0,     0.0,     0.0,     0.0]\n...     ], order='F', dtype=float)\n>>> u1 = np.eye(n, order='F', dtype=float)\n>>> u2 = np.zeros((n, n), order='F', dtype=float)\n>>> a_out, g_out, u1_out, u2_out, wr, wi, m, info = mb03td(\n...     'S', 'U', select, lower, a, g, u1, u2\n...     )\n>>> u_full = np.block([\n...     [u1_out, u2_out],\n...     [-u2_out, u1_out]\n...     ])\n>>> identity = np.eye(2 * n)\n>>> info\n0",
  "mb03ts": "Swap diagonal blocks in (skew-)Hamiltonian Schur form.\n\nSwaps diagonal blocks A11 and A22 of order 1 or 2 in the upper quasi-triangular\nmatrix A contained in a skew-Hamiltonian or Hamiltonian matrix.\n\nParameters:\n  isham (bool): True=Hamiltonian, False=skew-Hamiltonian matrix\n  wantu (bool): True=update U1 and U2, False=do not update\n  a (ndarray): N-by-N upper quasi-triangular matrix in Schur form (F-order)\n  g (ndarray): N-by-N symmetric (ISHAM) or skew-symmetric (!ISHAM) matrix (F-order)\n  u1 (ndarray): N-by-N matrix U1 (F-order, if wantu)\n  u2 (ndarray): N-by-N matrix U2 (F-order, if wantu)\n  j1 (int): Index of first row of first block A11 (1-based)\n  n1 (int): Order of first block A11 (0, 1, or 2)\n  n2 (int): Order of second block A22 (0, 1, or 2)\n\nReturns:\n  (a, g, u1, u2, info):\n    a (ndarray): Reordered matrix A\n    g (ndarray): Updated matrix G\n    u1 (ndarray): Updated matrix U1\n    u2 (ndarray): Updated matrix U2\n    info (int): 0=success, 1=swap rejected (result would be far from Schur form)\n\nExamples:\n\n>>> from slicot import mb03ts\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([\n...     [1.0, 0.5, 0.3],\n...     [0.0, 2.0, 0.4],\n...     [0.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> g = np.array([\n...     [0.1, 0.2, 0.3],\n...     [0.0, 0.4, 0.5],\n...     [0.0, 0.0, 0.6]\n...     ], order='F', dtype=float)\n>>> u1 = np.eye(n, order='F', dtype=float)\n>>> u2 = np.eye(n, order='F', dtype=float)\n>>> isham = True\n>>> wantu = True\n>>> j1 = 1\n>>> n1 = 1\n>>> n2 = 1\n>>> a_out, g_out, u1_out, u2_out, info = mb03ts(isham, wantu, a, g, u1, u2, j1, n1, n2)\n>>> info\n0",
  "mb03ud": "Singular value decomposition of upper triangular matrix.\n\nComputes SVD: A = Q*S*P' where Q, P are orthogonal and S is diagonal\nwith non-negative singular values in descending order.\n\nParameters:\n  n (int): Order of matrix A\n  a (ndarray): Upper triangular matrix A (n x n, F-order)\n               If jobp='V', returns P' on exit\n  jobq (str, optional): 'V' to compute Q, 'N' otherwise (default 'N')\n  jobp (str, optional): 'V' to compute P', 'N' otherwise (default 'N')\n  ldwork (int, optional): Workspace size (-1 for query, default auto)\n\nReturns:\n  (sv, p, q, info): Singular values, right vectors P', left vectors Q, exit code\n  - sv: array of singular values (descending order)\n  - p: P' matrix if jobp='V', else None\n  - q: Q matrix if jobq='V', else None\n  - info: 0=success, <0=invalid param, >0=convergence failure",
  "mb03vd": "Reduce product of p matrices to periodic Hessenberg form.\n\nParameters:\n  n (int): Order of square matrices\n  p (int): Number of matrices in product\n  ilo (int): Lower index for reduction (1-based)\n  ihi (int): Upper index for reduction (1-based)\n  a (ndarray): 3D matrix array (n,n,p), column-major\n\nReturns:\n  (a, tau, info): Reduced matrices, tau factors, exit code\n\nExamples:\n\n>>> from slicot import mb03vd\n>>> import numpy as np\n>>> n = 4\n>>> p = 2\n>>> ilo = 1\n>>> ihi = 4\n>>> a1 = np.array([\n...     [1.5, -0.7, 3.5, -0.7],\n...     [1.0,  0.0, 2.0,  3.0],\n...     [1.5, -0.7, 2.5, -0.3],\n...     [1.0,  0.0, 2.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> a2 = np.array([\n...     [1.5, -0.7, 3.5, -0.7],\n...     [1.0,  0.0, 2.0,  3.0],\n...     [1.5, -0.7, 2.5, -0.3],\n...     [1.0,  0.0, 2.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> a = np.zeros((n, n, p), dtype=np.float64, order='F')\n>>> a[:, :, 0] = a1\n>>> a[:, :, 1] = a2\n>>> a_out, tau, info = mb03vd(n, p, ilo, ihi, a)\n>>> h1 = np.triu(a_out[:, :, 0], -1)\n>>> h2 = np.triu(a_out[:, :, 1])\n>>> info\n0",
  "mb03vw": "Reduce periodic product to Hessenberg-triangular form (unblocked).\n\nReduces A(:,:,1)^S(1) * ... * A(:,:,K)^S(K) to Hessenberg-triangular form.\nH-th matrix becomes upper Hessenberg, others upper triangular.\n\nParameters:\n  compq (str): 'N'=no Q, 'U'=update Q, 'I'=init Q to I, 'P'=use qind\n  qind (ndarray, optional): Array(k) for partial Q generation with compq='P'\n  triu (str): 'N'=only neg signature, 'A'=all N-1 matrices triangularized\n  n (int): Order of each factor\n  k (int): Number of factors\n  h (int): Which factor becomes Hessenberg (1..k or auto)\n  ilo (int): Lower active submatrix bound (1-based)\n  ihi (int): Upper active submatrix bound (1-based)\n  s (ndarray): Signature array(k) with values 1 or -1\n  a (ndarray): 3D array (n,n,k) of factors\n  q (ndarray, optional): 3D array (n,n,k) for Q matrices (compq='U')\n\nReturns:\n  (a, q, h, info): Reduced factors, orthogonal matrices, Hessenberg index, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03vw\n>>> n = 4\n>>> k = 2\n>>> ilo = 1\n>>> ihi = n\n>>> a = np.random.randn(n, n, k).astype(float, order='F')\n>>> s = np.array([1, -1], dtype=np.int32)\n>>> h = 1\n>>> a_out, q_out, h_out, info = mb03vw('I', None, 'N', n, k, h, ilo, ihi, s, a)\n...     f\"Matrix {i} not upper triangular at ({row},{col})\"\n>>> h_idx = h_out - 1\n...     f\"Hessenberg matrix has nonzero at ({row},{col})\"\n...     qt_q = q_out[:, :, i].T @ q_out[:, :, i]\n>>> info\n0",
  "mb03vy": "Generate orthogonal matrices from periodic Hessenberg reduction.\n\nGenerates Q_1, Q_2, ..., Q_p orthogonal matrices from reflectors\nproduced by mb03vd.\n\nParameters:\n  n (int): Order of square matrices\n  p (int): Number of transformation matrices\n  ilo (int): Lower index from mb03vd (1-based)\n  ihi (int): Upper index from mb03vd (1-based)\n  a (ndarray): 3D array (n,n,p) with Householder vectors from mb03vd\n  tau (ndarray): 2D array (n-1,p) with scalar factors from mb03vd\n\nReturns:\n  (q, info): Orthogonal matrices Q_j, exit code\n\nExamples:\n\n>>> from slicot import mb03vy\n>>> import numpy as np\n>>> n = 4\n>>> p = 2\n>>> ilo = 1\n>>> ihi = n\n>>> a_out, tau, info_vd = mb03vd(n, p, ilo, ihi, a)\n>>> q, info_vy = mb03vy(n, p, ilo, ihi, a_out, tau)\n...     qj = q[:, :, j]\n...     qtq = qj.T @ qj\n...     qqt = qj @ qj.T",
  "mb03wa": "Swap adjacent diagonal blocks in periodic real Schur form.\n\nSwaps adjacent diagonal blocks A11*B11 and A22*B22 of size 1-by-1 or 2-by-2\nin an upper (quasi) triangular matrix product A*B by orthogonal equivalence\ntransformation.\n\n(A, B) must be in periodic real Schur canonical form, i.e., A is block upper\ntriangular with 1-by-1 and 2-by-2 diagonal blocks, and B is upper triangular.\n\nOptionally, the matrices Q and Z of generalized Schur vectors are updated:\n    Q(in) * A(in) * Z(in)' = Q(out) * A(out) * Z(out)'\n    Z(in) * B(in) * Q(in)' = Z(out) * B(out) * Q(out)'\n\nParameters:\n  wantq (bool): True to update Q, False if Q not required\n  wantz (bool): True to update Z, False if Z not required\n  n1 (int): Order of first block A11*B11 (0, 1, or 2)\n  n2 (int): Order of second block A22*B22 (0, 1, or 2)\n  a (ndarray): (N1+N2)-by-(N1+N2) matrix A (F-order)\n  b (ndarray): (N1+N2)-by-(N1+N2) matrix B (F-order)\n  q (ndarray): (N1+N2)-by-(N1+N2) orthogonal matrix Q (if wantq)\n  z (ndarray): (N1+N2)-by-(N1+N2) orthogonal matrix Z (if wantz)\n\nReturns:\n  (a_out, b_out, q_out, z_out, info):\n    a_out: Reordered matrix A\n    b_out: Reordered matrix B\n    q_out: Updated orthogonal matrix Q (if wantq)\n    z_out: Updated orthogonal matrix Z (if wantz)\n    info: 0=success, 1=swap rejected (would be too far from Schur form)\n\nExamples:\n\n>>> from slicot import mb03wa\n>>> import numpy as np\n>>> a = np.array([\n...     [2.0, 0.5],\n...     [0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.3],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> q = np.eye(2, order='F', dtype=float)\n>>> z = np.eye(2, order='F', dtype=float)\n>>> eig_before = np.linalg.eigvals(a @ b)\n>>> a_out, b_out, q_out, z_out, info = mb03wa(True, True, 1, 1, a, b, q, z)\n>>> eig_after = np.linalg.eigvals(a_out @ b_out)\n...     sorted(eig_before.real),\n...     sorted(eig_after.real),\n...     rtol=1e-10\n>>> )\n>>> info\n0",
  "mb03wd": "Compute periodic Schur decomposition of matrix product.\n\nComputes Schur decomposition and eigenvalues of H = H_1*H_2*...*H_p\nwith H_1 upper Hessenberg, H_2...H_p upper triangular.\n\nParameters:\n  job (str): 'E' = eigenvalues only, 'S' = full Schur form\n  compz (str): 'N' = no Z, 'I' = init Z to I, 'V' = update Z\n  n (int): Order of matrices\n  p (int): Number of matrices\n  ilo (int): Lower index (1-based)\n  ihi (int): Upper index (1-based)\n  iloz (int): Lower Z row index (1-based)\n  ihiz (int): Upper Z row index (1-based)\n  h (ndarray): 3D array (n,n,p), column-major\n  z (ndarray, optional): 3D array for COMPZ='V'\n\nReturns:\n  (h, z, wr, wi, info): Schur form, transforms, eigenvalues, exit code\n\nExamples:\n\n>>> from slicot import mb03wd\n>>> import numpy as np\n>>> n = 4\n>>> p = 2\n>>> ilo = 1\n>>> ihi = 4\n>>> iloz = 1\n>>> ihiz = 4\n>>> a = np.zeros((n, n, p), order='F', dtype=float)\n>>> a[:, :, 0] = np.array([\n...     [1.5, -0.7, 3.5, -0.7],\n...     [1.0,  0.0, 2.0,  3.0],\n...     [1.5, -0.7, 2.5, -0.3],\n...     [1.0,  0.0, 2.0,  1.0]\n...     ], order='F', dtype=float)\n>>> a[:, :, 1] = np.array([\n...     [1.5, -0.7, 3.5, -0.7],\n...     [1.0,  0.0, 2.0,  3.0],\n...     [1.5, -0.7, 2.5, -0.3],\n...     [1.0,  0.0, 2.0,  1.0]\n...     ], order='F', dtype=float)\n>>> h, tau, info_vd = mb03vd(n, p, ilo, ihi, a)\n>>> h_result, z, wr, wi, info = mb03wd('S', 'I', n, p, ilo, ihi, iloz, ihiz, h)\n>>> expected_wr = np.array([6.449861, 6.449861, 0.091315, 0.208964])\n>>> expected_wi = np.array([7.817717, -7.817717, 0.0, 0.0])\n>>> t1 = h_result[:, :, 0]\n>>> t2 = h_result[:, :, 1]\n>>> info\n0",
  "mb03wx": "Compute eigenvalues of a product of matrices in periodic Schur form.\n\nComputes eigenvalues of T = T_1*T_2*...*T_p where T_1 is upper\nquasi-triangular (real Schur form) and T_2, ..., T_p are upper triangular.\n\nParameters:\n  n (int): Order of matrix T (n >= 0)\n  p (int): Number of matrices in product (p >= 1)\n  t (ndarray): 3D array (ldt1, ldt2, p). T(*,*,1) is upper quasi-triangular,\n               T(*,*,j) for j > 1 are upper triangular.\n\nReturns:\n  (wr, wi, info): Real and imaginary parts of eigenvalues, exit code\n\nExamples:\n\n>>> from slicot import mb03wx\n>>> import numpy as np\n>>> n = 4\n>>> p = 1\n>>> t1 = np.array([\n...     [2.0, 3.0, 0.5, 0.3],\n...     [-1.0, 2.0, 0.2, 0.1],\n...     [0.0, 0.0, 4.0, 0.4],\n...     [0.0, 0.0, 0.0, 5.0]\n...     ], order='F', dtype=float)\n>>> t = np.zeros((n, n, p), order='F', dtype=float)\n>>> t[:, :, 0] = t1\n>>> wr, wi, info = mb03wx(n, p, t)\n>>> expected_wr = np.array([2.0, 2.0, 4.0, 5.0])\n>>> expected_wi = np.array([np.sqrt(3.0), -np.sqrt(3.0), 0.0, 0.0])\n>>> info\n0",
  "mb03xd": "Compute eigenvalues of Hamiltonian matrix.\n\nComputes eigenvalues of H = [A, G; Q, -A'] where G=G' and Q=Q'.\nUses symplectic URV and periodic Schur decompositions.\n\nParameters:\n  balanc (str): 'N' = none, 'P' = permute, 'S' = scale, 'B' = both\n  job (str): 'E' = eigenvalues only, 'S' = Schur form, 'G' = full\n  jobu (str): 'N' = no U, 'U' = compute U\n  jobv (str): 'N' = no V, 'V' = compute V\n  n (int): Order of matrix A\n  a (ndarray): Matrix A, shape (n,n)\n  qg (ndarray): Q (lower) and G (upper), shape (n,n+1)\n\nReturns:\n  (S, T, QG, U1, U2, V1, V2, wr, wi, ilo, scale, info)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03xd\n>>> n = 5\n>>> A = np.array([\n...     [3.7588548168313685e-001, 9.1995720669587144e-001, 1.9389317998466821e-001, 5.4878212553858818e-001, 6.2731478808399666e-001],\n...     [9.8764628987858052e-003, 8.4472150190817474e-001, 9.0481233416635698e-001, 9.3158335257969060e-001, 6.9908013774533750e-001],\n...     [4.1985780631021896e-001, 3.6775288246828447e-001, 5.6920574967174709e-001, 3.3519743020639464e-001, 3.9718395379261456e-001],\n...     [7.5366962581358721e-001, 6.2080133182114383e-001, 6.3178992922175603e-001, 6.5553105501201447e-001, 4.1362889533818031e-001],\n...     [7.9387177473231862e-001, 7.3127726446634478e-001, 2.3441295540825388e-001, 3.9190420688900335e-001, 6.5521294635567051e-001]\n...     ], order='F', dtype=float)\n>>> QG = np.array([\n...     [1.8015558545989005e-001, 4.1879254941592853e-001, 2.7203760737317784e-001, 2.8147214090719214e-001, 1.7731904815580199e-001, 3.4718672159409536e-001],\n...     [2.7989257702981651e-001, 3.5042861661866559e-001, 2.5565572408444881e-001, 4.3977750345993827e-001, 2.8855026075967616e-001, 2.1496327083014577e-001],\n...     [1.7341073886969158e-001, 3.9913855375815932e-001, 4.0151317011596516e-001, 4.0331887464437133e-001, 2.6723538667317948e-001, 3.7110275606849241e-001],\n...     [3.7832182695699140e-001, 3.3812641389556752e-001, 8.4360396433341395e-002, 4.3672540277019672e-001, 7.0022228267365608e-002, 3.8210230186291916e-001],\n...     [1.9548216143135175e-001, 2.9055490787446736e-001, 4.7670819669167425e-001, 1.4636498713707141e-001, 2.7670398401519275e-001, 2.9431082727794898e-002]\n...     ], order='F', dtype=float)\n>>> S, T, QG_out, U1, U2, V1, V2, wr, wi, ilo, scale, info = mb03xd(\n...     'N', 'G', 'U', 'V', n, A, QG\n...     )\n>>> info\n0",
  "mb03xp": "Periodic Schur decomposition of A*B product.\n\nComputes Q'*A*Z = S (Schur form) and Z'*B*Q = T (upper triangular).\n\nParameters:\n  job (str): 'E' = eigenvalues only, 'S' = Schur form\n  compq (str): 'N' = no Q, 'I' = init Q to I, 'V' = update Q\n  compz (str): 'N' = no Z, 'I' = init Z to I, 'V' = update Z\n  n (int): Order of matrices\n  ilo (int): Lower index (1-based)\n  ihi (int): Upper index (1-based)\n  a (ndarray): Upper Hessenberg matrix A\n  b (ndarray): Upper triangular matrix B\n\nReturns:\n  (S, T, Q, Z, alphar, alphai, beta, info)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03xp\n>>> n = 4\n>>> ilo = 1\n>>> ihi = 4\n>>> A = np.triu(np.random.randn(n, n), k=-1).astype(float, order='F')\n>>> B = np.triu(np.random.randn(n, n)).astype(float, order='F')\n>>> S, T, Q, Z, alphar, alphai, beta, info = mb03xp(\n...     'S', 'I', 'I', n, ilo, ihi, A, B\n...     )\n>>> info\n0",
  "mb03xs": "Eigenvalues and real skew-Hamiltonian Schur form of a skew-Hamiltonian matrix.\n\nComputes eigenvalues and real skew-Hamiltonian Schur form of W = [[A, G], [Q, A^T]]\nwhere G, Q are N-by-N skew-symmetric. Computes orthogonal symplectic U such that\nU^T W U = [[Aout, Gout], [0, Aout^T]] with Aout in Schur canonical form.\n\nParameters:\n  a (ndarray): N-by-N matrix A (F-order)\n  qg (ndarray): N-by-(N+1) packed Q (cols 0:N lower tri) and G (cols 1:N+1 upper tri)\n  jobu (str, optional): 'N'=don't compute U (default), 'U'=compute U1 and U2\n\nReturns (jobu='N'):\n  (a_out, qg_out, wr, wi, info):\n    a_out: Aout in Schur form\n    qg_out: Gout in cols 1:N+1, Q part zeroed\n    wr, wi: Real and imaginary parts of eigenvalues\n    info: 0=success, <0=param error, >0=DHSEQR failed\n\nReturns (jobu='U'):\n  (a_out, qg_out, u1, u2, wr, wi, info):\n    u1, u2: N-by-N matrices where U = [[U1, U2], [-U2, U1]]\n\nExamples:\n\n>>> from slicot import mb03xs\n>>> import numpy as np\n>>> n = 2\n>>> a = np.array([[1.0, 2.0], [0.5, 1.5]], dtype=float, order='F')\n>>> q_lower = np.zeros((n, n), dtype=float, order='F')\n>>> q_lower[1, 0] = 0.3\n>>> g_upper = np.zeros((n, n), dtype=float, order='F')\n>>> g_upper[0, 1] = 0.4\n>>> qg = pack_qg(n, q_lower, g_upper)\n>>> a_work = a.copy(order='F')\n>>> qg_work = qg.copy(order='F')\n>>> a_out, qg_out, wr, wi, info = mb03xs(a_work, qg_work, jobu='N')\n>>> eig_computed = wr + 1j * wi\n>>> eig_full = np.concatenate([eig_computed, eig_computed])\n>>> eig_full_sorted = np.sort(np.abs(eig_full))\n>>> info\n0",
  "mb03xu": "Panel reduction for blocked Hamiltonian matrix.\n\nReduces 2*NB columns and rows of a (K+2N)-by-(K+2N) Hamiltonian\nmatrix H = [[op(A), G], [Q, op(B)]] using orthogonal symplectic\ntransformations. Auxiliary routine for MB04TB.\n\nParameters:\n  ltra (bool): If True, op(A) = A', else op(A) = A\n  ltrb (bool): If True, op(B) = B', else op(B) = B\n  n (int): Order of Q (n >= 0)\n  k (int): Offset of reduction (k >= 0)\n  nb (int): Number of columns/rows to reduce (0 <= nb < n)\n  a (ndarray): Matrix A (F-order)\n  b (ndarray): Matrix B (F-order)\n  g (ndarray): Matrix G (F-order)\n  q (ndarray): Matrix Q (F-order)\n\nReturns:\n  (A, B, G, Q, XA, XB, XG, XQ, YA, YB, YG, YQ, CSL, CSR, TAUL, TAUR, info):\n    Modified matrices, update matrices, Givens rotations, reflectors, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03xu\n>>> n = 5\n>>> k = 2\n>>> nb = 2\n>>> A = np.random.randn(k + n, n).astype(float, order='F')\n>>> B = np.random.randn(n, k + n).astype(float, order='F')\n>>> G = np.random.randn(k + n, k + n).astype(float, order='F')\n>>> G = (G + G.T) / 2\n>>> Q = np.random.randn(n, n).astype(float, order='F')\n>>> (A_out, B_out, G_out, Q_out,\n...     XA, XB, XG, XQ, YA, YB, YG, YQ,\n...     CSL, CSR, TAUL, TAUR, info) = mb03xu(\n...     False, False, n, k, nb,\n...     A.copy(), B.copy(), G.copy(), Q.copy()\n...     )",
  "mb03xz": "Eigenvalues of complex Hamiltonian matrix.\n\nComputes eigenvalues of H = [[A, G], [Q, -A^H]] where G, Q are Hermitian.\nDue to structure, eigenvalues appear in pairs (lambda, -conj(lambda)).\nUses embedding to real skew-Hamiltonian and structured Schur form.\n\nParameters:\n  a (ndarray): N-by-N complex matrix A (F-order)\n  qg (ndarray): N-by-(N+1) packed Q (cols 0:N lower tri) and G (cols 1:N+1 upper tri)\n  balanc (str): 'N'=no balancing, 'P'=permute, 'S'=scale, 'B'=both\n  job (str): 'E'=eigenvalues only, 'S'=compute Schur form Sc, 'G'=compute Sc and Gc\n  jobu (str): 'N'=don't compute U (default), 'U'=compute unitary symplectic U\n\nReturns:\n  (wr, wi, sc, gc, u1, u2, ilo, scale, info):\n    wr, wi: Real and imaginary parts of 2N eigenvalues\n    sc: 2N-by-2N upper triangular Schur form (if job='S' or 'G')\n    gc: 2N-by-2N Hermitian Gc matrix (if job='G')\n    u1, u2: 2N-by-2N blocks of unitary symplectic U (if job!='E' and jobu='U')\n    ilo: Balancing index (1 if balanc='N')\n    scale: Balancing scale factors\n    info: 0=success, <0=param error, >0=QR failed, 2N+1=2x2 block failed\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03xz\n>>> n = 4\n>>> a = np.array([\n...     [0.8147+0.4217j, 0.6323+0.6557j, 0.9575+0.6787j, 0.9571+0.6554j],\n...     [0.9057+0.9157j, 0.0975+0.0357j, 0.9648+0.7577j, 0.4853+0.1711j],\n...     [0.1269+0.7922j, 0.2784+0.8491j, 0.1576+0.7431j, 0.8002+0.7060j],\n...     [0.9133+0.9594j, 0.5468+0.9339j, 0.9705+0.3922j, 0.1418+0.0318j],\n...     ], dtype=complex, order='F')\n>>> qg = np.array([\n...     [0.2769+0.0j,      0.6948+0.0j,      0.4387+0.7513j, 0.1869+0.8909j, 0.7094+0.1493j],\n...     [0.0462+0.1626j,   0.3171+0.0j,      0.3816+0.0j,    0.4898+0.9593j, 0.7547+0.2575j],\n...     [0.0971+0.1190j,   0.9502+0.5853j,   0.7655+0.0j,    0.4456+0.0j,    0.2760+0.8407j],\n...     [0.8235+0.4984j,   0.0344+0.2238j,   0.7952+0.6991j, 0.6463+0.0j,    0.6797+0.0j],\n...     ], dtype=complex, order='F')\n>>> expected_wr = np.array([3.0844, -3.0844, 0.5241, -0.5241, 0.8824, -0.8824, 0.4459, -0.4459])\n>>> expected_wi = np.array([2.7519,  2.7519, -1.3026, -1.3026, -0.6918, -0.6918, 0.4748, 0.4748])\n>>> wr, wi, sc, gc, u1, u2, ilo, scale, info = mb03xz(\n...     a, qg, balanc='N', job='G', jobu='U'\n...     )\n>>> eig_computed = wr + 1j * wi\n>>> idx_c = np.lexsort((eig_computed.imag, eig_computed.real))\n>>> info\n0",
  "mb03ya": "Annihilate subdiagonal entries of Hessenberg matrix.\n\nAuxiliary routine for MB03XP and MB03YD.\n\nParameters:\n  wantt (bool): Compute full Schur form\n  wantq (bool): Accumulate Q matrix\n  wantz (bool): Accumulate Z matrix\n  ilo, ihi (int): Active block bounds (1-based)\n  iloq, ihiq (int): Q/Z row bounds (1-based)\n  pos (int): Position of zero diagonal in B (1-based)\n  a, b, q, z (ndarray): Matrices\n\nReturns:\n  (a, b, q, z, info): Transformed matrices and exit code\n\nExamples:\n\n>>> from slicot import mb03ya\n>>> import numpy as np\n>>> n = 4\n>>> ilo, ihi = 1, 4\n>>> iloq, ihiq = 1, 4\n>>> pos = 2\n>>> a = np.zeros((n, n), order='F', dtype=float)\n...     a[i, j] = np.random.randn()\n...     a[i + 1, i] = np.random.randn()\n>>> b = np.zeros((n, n), order='F', dtype=float)\n...     b[i, j] = np.random.randn()\n>>> b[pos - 1, pos - 1] = 0.0\n>>> q = np.eye(n, order='F', dtype=float)\n>>> z = np.eye(n, order='F', dtype=float)\n>>> a_out, b_out, q_out, z_out, info = mb03ya(\n...     True, True, True, ilo, ihi, iloq, ihiq, pos, a, b, q, z\n...     )\n>>> info\n0",
  "mb03yd": "Periodic QR iteration for eigenvalues of periodic Hessenberg matrix.\n\nComputes eigenvalues of A*inv(B) where A is upper Hessenberg and B\nis upper triangular, using periodic QR iteration.\n\nParameters:\n  wantt (bool): Compute full Schur form (True) or eigenvalues only (False)\n  wantq (bool): Update matrix Q\n  wantz (bool): Update matrix Z\n  n (int): Order of matrices\n  ilo, ihi (int): Active block bounds (1-based)\n  iloq, ihiq (int): Q/Z row bounds (1-based)\n  a, b, q, z (ndarray): Input matrices (F-order)\n\nReturns:\n  (alphar, alphai, beta, info): Eigenvalue numerators/denominators and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03yd\n>>> n = 2\n>>> a = np.array([\n...     [3.0, 1.0],\n...     [0.5, 2.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.5],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> q = np.eye(n, order='F', dtype=float)\n>>> z = np.eye(n, order='F', dtype=float)\n>>> alphar, alphai, beta, info = mb03yd(\n...     wantt=True, wantq=True, wantz=True,\n...     n=n, ilo=1, ihi=n, iloq=1, ihiq=n,\n...     a=a, b=b, q=q, z=z\n...     )\n>>> info\n0",
  "mb03yt": "Periodic Schur factorization of 2x2 matrix pair.\n\nParameters:\n  a (ndarray): 2x2 matrix A\n  b (ndarray): 2x2 upper triangular matrix B\n\nReturns:\n  (a, b, alphar, alphai, beta, csl, snl, csr, snr):\n    Transformed matrices, eigenvalue info, rotation parameters\n\nExamples:\n\n>>> from slicot import mb03yt\n>>> import numpy as np\n>>> a = np.array([\n...     [4.0, 1.0],\n...     [0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.5],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a_out, b_out, alphar, alphai, beta, csl, snl, csr, snr = mb03yt(a, b)",
  "mb03za": "Reorder eigenvalues in periodic Schur form and compute stable subspace.\n\nComputes orthogonal matrices Ur and Vr so that:\n  Vr' * A * Ur = [A11  A12]    Ur' * B * Vr = [B11  B12]\n                 [0    A22]                   [0    B22]\nis in periodic Schur form with eigenvalues of A11*B11 forming selected cluster.\n\nAlso computes orthogonal W transforming [0, -A11; B11, 0] to block triangular\nform with eigenvalues of R11 having positive real part.\n\nParameters:\n  compc (str): 'U' to update C, 'N' to skip\n  compu (str): 'U' to update U1/U2, 'N' to skip\n  compv (str): 'V' to update V1/V2, 'N' to skip\n  compw (str): 'N' W not needed, 'I' init to identity, 'V' accumulate\n  which (str): 'A' all eigenvalues, 'S' selected by select\n  select (ndarray): Boolean array specifying selected eigenvalues\n  a (ndarray): Upper quasi-triangular matrix A (F-order)\n  b (ndarray): Upper triangular matrix B (F-order)\n  c (ndarray): General matrix C (F-order)\n  u1, u2 (ndarray): Blocks of orthogonal symplectic U\n  v1, v2 (ndarray): Blocks of orthogonal symplectic V\n  w (ndarray): Orthogonal transformation matrix\n\nReturns:\n  (r22, b_out, c_out, u1_out, u2_out, v1_out, v2_out, w_out, wr, wi, m, info):\n    r22: M-by-M R22 matrix stored in A\n    wr, wi: Real/imaginary parts of eigenvalues of R11\n    m: Number of selected eigenvalues\n    info: 0=success, 1-4=various algorithm failures\n\nExamples:\n\n>>> from slicot import mb03za\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([\n...     [-2.0, 0.5, 0.1],\n...     [0.0, -1.5, 0.3],\n...     [0.0, 0.0, -1.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.2, 0.1],\n...     [0.0, 1.5, 0.2],\n...     [0.0, 0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> c = np.eye(n, order='F', dtype=float)\n>>> u1 = np.eye(n, order='F', dtype=float)\n>>> u2 = np.zeros((n, n), order='F', dtype=float)\n>>> v1 = np.eye(n, order='F', dtype=float)\n>>> v2 = np.zeros((n, n), order='F', dtype=float)\n>>> w = np.zeros((2*n, 2*n), order='F', dtype=float)\n>>> select = np.array([True, True, True], dtype=bool)\n>>> r22, b_out, c_out, u1_out, u2_out, v1_out, v2_out, w_out, wr, wi, m, info = mb03za(\n...     'N', 'N', 'N', 'I', 'A', select, a, b, c, u1, u2, v1, v2, w\n...     )\n>>> info\n0",
  "mb03zd": "Compute stable/unstable invariant subspaces for Hamiltonian matrix.\n\nComputes orthonormal bases US and/or UU for the stable and/or unstable\ninvariant subspaces of a Hamiltonian matrix using the output of MB03XD.\nThe Hamiltonian is represented in product periodic Schur form.\n\nParameters:\n  which (str): 'A' all eigenvalues, 'S' selected eigenvalues\n  meth (str): 'Q' QR-based, 'L' 2*n vectors, 'R' extended (for extractor)\n  stab (str): 'S' stable only, 'U' unstable only, 'B' both\n  balanc (str): 'N' no balancing, 'P'/'S'/'B' permute/scale/both\n  ortbal (str): 'B' balance before orthonormalization, 'A' after\n  n (int): Order of Hamiltonian matrix (n >= 0)\n  mm (int): Number of vectors (must be >= 2*n)\n  ilo (int): Lower index from balancing (1 if balanc='N')\n  scale (ndarray): Scale factors from balancing (n,)\n  s (ndarray): Real Schur form S (n x n, F-order)\n  t (ndarray): Upper triangular T (n x n, F-order)\n  g (ndarray): Matrix G (n x n, F-order)\n  u1, u2 (ndarray): Orthogonal symplectic U blocks (n x n, F-order)\n  v1, v2 (ndarray): Orthogonal symplectic V blocks (n x n, F-order)\n\nReturns:\n  (m, wr, wi, us, uu, info):\n    m: Number of selected eigenvalues\n    wr, wi: Real/imaginary parts of eigenvalues\n    us: Stable invariant subspace basis (mm x m, F-order)\n    uu: Unstable invariant subspace basis (mm x m, F-order)\n    info: 0=success, 1-5=various algorithm failures\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb03zd\n>>> n = 5\n>>> ilo = 1\n>>> s = np.array([\n...     [-3.1844761777714732,  0.1612357243439331, -0.0628592203751138,  0.2449004200921981,  0.1974400149992579],\n...     [ 0.0000000000000000, -0.1510667773167784,  0.4260444411622838, -0.1775026035208615,  0.3447278421198472],\n...     [ 0.0000000000000000, -0.1386140422054264, -0.3006779624777515,  0.2944143257134196,  0.3456440339120323],\n...     [ 0.0000000000000000,  0.0000000000000000,  0.0000000000000000, -0.2710128384740570,  0.0933189808067138],\n...     [ 0.0000000000000000,  0.0000000000000000,  0.0000000000000000,  0.4844146572359603,  0.2004347508746697]\n...     ], dtype=float, order='F')\n>>> t = np.array([\n...     [ 3.2038208121776366,  0.1805955192510651,  0.2466389119377561, -0.2539149302433368, -0.0359238844381195],\n...     [ 0.0000000000000000, -0.7196686433290816,  0.0000000000000000,  0.2428659121580384, -0.0594190100670832],\n...     [ 0.0000000000000000,  0.0000000000000000, -0.1891741194498107, -0.3309578443491266, -0.0303520731950515],\n...     [ 0.0000000000000000,  0.0000000000000000,  0.0000000000000000, -0.4361574461961550,  0.0000000000000000],\n...     [ 0.0000000000000000,  0.0000000000000000,  0.0000000000000000,  0.0000000000000000,  0.1530894573304220]\n...     ], dtype=float, order='F')\n>>> g = np.array([\n...     [-0.0370982242678464,  0.0917788436945724, -0.0560402416315252,  0.1345152517579192,  0.0256668227276700],\n...     [ 0.0652183678916931, -0.0700457231988297,  0.0350041175858839, -0.2233868768749268, -0.1171980260782843],\n...     [-0.0626428681377119,  0.2327575351902772, -0.1251515732208170, -0.0177816046663201,  0.3696921118421182],\n...     [ 0.0746042309265599, -0.0828007611045140,  0.0217427473546043, -0.1157775118548851, -0.3161183681200527],\n...     [ 0.1374372236164812,  0.1002727885506992,  0.4021556774753973, -0.0431072263235579,  0.1067394572547867]\n...     ], dtype=float, order='F')\n>>> u1 = np.array([\n...     [ 0.3806883009357247, -0.0347810363019649, -0.5014665065895758,  0.5389691288472394,  0.2685446895251367],\n...     [ 0.4642712665555326, -0.5942766860716395,  0.4781179763952615,  0.2334370556238151,  0.0166790369048933],\n...     [ 0.2772789197782788, -0.0130145392695876, -0.2123817030594055, -0.2550292626960107, -0.5049268366774490],\n...     [ 0.4209268575081796,  0.1499593172661228, -0.1925590746592156, -0.5472292877802402,  0.4543329704184054],\n...     [ 0.3969669479129449,  0.6321903535930828,  0.3329156356041961,  0.0163533225344433, -0.2638879466190024]\n...     ], dtype=float, order='F')\n>>> u2 = np.array([\n...     [-0.1795922007470742,  0.1908329820840911,  0.0868799433942070,  0.3114741142062388, -0.2579907627915167],\n...     [-0.2447897730222852, -0.1028403314750045, -0.1157840914576285, -0.1873268885694406,  0.1700708002861580],\n...     [-0.2243335325285328,  0.3180998613802520,  0.3315380214794822,  0.1977859924739963,  0.5072476567310013],\n...     [-0.2128397588651423, -0.2740560593051881,  0.1941418870268881, -0.3096684962457369, -0.0581576193198714],\n...     [-0.2002027567371932, -0.0040094115506855, -0.3979373387545264,  0.1520881534833910, -0.2010804514091372]\n...     ], dtype=float, order='F')\n>>> v1 = np.array([\n...     [ 0.4447147692018334, -0.6830166755147440, -0.0002576861753487,  0.5781954611783305, -0.0375091627893805],\n...     [ 0.5121756358795817,  0.0297197140254773,  0.4332229148788766, -0.3240527006890552,  0.5330850295256511],\n...     [ 0.3664711365265602,  0.3288511296455119,  0.0588396016404451,  0.1134221597062257,  0.1047567336850078],\n...     [ 0.4535357098437908,  0.1062866148880792, -0.3964092656837774, -0.2211800890450674,  0.0350667323996222],\n...     [ 0.4450432900616097,  0.2950206358263853, -0.1617837757183893, -0.0376369332204927, -0.6746752660482623]\n...     ], dtype=float, order='F')\n>>> v2 = np.array([\n...     [ 0.0000000000000000,  0.0000000000000000,  0.0000000000000000,  0.0000000000000000,  0.0000000000000000],\n...     [ 0.0299719306696789, -0.2322624725320701, -0.0280846899680325, -0.3044255686880000, -0.1077641482535519],\n...     [-0.0069083614679702,  0.3351358347080056, -0.4922707032978891,  0.4293545450291714,  0.4372821269062001],\n...     [ 0.0167847133528843,  0.2843629278945327,  0.5958979805231146,  0.3097336757510886, -0.2086733033047188],\n...     [ 0.0248567764822071, -0.2810759958040470, -0.1653113624869834, -0.3528780198620412, -0.0254898556119252]\n...     ], dtype=float, order='F')\n>>> scale = np.zeros(n, dtype=float, order='F')\n>>> m, wr, wi, us, uu, info = mb03zd(\n...     'A', 'L', 'B', 'N', 'B',\n...     n, 2*n, ilo, scale, s, t, g, u1, u2, v1, v2\n...     )\n>>> expected_wr = np.array([-3.1941, -0.1350, -0.1350, -0.0595, -0.0595])\n>>> expected_wi = np.array([0.0000, 0.3179, -0.3179, 0.2793, -0.2793])\n>>> us_orth = us.T @ us - np.eye(m)\n>>> orth_us = np.linalg.norm(us_orth, 'fro')\n>>> uu_orth = uu.T @ uu - np.eye(m)\n>>> orth_uu = np.linalg.norm(uu_orth, 'fro')\n>>> us1, us2 = us[:n, :], us[n:, :]\n>>> symp_us = us1.T @ us2 - us2.T @ us1\n>>> symp_us_norm = np.linalg.norm(symp_us, 'fro')\n>>> uu1, uu2 = uu[:n, :], uu[n:, :]\n>>> symp_uu = uu1.T @ uu2 - uu2.T @ uu1\n>>> symp_uu_norm = np.linalg.norm(symp_uu, 'fro')\n>>> info\n0",
  "mb04ad": "Compute eigenvalues of skew-Hamiltonian/Hamiltonian pencil.\n\nComputes eigenvalues of a real N-by-N skew-Hamiltonian/Hamiltonian pencil\naS - bH with S = T Z = J Z' J' Z using generalized symplectic URV\ndecomposition. Optionally computes orthogonal transformation matrices.\n\nParameters:\n  job (str): 'E'=eigenvalues only, 'T'=also compute triangular T\n  compq1 (str): 'N'=no Q1, 'I'=init identity, 'U'=update Q1\n  compq2 (str): 'N'=no Q2, 'I'=init identity, 'U'=update Q2\n  compu1 (str): 'N'=no U1, 'I'=init identity, 'U'=update U1\n  compu2 (str): 'N'=no U2, 'I'=init identity, 'U'=update U2\n  z (ndarray): Z matrix from skew-Hamiltonian S = T Z (n x n, F-order)\n  h (ndarray): Hamiltonian matrix H (n x n, F-order)\n  q1 (ndarray, optional): Orthogonal Q1 matrix (n x n, F-order)\n  q2 (ndarray, optional): Orthogonal Q2 matrix (n x n, F-order)\n  u11 (ndarray, optional): Symplectic U1 block (n/2 x n/2, F-order)\n  u12 (ndarray, optional): Symplectic U1 block (n/2 x n/2, F-order)\n  u21 (ndarray, optional): Symplectic U2 block (n/2 x n/2, F-order)\n  u22 (ndarray, optional): Symplectic U2 block (n/2 x n/2, F-order)\n\nReturns:\n  (t, z, h, q1, q2, u11, u12, u21, u22, alphar, alphai, beta, info):\n    t: Upper triangular factor T (n x n)\n    z: Transformed Z matrix (n x n)\n    h: Transformed H matrix (n x n)\n    q1, q2: Orthogonal matrices (n x n)\n    u11, u12, u21, u22: Symplectic transformation blocks (n/2 x n/2)\n    alphar, alphai, beta: Generalized eigenvalues (n/2,)\n    info: 0=success, 3=QZ did not converge\n\nExamples:\n\n>>> from slicot import mb04ad\n>>> import numpy as np\n>>> n = 8\n>>> m = n // 2\n>>> z = np.array([\n...     [3.1472, 4.5751, -0.7824, 1.7874, -2.2308, -0.6126, 2.0936, 4.5974],\n...     [4.0579, 4.6489, 4.1574, 2.5774, -4.5383, -1.1844, 2.5469, -1.5961],\n...     [-3.7301, -3.4239, 2.9221, 2.4313, -4.0287, 2.6552, -2.2397, 0.8527],\n...     [4.1338, 4.7059, 4.5949, -1.0777, 3.2346, 2.9520, 1.7970, -2.7619],\n...     [1.3236, 4.5717, 1.5574, 1.5548, 1.9483, -3.1313, 1.5510, 2.5127],\n...     [-4.0246, -0.1462, -4.6429, -3.2881, -1.8290, -0.1024, -3.3739, -2.4490],\n...     [-2.2150, 3.0028, 3.4913, 2.0605, 4.5022, -0.5441, -3.8100, 0.0596],\n...     [0.4688, -3.5811, 4.3399, -4.6817, -4.6555, 1.4631, -0.0164, 1.9908],\n...     ], dtype=float, order='F')\n>>> h = np.array([\n...     [3.9090, -3.5071, 3.1428, -3.0340, -1.4834, 3.7401, -0.1715, 0.4026],\n...     [4.5929, -2.4249, -2.5648, -2.4892, 3.7401, -2.1416, 1.6251, 2.6645],\n...     [0.4722, 3.4072, 4.2926, 1.1604, -0.1715, 1.6251, -4.2415, -0.0602],\n...     [-3.6138, -2.4572, -1.5002, -0.2671, 0.4026, 2.6645, -0.0602, -3.7009],\n...     [0.6882, -1.8421, -4.1122, 0.1317, -3.9090, -4.5929, -0.4722, 3.6138],\n...     [-1.8421, 2.9428, -0.4340, 1.3834, 3.5071, 2.4249, -3.4072, 2.4572],\n...     [-4.1122, -0.4340, -2.3703, 0.5231, -3.1428, 2.5648, -4.2926, 1.5002],\n...     [0.1317, 1.3834, 0.5231, -4.1618, 3.0340, 2.4892, -1.1604, 0.2671],\n...     ], dtype=float, order='F')\n>>> result = mb04ad('T', 'I', 'I', 'I', 'I', z, h)\n>>> t_out, z_out, h_out, q1, q2, u11, u12, u21, u22, alphar, alphai, beta, info = result",
  "mb04az": "Eigenvalues of complex skew-Hamiltonian/Hamiltonian pencil.\n\nComputes eigenvalues of a complex N-by-N skew-Hamiltonian/Hamiltonian\npencil aS - bH, with S = J*Z^H*J^T*Z and H = [[B,F],[G,-B^H]].\n\nParameters:\n  job (str): 'E'=eigenvalues only, 'T'=Schur form and eigenvalues\n  compq (str): 'N'=no Q, 'C'=compute Q\n  compu (str): 'N'=no U, 'C'=compute U\n  z (ndarray): Complex N-by-N matrix Z (F-order)\n  b (ndarray): Complex M-by-M matrix B, M=N/2 (F-order)\n  fg (ndarray): Complex M-by-(M+1) with F diagonal and G upper (F-order)\n\nReturns:\n  For JOB='E': (alphar, alphai, beta, info)\n  For JOB='T': (z, b, fg, d, c, q, u, alphar, alphai, beta, info)\n    z: Transformed Z matrix (N x N)\n    b: Transformed B matrix (N x N)\n    fg: Transformed FG matrix (N x N)\n    d: D matrix (N x N)\n    c: C matrix (N x N)\n    q: Unitary Q matrix (2N x 2N) if COMPQ='C'\n    u: Unitary U matrix (N x 2N) if COMPU='C'\n    alphar, alphai, beta: Generalized eigenvalues (N,)\n    info: 0=success, positive=failure\n\nExamples:\n\n>>> from slicot import mb04az\n>>> import numpy as np\n>>> n = 4\n>>> m = n // 2\n>>> z = np.array([\n...     [0.4941+0.8054j, 0.8909+0.8865j, 0.0305+0.9786j, 0.9047+0.0596j],\n...     [0.7790+0.5767j, 0.3341+0.0286j, 0.7440+0.7126j, 0.6098+0.6819j],\n...     [0.7150+0.1829j, 0.6987+0.4899j, 0.5000+0.5004j, 0.6176+0.0424j],\n...     [0.9037+0.2399j, 0.1978+0.1679j, 0.4799+0.4710j, 0.8594+0.0714j],\n...     ], order='F', dtype=complex)\n>>> b_in = np.array([\n...     [0.5216+0.7224j, 0.8181+0.6596j],\n...     [0.0967+0.1498j, 0.8175+0.5185j],\n...     ], order='F', dtype=complex)\n>>> fg_in = np.array([\n...     [0.9729+0.0j, 0.8003+0.0j, 0.4323+0.8313j],\n...     [0.6489+0.1331j, 0.4537+0.0j, 0.8253+0.0j],\n...     ], order='F', dtype=complex)\n>>> result = mb04az('T', 'C', 'C', z, b_in, fg_in)\n>>> z_out, b_out, fg_out, d, c, q, u, alphar, alphai, beta, info = result",
  "mb04bd": "Eigenvalues of skew-Hamiltonian/Hamiltonian pencil.\n\nComputes eigenvalues of a real N-by-N skew-Hamiltonian/Hamiltonian pencil\naS - bH with\n      (  A  D  )         (  C  V  )\n  S = (        ) and H = (        )\n      (  E  A' )         (  W -C' )\n\nParameters:\n  job (str): 'E'=eigenvalues only, 'T'=triangular form and eigenvalues\n  compq1 (str): 'N'=no Q1, 'I'=init identity, 'U'=update Q1\n  compq2 (str): 'N'=no Q2, 'I'=init identity, 'U'=update Q2\n  a (ndarray): Matrix A (n/2 x n/2, F-order)\n  de (ndarray): Matrix containing E (lower) and D (upper) (n/2 x n/2+1, F-order)\n  c1 (ndarray): Matrix C1=C (n/2 x n/2, F-order)\n  vw (ndarray): Matrix containing W (lower) and V (upper) (n/2 x n/2+1, F-order)\n  q1 (ndarray, optional): Orthogonal Q1 matrix (n x n, F-order, for COMPQ1='U')\n\nReturns:\n  (a, de, c1, vw, q1, q2, b, f, c2, alphar, alphai, beta, info):\n    a, de, c1, vw: Transformed input matrices\n    q1: Orthogonal transformation Q1 (n x n)\n    q2: Orthogonal transformation Q2 (n x n)\n    b: Output matrix B (n/2 x n/2)\n    f: Skew-symmetric matrix F (n/2 x n/2)\n    c2: Output matrix C2 (n/2 x n/2)\n    alphar, alphai, beta: Generalized eigenvalues (n/2,)\n    info: 0=success, 1=eigenvalue problem, 2=QZ failed, 3=warning\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04bd\n>>> n = 8\n>>> m = n // 2\n>>> a = np.array([\n...     [3.1472,  1.3236,  4.5751,  4.5717],\n...     [4.0579, -4.0246,  4.6489, -0.1462],\n...     [-3.7301, -2.2150, -3.4239,  3.0028],\n...     [4.1338,  0.4688,  4.7059, -3.5811]\n...     ], order='F', dtype=float)\n>>> de = np.array([\n...     [0.0000,  0.0000, -1.5510, -4.5974, -2.5127],\n...     [3.5071,  0.0000,  0.0000,  1.5961,  2.4490],\n...     [-3.1428,  2.5648,  0.0000,  0.0000, -0.0596],\n...     [3.0340,  2.4892, -1.1604,  0.0000,  0.0000]\n...     ], order='F', dtype=float)\n>>> c1 = np.array([\n...     [0.6882, -3.3782, -3.3435,  1.8921],\n...     [-0.3061,  2.9428,  1.0198,  2.4815],\n...     [-4.8810, -1.8878, -2.3703, -0.4946],\n...     [-1.6288,  0.2853,  1.5408, -4.1618]\n...     ], order='F', dtype=float)\n>>> vw = np.array([\n...     [-2.4013, -2.7102,  0.3834, -3.9335,  3.1730],\n...     [-3.1815, -2.3620,  4.9613,  4.6190,  3.6869],\n...     [3.6929,  0.7970,  0.4986, -4.9537, -4.1556],\n...     [3.5303,  1.2206, -1.4905,  0.1325, -1.0022]\n...     ], order='F', dtype=float)\n>>> result = mb04bd('T', 'I', 'I', a, de, c1, vw)\n>>> (a_out, de_out, c1_out, vw_out, q1, q2, b, f, c2,\n...     alphar, alphai, beta, info) = result\n>>> m = n // 2",
  "mb04bp": "Eigenvalues of skew-Hamiltonian/Hamiltonian pencil (block algorithm).\n\nBlock algorithm variant of MB04BD for better performance on large matrices.\nComputes eigenvalues of a real N-by-N skew-Hamiltonian/Hamiltonian pencil\naS - bH. For small N (<=250), delegates to MB04BD.\n\nSame interface and output as MB04BD.\n\nParameters:\n  job (str): 'E'=eigenvalues only, 'T'=triangular form and eigenvalues\n  compq1 (str): 'N'=no Q1, 'I'=init identity, 'U'=update Q1\n  compq2 (str): 'N'=no Q2, 'I'=init identity, 'U'=update Q2\n  a (ndarray): Matrix A (n/2 x n/2, F-order)\n  de (ndarray): Matrix containing E (lower) and D (upper) (n/2 x n/2+1, F-order)\n  c1 (ndarray): Matrix C1=C (n/2 x n/2, F-order)\n  vw (ndarray): Matrix containing W (lower) and V (upper) (n/2 x n/2+1, F-order)\n  q1 (ndarray, optional): Orthogonal Q1 matrix (n x n, F-order, for COMPQ1='U')\n\nReturns:\n  (a, de, c1, vw, q1, q2, b, f, c2, alphar, alphai, beta, info):\n    a, de, c1, vw: Transformed input matrices\n    q1: Orthogonal transformation Q1 (n x n)\n    q2: Orthogonal transformation Q2 (n x n)\n    b: Output matrix B (n/2 x n/2)\n    f: Skew-symmetric matrix F (n/2 x n/2)\n    c2: Output matrix C2 (n/2 x n/2)\n    alphar, alphai, beta: Generalized eigenvalues (n/2,)\n    info: 0=success, 1=eigenvalue problem, 2=QZ failed, 3=warning\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04bp\n>>> a = np.array([\n...     [3.1472,  1.3236,  4.5751,  4.5717],\n...     [4.0579, -4.0246,  4.6489, -0.1462],\n...     [-3.7301, -2.2150, -3.4239,  3.0028],\n...     [4.1338,  0.4688,  4.7059, -3.5811]\n...     ], dtype=float, order='F')\n>>> de = np.array([\n...     [0.0000,  0.0000, -1.5510, -4.5974, -2.5127],\n...     [3.5071,  0.0000,  0.0000,  1.5961,  2.4490],\n...     [-3.1428,  2.5648,  0.0000,  0.0000, -0.0596],\n...     [3.0340,  2.4892, -1.1604,  0.0000,  0.0000]\n...     ], dtype=float, order='F')\n>>> c1 = np.array([\n...     [0.6882, -3.3782, -3.3435,  1.8921],\n...     [-0.3061,  2.9428,  1.0198,  2.4815],\n...     [-4.8810, -1.8878, -2.3703, -0.4946],\n...     [-1.6288,  0.2853,  1.5408, -4.1618]\n...     ], dtype=float, order='F')\n>>> vw = np.array([\n...     [-2.4013, -2.7102,  0.3834, -3.9335,  3.1730],\n...     [-3.1815, -2.3620,  4.9613,  4.6190,  3.6869],\n...     [3.6929,  0.7970,  0.4986, -4.9537, -4.1556],\n...     [3.5303,  1.2206, -1.4905,  0.1325, -1.0022]\n...     ], dtype=float, order='F')\n>>> result = mb04bp('T', 'I', 'I', a, de, c1, vw)\n>>> a_out, de_out, c1_out, vw_out, q1, q2, b, f, c2, alphar, alphai, beta, info = result\n>>> m = 4\n>>> n = 8",
  "mb04bz": "Eigenvalues of complex skew-Hamiltonian/Hamiltonian pencil.\n\nComputes eigenvalues of a complex N-by-N skew-Hamiltonian/Hamiltonian\npencil aS - bH, with S = [[A,D],[E,A^H]] and H = [[B,F],[G,-B^H]],\nusing an embedding to a real skew-Hamiltonian/skew-Hamiltonian pencil.\n\nParameters:\n  job (str): 'E'=eigenvalues only, 'T'=Schur form and eigenvalues\n  compq (str): 'N'=no Q, 'C'=compute unitary Q\n  a (ndarray): Complex N/2-by-N/2 matrix A (F-order)\n  de (ndarray): Complex N/2-by-(N/2+1) with E (lower) and D (upper) (F-order)\n  b (ndarray): Complex N/2-by-N/2 matrix B (F-order)\n  fg (ndarray): Complex N/2-by-(N/2+1) with G (lower) and F (upper) (F-order)\n\nReturns:\n  For JOB='E' COMPQ='N': (alphar, alphai, beta, info)\n  For JOB='T' COMPQ='N': (a, de, b, fg, alphar, alphai, beta, info)\n  For JOB='T' COMPQ='C': (a, de, b, fg, q, alphar, alphai, beta, info)\n    a: Upper triangular BA matrix (N x N)\n    de: Skew-Hermitian BD matrix (N x N)\n    b: Upper triangular BB matrix (N x N)\n    fg: Hermitian BF matrix (N x N)\n    q: Unitary Q matrix (2N x 2N)\n    alphar, alphai, beta: Generalized eigenvalues (N,)\n    info: 0=success, 1=MB04FD QZ failed, 2=ZHGEQZ failed, 3=pencil singular\n\nExamples:\n\n>>> from slicot import mb04bz\n>>> import numpy as np\n>>> n = 4\n>>> m = n // 2\n>>> a = np.array([\n...     [0.0604+0.6568j, 0.5268+0.2919j],\n...     [0.3992+0.6279j, 0.4167+0.4316j],\n...     ], order='F', dtype=complex)\n>>> de = np.array([\n...     [0+0.4896j, 0+0.9516j, 0.3724+0.0526j],\n...     [0.9840+0.3394j, 0+0.9203j, 0+0.7378j],\n...     ], order='F', dtype=complex)\n>>> b_in = np.array([\n...     [0.2691+0.4177j, 0.5478+0.3014j],\n...     [0.4228+0.9830j, 0.9427+0.7010j],\n...     ], order='F', dtype=complex)\n>>> fg = np.array([\n...     [0.6663+0j, 0.6981+0j, 0.1781+0.8818j],\n...     [0.5391+0.1711j, 0.6665+0j, 0.1280+0j],\n...     ], order='F', dtype=complex)\n>>> result = mb04bz('T', 'C', a, de, b_in, fg)\n>>> a_out, de_out, b_out, fg_out, q, alphar, alphai, beta, info = result\n>>> eigenvalues = (alphar + 1j * alphai) / beta",
  "mb04cd": "Reduce skew-Hamiltonian/Hamiltonian pencil to generalized Schur form.\n\nComputes transformed matrices A, B and D using orthogonal matrices Q1, Q2, Q3\nfor a real N-by-N regular pencil aA*B - bD where:\n- A11, A22, B11, B22, D12 are upper triangular\n- D21 is upper quasi-triangular\n- The transformed pencil is in generalized Schur form\n\nParameters:\n  compq1 (str): Q1 computation: 'N'=none, 'I'=init, 'U'=update\n  compq2 (str): Q2 computation: 'N'=none, 'I'=init, 'U'=update\n  compq3 (str): Q3 computation: 'N'=none, 'I'=init, 'U'=update\n  a (ndarray): N-by-N matrix A (F-order)\n  b (ndarray): N-by-N matrix B (F-order)\n  d (ndarray): N-by-N matrix D (F-order)\n  q1 (ndarray, optional): N-by-N matrix Q1 for update mode (F-order)\n  q2 (ndarray, optional): N-by-N matrix Q2 for update mode (F-order)\n  q3 (ndarray, optional): N-by-N matrix Q3 for update mode (F-order)\n\nReturns:\n  (a, b, d, q1, q2, q3, info): Transformed matrices, orthogonal Q matrices, exit code\n  info=0: success, info=1-4: algorithm warnings\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04cd\n>>> n = 4\n>>> m = n // 2\n>>> a11 = np.triu(np.random.randn(m, m))\n>>> a22 = np.triu(np.random.randn(m, m))\n>>> a = np.zeros((n, n), order='F', dtype=float)\n>>> a[:m, :m] = a11\n>>> a[m:, m:] = a22\n>>> b11 = np.triu(np.random.randn(m, m))\n>>> b22 = np.triu(np.random.randn(m, m))\n>>> b = np.zeros((n, n), order='F', dtype=float)\n>>> b[:m, :m] = b11\n>>> b[m:, m:] = b22\n>>> d12 = np.triu(np.random.randn(m, m))\n>>> d21 = np.triu(np.random.randn(m, m))\n>>> d = np.zeros((n, n), order='F', dtype=float)\n>>> d[:m, m:] = d12\n>>> d[m:, :m] = d21\n>>> result = mb04cd('I', 'I', 'I', a, b, d)\n>>> a_out, b_out, d_out, q1, q2, q3, info = result",
  "mb04db": "Apply inverse balancing transformation to [V1; sgn*V2].\n\nApplies from the left the inverse of a balancing transformation\ncomputed by MB04DP to the matrix [V1; sgn*V2].\n\nParameters:\n  job (str): 'N'=none, 'P'=permute only, 'S'=scale only, 'B'=both\n  sgn (str): 'P'=sgn=+1, 'N'=sgn=-1\n  ilo (int): ILO from MB04DP (1 <= ilo <= n+1)\n  lscale (ndarray): Left scaling factors from MB04DP (n,)\n  rscale (ndarray): Right scaling factors from MB04DP (n,)\n  v1 (ndarray): N-by-M matrix V1 (F-order)\n  v2 (ndarray): N-by-M matrix V2 (F-order)\n\nReturns:\n  (v1, v2, info): Transformed matrices and exit code\n\nExamples:\n\n>>> from slicot import mb04db\n>>> import numpy as np\n>>> n = 4\n>>> m = 3\n>>> ilo = 1\n>>> v1 = np.random.randn(n, m).astype(float, order='F')\n>>> v2 = np.random.randn(n, m).astype(float, order='F')\n>>> lscale = np.ones(n, dtype=float)\n>>> rscale = np.ones(n, dtype=float)\n>>> v1_out, v2_out, info = mb04db('N', 'P', ilo, lscale, rscale, v1, v2)\n>>> info\n0",
  "mb04dd": "Balance a real Hamiltonian matrix.\n\nParameters:\n  job (str): 'N' = none, 'P' = permute, 'S' = scale, 'B' = both\n  a (ndarray): N-by-N matrix A (F-order)\n  qg (ndarray): N-by-(N+1) matrix with lower tri Q, upper tri G\n\nReturns:\n  (a, qg, ilo, scale, info): Balanced matrices and scaling info\n\nExamples:\n\n>>> from slicot import mb04dd\n>>> import numpy as np\n>>> n = 4\n>>> a = np.random.randn(n, n).astype(float, order='F')\n>>> qg = np.random.randn(n, n + 1).astype(float, order='F')\n>>> a_out, qg_out, ilo, scale, info = mb04dd('N', a, qg)\n>>> info\n0",
  "mb04di": "Apply inverse balancing transformation to [V1; sgn*V2].\n\nApplies the inverse of a balancing transformation computed by MB04DD\nor MB04DS to the matrix [V1; sgn*V2] where sgn is +1 or -1.\n\nParameters:\n  job (str): 'N'=none, 'P'=permute only, 'S'=scale only, 'B'=both\n  sgn (str): 'P'=sgn=+1, 'N'=sgn=-1\n  ilo (int): ILO from MB04DD or MB04DS (1 <= ilo <= n+1)\n  scale (ndarray): Scaling factors from MB04DD or MB04DS (n,)\n  v1 (ndarray): N-by-M matrix V1 (F-order)\n  v2 (ndarray): N-by-M matrix V2 (F-order)\n\nReturns:\n  (v1, v2, info): Transformed matrices and exit code\n\nExamples:\n\n>>> from slicot import mb04di\n>>> import numpy as np\n>>> n = 4\n>>> m = 3\n>>> ilo = 2\n>>> scale = np.array([5.0, 1.0, 2.0, 0.5], order='F', dtype=float)\n>>> v1 = np.random.randn(n, m).astype(float, order='F')\n>>> v2 = np.random.randn(n, m).astype(float, order='F')\n>>> v1_out, v2_out, info = mb04di('N', 'P', ilo, scale, v1, v2)\n>>> info\n0",
  "mb04dl": "Balance a real matrix pencil (A, B).\n\nBalances a pair of N-by-N real matrices (A,B) by permuting to isolate\neigenvalues and applying diagonal equivalence transformations.\n\nParameters:\n  job (str): 'N'=none, 'P'=permute only, 'S'=scale only, 'B'=both\n  n (int): Order of matrices A and B\n  thresh (float): Threshold for scaling (>=0 fixed, <0 automatic)\n  a (ndarray): N-by-N matrix A (F-order, modified in place)\n  b (ndarray): N-by-N matrix B (F-order, modified in place)\n\nReturns:\n  (a, b, ilo, ihi, lscale, rscale, dwork, iwarn, info):\n    Balanced matrices, indices, scaling factors, workspace, and exit codes\n\nExamples:\n\n>>> from slicot import mb04dl\n>>> import numpy as np\n>>> n = 4\n>>> a = np.array([\n...     [1.0, 0.0, -1e-12, 0.0],\n...     [0.0, -2.0, 0.0, 0.0],\n...     [-1.0, -1.0, -1.0, 0.0],\n...     [-1.0, -1.0, 0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 0.0],\n...     [0.0, 0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a_out, b_out, ilo, ihi, lscale, rscale, dwork, iwarn, info = mb04dl(\n...     'B', n, -3.0, a, b\n...     )\n>>> info\n0",
  "mb04dp": "Balance a real skew-Hamiltonian/Hamiltonian pencil.\n\nBalances the pencil aS - bH where S=[[A,D],[E,A']] (skew-Hamiltonian)\nand H=[[C,V],[W,-C']] (Hamiltonian), with D,E skew-symmetric and V,W symmetric.\n\nParameters:\n  job (str): 'N'=none, 'P'=permute only, 'S'=scale only, 'B'=both\n  n (int): Order of matrices A, D, E, C, V, W\n  thresh (float): Threshold for scaling (>=0 fixed, <0 automatic)\n  a (ndarray): N-by-N matrix A (F-order, modified in place)\n  de (ndarray): N-by-(N+1) array with E (lower) and D (upper) (F-order)\n  c (ndarray): N-by-N matrix C (F-order, modified in place)\n  vw (ndarray): N-by-(N+1) array with W (lower) and V (upper) (F-order)\n\nReturns:\n  (a, de, c, vw, ilo, lscale, rscale, dwork, iwarn, info):\n    Balanced matrices, ILO, scaling factors, workspace, and exit codes\n\nExamples:\n\n>>> from slicot import mb04dp\n>>> import numpy as np\n>>> n = 2\n>>> a = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> de = np.array([\n...     [0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0],\n...     [0.0, -2.0]\n...     ], order='F', dtype=float)\n>>> vw = np.array([\n...     [-1.0, -1e-12, 0.0],\n...     [-1.0, -1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> a_out, de_out, c_out, vw_out, ilo, lscale, rscale, dwork, iwarn, info = mb04dp(\n...     'B', n, -3.0, a, de, c, vw\n...     )\n>>> info\n0",
  "mb04ds": "Balance a real skew-Hamiltonian matrix.\n\nBalances a 2N-by-2N skew-Hamiltonian matrix S = [[A,G],[Q,A']] where\nA is N-by-N and G, Q are N-by-N skew-symmetric matrices.\n\nParameters:\n  job (str): 'N'=none, 'P'=permute only, 'S'=scale only, 'B'=both\n  n (int): Order of matrix A (n >= 0)\n  a (ndarray): N-by-N matrix A (F-order, modified in place)\n  qg (ndarray): N-by-(N+1) array with Q (strictly lower, cols 1:N)\n                and G (strictly upper, cols 2:N+1) (F-order)\n\nReturns:\n  (a, qg, ilo, scale, info):\n    Balanced matrices, ILO (number of deflated eigenvalues + 1),\n    scaling factors, and exit code\n\nExamples:\n\n>>> from slicot import mb04ds\n>>> import numpy as np\n>>> n = 6\n>>> a = np.array([\n...     [0.0576, 0.0, 0.5208, 0.0, 0.7275, -0.7839],\n...     [0.1901, 0.0439, 0.1663, 0.0928, 0.6756, -0.5030],\n...     [0.5962, 0.0, 0.4418, 0.0, -0.5955, 0.7176],\n...     [0.5869, 0.0, 0.3939, 0.0353, 0.6992, -0.0147],\n...     [0.2222, 0.0, -0.3663, 0.0, 0.5548, -0.4608],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 0.1338]\n...     ], order='F', dtype=float)\n>>> qg = np.array([\n...     [0.0, 0.0, -0.9862, -0.4544, -0.4733, 0.4435, 0.0],\n...     [0.0, 0.0, 0.0, -0.6927, 0.6641, 0.4453, 0.0],\n...     [-0.3676, 0.0, 0.0, 0.0, 0.0841, 0.3533, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0877, 0.0],\n...     [0.9561, 0.0, 0.4784, 0.0, 0.0, 0.0, 0.0],\n...     [-0.0164, -0.4514, -0.8289, -0.6831, -0.1536, 0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> a_out, qg_out, ilo, scale, info = mb04ds('B', n, a, qg)\n>>> info\n0",
  "mb04dy": "Symplectic scaling of a Hamiltonian matrix.\n\nPerforms symplectic scaling on a Hamiltonian matrix H = [[A,G],[Q,-A']]\nwhere A is N-by-N and G, Q are symmetric N-by-N matrices.\n\nScaling strategies:\n  'S': Symplectic scaling using DGEBAL + equilibration\n  '1'/'O': 1-norm scaling by power of machine base\n  'N': No scaling\n\nParameters:\n  jobscl (str): 'S'=symplectic, '1'/'O'=1-norm, 'N'=none\n  a (ndarray): N-by-N matrix A (F-order, modified in place)\n  qg (ndarray): N-by-(N+1) array with Q (lower tri, cols 0:N-1)\n                and G (upper tri, cols 1:N) (F-order)\n\nReturns:\n  (a, qg, d, info):\n    Scaled matrices, scaling factors (N for 'S', 1 for '1'/'O'),\n    and exit code\n\nExamples:\n\n>>> from slicot import mb04dy\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([\n...     [-0.4,   0.05,   0.0007],\n...     [-4.7,   0.8,    0.025],\n...     [81.0,  29.0,   -0.9]\n...     ], order='F', dtype=float)\n>>> qg = np.zeros((n, n + 1), order='F', dtype=float)\n>>> qg[0, 1] = 0.0034\n>>> qg[0, 2] = 0.0014\n>>> qg[0, 3] = 0.00077\n>>> qg[1, 2] = -0.005\n>>> qg[1, 3] = 0.0004\n>>> qg[2, 3] = 0.003\n>>> qg[0, 0] = -18.0\n>>> qg[1, 0] = -12.0\n>>> qg[2, 0] = 43.0\n>>> qg[1, 1] = 99.0\n>>> qg[2, 1] = 420.0\n>>> qg[2, 2] = -200.0\n>>> q_full = np.zeros((n, n), dtype=float)\n>>> g_full = np.zeros((n, n), dtype=float)\n...     q_full[i, j] = qg[i, j]\n...     q_full[j, i] = qg[i, j]\n...     g_full[i, j] = qg[i, j + 1]\n...     g_full[j, i] = qg[i, j + 1]\n>>> a_out, qg_out, d, info = mb04dy('S', a.copy(), qg.copy())\n>>> q_scaled = np.zeros((n, n), dtype=float)\n>>> g_scaled = np.zeros((n, n), dtype=float)\n...     q_scaled[i, j] = qg_out[i, j]\n...     q_scaled[j, i] = qg_out[i, j]\n...     g_scaled[i, j] = qg_out[i, j + 1]\n...     g_scaled[j, i] = qg_out[i, j + 1]\n>>> h_scaled = np.zeros((2*n, 2*n), dtype=float)\n>>> h_scaled[:n, :n] = a_out\n>>> h_scaled[:n, n:] = g_scaled\n>>> h_scaled[n:, :n] = q_scaled\n>>> h_scaled[n:, n:] = -a_out.T\n>>> D_full = np.diag(np.concatenate([d, 1.0 / d]))\n>>> D_inv = np.diag(np.concatenate([1.0 / d, d]))\n>>> h_reconstructed = D_full @ h_scaled @ D_inv\n>>> eig_reconstructed = np.linalg.eigvals(h_reconstructed)\n>>> eig_reconstructed_sorted = sorted(eig_reconstructed, key=lambda x: (x.real, x.imag))\n...     np.array(eig_reconstructed_sorted),\n...     rtol=1e-10, atol=1e-12\n>>> )\n>>> info\n0",
  "mb04dz": "Balance a complex Hamiltonian matrix.\n\nBalances a complex Hamiltonian matrix H = [[A,G],[Q,-A^H]] where A is NxN\nand G, Q are NxN Hermitian matrices. Involves permuting to isolate\neigenvalues and diagonal similarity transformations.\n\nParameters:\n  job (str): 'N'=none, 'P'=permute only, 'S'=scale only, 'B'=both\n  a (ndarray): N-by-N complex matrix A (F-order, modified in place)\n  qg (ndarray): N-by-(N+1) complex array with lower tri of Q and\n                upper tri of G (F-order, modified in place)\n\nReturns:\n  (a, qg, ilo, scale, info):\n    Balanced matrices, ILO (number of deflated eigenvalues + 1),\n    scaling factors (real array), and exit code\n\nExamples:\n\n>>> from slicot import mb04dz\n>>> import numpy as np\n>>> n = 6\n>>> a = np.array([\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [0.0994+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.9696+0.0j],\n...     [0.3248+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.4372+0.0j, 0.8308+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0717+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.1976+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j]\n...     ], order='F', dtype=complex)\n>>> qg = np.array([\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0651+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 0.0444+0.0j, 0.0+0.0j, 0.0+0.0j, 0.1957+0.0j, 0.0+0.0j],\n...     [0.8144+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.3652+0.0j, 0.0+0.0j, 0.9121+0.0j],\n...     [0.9023+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 1.0945+0.0j]\n...     ], order='F', dtype=complex)\n>>> a_out, qg_out, ilo, scale, info = mb04dz('B', a, qg)\n>>> info\n0",
  "mb04ed": "Eigenvalues of skew-Hamiltonian/skew-Hamiltonian pencil.\n\nComputes eigenvalues of aS - bT where S = J*Z'*J'*Z and T = [[B,F],[G,B']]\nwith J = [[0,I],[-I,0]]. Optionally computes structured Schur form.\n\nParameters:\n  job (str): 'E'=eigenvalues only, 'T'=also structured Schur form\n  compq (str): 'N'=don't compute Q, 'I'=initialize and compute Q\n  compu (str): 'N'=don't compute U, 'I'=init U, 'U'=update U0\n  z (ndarray): N-by-N matrix Z (F-order)\n  b (ndarray): N/2-by-N/2 matrix B (F-order)\n  fg (ndarray): N/2-by-(N/2+1) array with G (strictly lower) and F (strictly upper)\n  u1 (ndarray, optional): N/2-by-N/2 for COMPU='U'\n  u2 (ndarray, optional): N/2-by-N/2 for COMPU='U'\n\nReturns:\n  (z, b, fg, q, u1, u2, alphar, alphai, beta, info):\n    Transformed matrices, orthogonal Q, symplectic U blocks,\n    eigenvalue components (lambda = (alphar+alphai*j)/beta), info\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04ed\n>>> n = 8\n>>> m = n // 2  # m = 4\n>>> z = np.array([\n...     [0.0949, 3.3613, -4.7663, -0.5534, 0.6408, -3.2793, 3.4253, 2.9654],\n...     [0.1138, -1.5903, 2.1837, -4.1648, -4.3775, -1.7454, 0.1744, 2.3262],\n...     [2.7505, 4.4048, 4.4183, 3.0478, 2.7728, 2.3048, -0.6451, -1.2045],\n...     [3.6091, -4.1716, 3.4461, 3.6880, -0.0985, 3.8458, 0.2528, -1.3859],\n...     [0.4352, -3.2829, 3.7246, 0.4794, -0.3690, -1.5562, -3.4817, -2.2902],\n...     [1.3080, -3.9881, -3.5497, 3.5020, 2.2582, 4.4764, -4.4080, -1.6818],\n...     [1.1308, -1.5087, 2.4730, 2.1553, -1.7129, -4.8669, -2.4102, 4.2274],\n...     [4.7933, -4.3671, -0.0473, -2.0092, 1.2439, -4.7385, 3.4242, -0.2764]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [2.0936, 1.5510, 4.5974, 2.5127],\n...     [2.5469, -3.3739, -1.5961, -2.4490],\n...     [-2.2397, -3.8100, 0.8527, 0.0596],\n...     [1.7970, -0.0164, -2.7619, 1.9908]\n...     ], order='F', dtype=float)\n>>> fg = np.array([\n...     [1.0000, 2.0000, -4.0500, 1.3353, 0.2899],\n...     [-0.4318, 2.0000, 2.0000, -2.9860, -0.0160],\n...     [1.0241, 0.9469, 2.0000, 2.0000, 1.3303],\n...     [0.0946, -0.1272, -4.4003, 2.0000, 2.0000]\n...     ], order='F', dtype=float)\n>>> z_out, b_out, fg_out, q_out, u1_out, u2_out, alphar, alphai, beta, info = mb04ed(\n...     'T', 'I', 'I', z, b, fg\n...     )\n>>> qtq = q_out.T @ q_out\n>>> u = np.zeros((n, n), order='F', dtype=float)\n>>> u[:m, :m] = u1_out\n>>> u[:m, m:] = u2_out\n>>> u[m:, :m] = -u2_out\n>>> u[m:, m:] = u1_out\n>>> utu = u.T @ u\n>>> info\n0",
  "mb04fd": "Eigenvalues of skew-Hamiltonian/skew-Hamiltonian pencil (real).\n\nComputes eigenvalues of aS - bT where S = [[A,D],[E,A']] and T = [[B,F],[G,B']]\nwith D, E, F, G skew-symmetric. Optionally computes structured Schur form.\n\nParameters:\n  job (str): 'E'=eigenvalues only, 'T'=also structured Schur form\n  compq (str): 'N'=don't compute Q, 'I'=initialize and compute Q, 'U'=update Q\n  a (ndarray): N/2-by-N/2 matrix A (F-order)\n  de (ndarray): N/2-by-(N/2+1) array with E (strictly lower) and D (strictly upper)\n  b (ndarray): N/2-by-N/2 matrix B (F-order)\n  fg (ndarray): N/2-by-(N/2+1) array with G (strictly lower) and F (strictly upper)\n  q (ndarray, optional): N-by-N orthogonal matrix Q for COMPQ='U'\n  n (int, optional): Order of pencil (must be even, default from matrix sizes)\n\nReturns:\n  (a, de, b, fg, q, alphar, alphai, beta, info):\n    Transformed matrices, orthogonal Q,\n    eigenvalue components (lambda = (alphar+alphai*j)/beta), info\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04fd\n>>> n = 8\n>>> m = n // 2  # m = 4\n>>> a = np.array([\n...     [0.8147, 0.6323, 0.9575, 0.9571],\n...     [0.9057, 0.0975, 0.9648, 0.4853],\n...     [0.1269, 0.2784, 0.1576, 0.8002],\n...     [0.9133, 0.5468, 0.9705, 0.1418]\n...     ], order='F', dtype=float)\n>>> de = np.array([\n...     [0.4217, 0.6557, 0.6787, 0.6554, 0.2769],\n...     [0.9157, 0.0357, 0.7577, 0.1711, 0.0461],\n...     [0.7922, 0.8491, 0.7431, 0.7060, 0.0971],\n...     [0.9594, 0.9339, 0.3922, 0.0318, 0.8234]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.6948, 0.4387, 0.1868, 0.7093],\n...     [0.3170, 0.3815, 0.4897, 0.7546],\n...     [0.9502, 0.7655, 0.4455, 0.2760],\n...     [0.0344, 0.7951, 0.6463, 0.6797]\n...     ], order='F', dtype=float)\n>>> fg = np.array([\n...     [0.6550, 0.9597, 0.7512, 0.8909, 0.1492],\n...     [0.1626, 0.3403, 0.2550, 0.9592, 0.2575],\n...     [0.1189, 0.5852, 0.5059, 0.5472, 0.8407],\n...     [0.4983, 0.2238, 0.6990, 0.1386, 0.2542]\n...     ], order='F', dtype=float)\n>>> a_out, de_out, b_out, fg_out, q_out, alphar, alphai, beta, iwork, info = mb04fd(\n...     'T', 'I', a.copy(), de.copy(), b.copy(), fg.copy()\n...     )\n>>> eigenvalues_actual = np.sort(alphar / beta)\n>>> qtq = q_out.T @ q_out\n>>> info\n0",
  "mb04fp": "Eigenvalues of skew-Hamiltonian/skew-Hamiltonian pencil (panel-based).\n\nPanel-based version of MB04FD for better performance on large matrices.\nComputes eigenvalues of aS - bT where S = [[A,D],[E,A']] and T = [[B,F],[G,B']]\nwith D, E, F, G skew-symmetric. For small matrices (N/2 <= 32), delegates to MB04FD.\n\nParameters:\n  job (str): 'E'=eigenvalues only, 'T'=also structured Schur form\n  compq (str): 'N'=don't compute Q, 'I'=initialize and compute Q, 'U'=update Q\n  a (ndarray): N/2-by-N/2 matrix A (F-order)\n  de (ndarray): N/2-by-(N/2+1) array with E (strictly lower) and D (strictly upper)\n  b (ndarray): N/2-by-N/2 matrix B (F-order)\n  fg (ndarray): N/2-by-(N/2+1) array with G (strictly lower) and F (strictly upper)\n  q (ndarray, optional): N-by-N orthogonal matrix Q for COMPQ='U'\n  n (int, optional): Order of pencil (must be even, default from matrix sizes)\n\nReturns:\n  (a, de, b, fg, q, alphar, alphai, beta, iwork, info):\n    Transformed matrices, orthogonal Q,\n    eigenvalue components (lambda = (alphar+alphai*j)/beta),\n    iwork (inaccurate eigenvalue info), info\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04fp\n>>> n = 64\n>>> m = n // 2\n>>> a = np.random.randn(m, m).astype(float, order='F')\n>>> b = np.random.randn(m, m).astype(float, order='F')\n>>> de = make_skew_symmetric_storage(m)\n>>> fg = make_skew_symmetric_storage(m)\n>>> a_out, de_out, b_out, fg_out, q_out, alphar, alphai, beta, iwork, info = mb04fp(\n...     'T', 'I', a.copy(), de.copy(), b.copy(), fg.copy()\n...     )\n>>> qtq = q_out.T @ q_out\n>>> info\n0",
  "mb04gd": "RQ factorization with row pivoting.\n\nComputes P*A = R*Q where P is a permutation matrix, R is upper triangular\n(or trapezoidal if m >= n), and Q is orthogonal.\n\nParameters:\n  a (ndarray): M-by-N matrix A (F-order), modified in place\n  jpvt (ndarray): Pivot indices (M,), dtype=int32\n                  On entry: if jpvt[i] != 0, row i is constrained to bottom\n                  On exit: jpvt[i] = k means row i of P*A was row k of A\n\nReturns:\n  (a, jpvt, tau, info): Modified matrix, pivot indices, reflector factors, exit code\n\nExamples:\n\n>>> from slicot import mb04gd\n>>> import numpy as np\n>>> m = 6\n>>> n = 5\n>>> a = np.array([\n...     [1.0, 2.0, 6.0, 3.0, 5.0],\n...     [-2.0, -1.0, -1.0, 0.0, -2.0],\n...     [5.0, 5.0, 1.0, 5.0, 1.0],\n...     [-2.0, -1.0, -1.0, 0.0, -2.0],\n...     [4.0, 8.0, 4.0, 20.0, 4.0],\n...     [-2.0, -1.0, -1.0, 0.0, -2.0],\n...     ], dtype=float, order='F')\n>>> jpvt = np.array([0, 0, 0, 0, 0, 0], dtype=np.int32)\n>>> a_out, jpvt_out, tau, info = mb04gd(a, jpvt)\n>>> k = min(m, n)\n...     rtol=1e-3, atol=1e-3)\n>>> info\n0",
  "mb04hd": "Reduce skew-Hamiltonian/Hamiltonian pencil to generalized Schur form.\n\nReduces a special block (anti-)diagonal skew-Hamiltonian/Hamiltonian pencil\naAB - bBB with A = diag(A11,A22) and B = anti-diag(B21,B12) to generalized\nSchur form using orthogonal transformations Q1 and Q2.\n\nParameters:\n  compq1 (str): 'N'=no Q1, 'I'=initialize Q1, 'U'=update Q1\n  compq2 (str): 'N'=no Q2, 'I'=initialize Q2, 'U'=update Q2\n  a (ndarray): N-by-N matrix A with block diagonal structure (F-order)\n  b (ndarray): N-by-N matrix B with block anti-diagonal structure (F-order)\n  q1 (ndarray, optional): Orthogonal transformation Q1 (N-by-N, F-order)\n  q2 (ndarray, optional): Orthogonal transformation Q2 (N-by-N, F-order)\n\nReturns:\n  (a, b, q1, q2, info): Transformed matrices and exit code\n  info=0: success\n  info=1: QZ algorithm failed\n  info=2: warning - eigenvalue reordering failed\n  info=3: reordering in periodic QZ failed\n  info=4: illegal structure (deflation window too small)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04hd\n>>> n = 4\n>>> m = n // 2\n>>> a11 = np.triu(np.random.randn(m, m))\n>>> a22 = np.triu(np.random.randn(m, m))\n>>> a = np.zeros((n, n), order='F', dtype=float)\n>>> a[:m, :m] = a11\n>>> a[m:, m:] = a22\n>>> b12 = np.triu(np.random.randn(m, m))\n>>> b21 = np.triu(np.random.randn(m, m))\n>>> b = np.zeros((n, n), order='F', dtype=float)\n>>> b[:m, m:] = b12\n>>> b[m:, :m] = b21\n>>> result = mb04hd('I', 'I', a, b)\n>>> a_out, b_out, q1, q2, info = result",
  "mb04id": "QR factorization of matrix with lower-left zero triangle.\n\nComputes A = Q*R where A has p-by-min(p,m) zero triangle in lower-left.\nOptionally applies Q' to matrix B.\n\nParameters:\n  n (int): Number of rows of A\n  m (int): Number of columns of A\n  p (int): Order of zero triangle\n  a (ndarray): Matrix A (n x m, F-order), modified in place\n  b (ndarray, optional): Matrix B (n x l, F-order), modified in place\n  l (int, optional): Number of columns of B (default 0)\n  ldwork (int, optional): Workspace size (-1 for query, default auto)\n\nReturns:\n  If l>0: (b, tau, info) - transformed B, Householder factors, exit code\n  If l=0: (tau, info) - Householder factors, exit code\n  If ldwork=-1: adds optimal workspace size to tuple\n\nExamples:\n\n>>> from slicot import mb04id\n>>> import numpy as np\n>>> n, m, p = 8, 7, 2\n>>> a = np.random.randn(n, m).astype(float, order='F')\n>>> a[6, 0] = 0.0  # Zero triangle\n>>> a[7, 0] = 0.0\n>>> a[7, 1] = 0.0\n>>> a_out, tau, info = mb04id(n, m, p, a)\n>>> r = np.triu(a_out[:min(n, m), :])\n>>> info\n0",
  "mb04iy": "Apply orthogonal transformations from MB04ID to matrix C.\n\nApplies Q or Q' to matrix C, where Q is product of elementary reflectors\nas returned by MB04ID (special structure for lower-left zero triangle).\n\nParameters:\n  side (str): 'L' for left (Q*C or Q'*C), 'R' for right (C*Q or C*Q')\n  trans (str): 'N' for Q, 'T' for Q'\n  a (ndarray): Reflector storage (lda x k, F-order), modified but restored\n  tau (ndarray): Reflector scalar factors (k,)\n  c (ndarray): Matrix C (n x m, F-order), modified in place\n  p (int, optional): Order of zero triangle (default 0)\n\nReturns:\n  (c, info): Transformed matrix and exit code",
  "mb04iz": "QR factorization of complex matrix with lower-left zero triangle.\n\nComputes A = Q*R where A is n-by-m complex matrix with p-by-min(p,m)\nzero triangle in the lower left corner. Optionally applies Q^H to B.\n\nParameters:\n  a (ndarray): Complex matrix A (n x m, F-order), modified in place\n  p (int): Order of zero triangle (>= 0)\n  b (ndarray, optional): Complex matrix B (n x l, F-order), modified in place\n  lzwork (int, optional): Workspace size (-1 for query)\n\nReturns:\n  dict with keys:\n    a: Factored matrix (R in upper triangle, reflectors below)\n    tau: Complex scalar factors of reflectors (min(n,m),)\n    info: Exit code (0 = success)\n    zwork_opt: Optimal workspace size\n    b: Transformed B (only if b provided)\n\nExamples:\n\n>>> from slicot import mb04iz\n>>> import numpy as np\n>>> n, m, p = 6, 5, 2\n>>> a = (np.random.randn(n, m) + 1j * np.random.randn(n, m)).astype(\n...     np.complex128, order='F'\n...     )\n...     a[n - p + i, j] = 0.0\n>>> result = mb04iz(a, p)\n>>> a_out, tau, info = result['a'], result['tau'], result['info']\n...     if i > j:  # Below diagonal\n...     pass  # These contain Householder vectors\n...     else:",
  "mb04jd": "LQ factorization of matrix with upper-right zero triangle.\n\nComputes A = L*Q where A is n-by-m matrix with min(n,p)-by-p\nzero triangle in the upper right corner. Optionally applies Q to matrix B\nfrom the right. Exploits the zero structure.\n\nParameters:\n  n (int): Number of rows of A (>= 0)\n  m (int): Number of columns of A (>= 0)\n  p (int): Order of zero triangle (>= 0)\n  a (ndarray): Matrix A (n x m, F-order), modified in place\n  b (ndarray, optional): Matrix B (l x m, F-order), modified in place\n  l (int, optional): Number of rows of B (default 0)\n  ldwork (int, optional): Workspace size (-1 for query, default auto)\n\nReturns:\n  If l>0: (a, b, tau, info) - factored A, transformed B, reflectors, exit code\n  If l=0: (a, tau, info) - factored A, Householder factors, exit code\n  If ldwork=-1: adds optimal workspace size to tuple\n\nExamples:\n\n>>> from slicot import mb04jd\n>>> import numpy as np\n>>> n, m, p = 8, 7, 2\n>>> a = np.random.randn(n, m).astype(float, order='F')\n>>> a[0, 5] = 0.0\n>>> a[0, 6] = 0.0\n>>> a[1, 6] = 0.0\n>>> a_out, tau, info = mb04jd(n, m, p, a)\n>>> l_mat = np.tril(a_out[:, :min(n, m)])\n>>> diag_size = min(n, m)\n>>> info\n0",
  "mb04kd": "QR factorization of special structured block matrix.\n\nComputes Q' * [[R],[A B]] = [[R_bar C],[0 D]]\n\nParameters:\n  uplo (str): 'U' if A is upper trapezoidal, 'F' if A is full\n  n (int): Order of R and R_bar\n  m (int): Number of columns of B, C, D\n  p (int): Number of rows of A, B, D\n  r (ndarray): Upper triangular matrix R (n x n, F-order)\n  a (ndarray): Matrix A (p x n, F-order)\n  b (ndarray): Matrix B (p x m, F-order)\n\nReturns:\n  (r_bar, a_out, d, c, tau): Transformed matrices and Householder factors\n\nExamples:\n\n>>> import numpy as np\n>>> n, m, p = 3, 2, 4\n>>> R = np.array([\n...     [2.0, 1.0, 0.5],\n...     [0.0, 3.0, 1.5],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> A = np.array([\n...     [1.0, 2.0, 1.0],\n...     [3.0, 1.0, 2.0],\n...     [2.0, 3.0, 1.0],\n...     [1.0, 1.0, 3.0]\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [1.5, 2.0],\n...     [2.5, 1.0],\n...     [1.0, 3.0],\n...     [3.0, 1.5]\n...     ], order='F', dtype=float)\n>>> from slicot import mb04kd\n>>> R_bar, A_out, D, C, tau = mb04kd('F', n, m, p, R.copy(), A.copy(), B.copy())\n>>> original_norm_sq = np.linalg.norm(R)**2 + np.linalg.norm(A)**2 + np.linalg.norm(B)**2\n>>> result_norm_sq = np.linalg.norm(R_bar)**2 + np.linalg.norm(C)**2 + np.linalg.norm(D)**2\n...     err_msg=\"Orthogonal transformation should preserve Frobenius norm\")",
  "mb04ld": "LQ factorization of special structured block matrix.\n\nComputes [[L A],[0 B]] * Q = [[L_bar 0],[C D]]\n\nUseful for Kalman filter square-root covariance updates.\n\nParameters:\n  uplo (str): 'L' if A is lower trapezoidal, 'F' if A is full\n  n (int): Order of L and L_bar\n  m (int): Number of columns of A, B, D\n  p (int): Number of rows of B, C, D\n  l (ndarray): Lower triangular matrix L (n x n, F-order)\n  a (ndarray): Matrix A (n x m, F-order)\n  b (ndarray): Matrix B (p x m, F-order)\n\nReturns:\n  (l_bar, a_out, d, c, tau): Transformed matrices and Householder factors\n\nExamples:\n\n>>> import numpy as np\n>>> n, m, p = 3, 4, 2\n>>> L = np.tril(np.random.randn(n, n)).astype(float, order='F')\n>>> L += np.diag(np.abs(np.diag(L)) + 1.0)\n>>> A = np.random.randn(n, m).astype(float, order='F')\n>>> B = np.random.randn(p, m).astype(float, order='F')\n>>> from slicot import mb04ld\n>>> L_bar, A_out, D, C, tau = mb04ld('F', n, m, p, L.copy(), A.copy(), B.copy())\n>>> original_norm_sq = np.linalg.norm(L)**2 + np.linalg.norm(A)**2 + np.linalg.norm(B)**2\n>>> result_norm_sq = np.linalg.norm(L_bar)**2 + np.linalg.norm(C)**2 + np.linalg.norm(D)**2\n...     err_msg=\"Orthogonal transformation should preserve Frobenius norm\")",
  "mb04md": "Balance a general real matrix to reduce its 1-norm.\n\nApplies diagonal similarity transformation inv(D) * A * D iteratively\nto make rows and columns as close in norm as possible.\n\nParameters:\n  a (ndarray): N-by-N matrix A (F-order), balanced on exit\n  maxred (float, optional): Max allowed reduction if zero rows/cols.\n    If > 0, must be > 1. If <= 0, uses default 10.0.\n\nReturns:\n  (a_balanced, scale, maxred_out, info):\n    a_balanced: Balanced matrix\n    scale: Scaling factors D(j) for j=1,...,N\n    maxred_out: Ratio of original/balanced 1-norm (if A non-zero)\n    info: 0=success, <0=param -info invalid\n\nExamples:\n\n>>> from slicot import mb04md\n>>> import numpy as np\n>>> n = 4\n>>> a = np.array([\n...     [1.0, 0.0, 0.0, 0.0],\n...     [300.0, 400.0, 500.0, 600.0],\n...     [1.0, 2.0, 0.0, 0.0],\n...     [1.0, 1.0, 1.0, 1.0],\n...     ], dtype=float, order='F')\n>>> a_balanced, scale, maxred_out, info = mb04md(a)\n>>> info\n0",
  "mb04nd": "RQ factorization of special structured block matrix.\n\nCalculates RQ factorization of [A R; C B] to produce [0 R_new; C_new B_new].\n\nParameters:\n  uplo (str): 'U' for upper trapezoidal A, 'F' for full A\n  n (int): Order of R and R_new\n  m (int): Number of rows of B and C\n  p (int): Number of columns of A and C\n  r (ndarray): n-by-n upper triangular R (modified in place)\n  a (ndarray): n-by-p matrix A (modified, stores Householder vectors)\n  b (ndarray): m-by-n matrix B (modified in place)\n  c (ndarray): m-by-p matrix C (modified in place)\n\nReturns:\n  tau (ndarray): Scalar factors of elementary reflectors\n\nExamples:\n\n>>> import numpy as np\n>>> n, m, p = 3, 2, 3\n>>> a = np.random.randn(n, p).astype(float, order='F')\n>>> r = np.triu(np.random.randn(n, n)).astype(float, order='F')\n>>> c = np.random.randn(m, p).astype(float, order='F')\n>>> b = np.random.randn(m, n).astype(float, order='F')\n>>> a_work = a.copy(order='F')\n>>> r_work = r.copy(order='F')\n>>> c_work = c.copy(order='F')\n>>> b_work = b.copy(order='F')\n>>> from slicot import mb04nd\n>>> tau = _slicot.mb04nd('F', n, m, p, r_work, a_work, b_work, c_work)",
  "mb04ny": "Apply Householder reflector to matrix [A B] from the right.\n\nApplies H = I - tau*[1;v]*[1;v]' to m-by-(n+1) matrix [A B],\nwhere A has one column.\n\nParameters:\n  m (int): Number of rows of A and B\n  n (int): Number of columns of B\n  v (ndarray): Householder vector (1+(n-1)*abs(incv), F-order)\n  incv (int): Increment between elements of v\n  tau (float): Householder scalar\n  a (ndarray): Matrix A (m x 1, F-order, modified in place)\n  b (ndarray): Matrix B (m x n, F-order, modified in place)\n\nReturns:\n  (a, b): Updated matrices\n\nExamples:\n\n>>> import numpy as np\n>>> m, n = 3, 1\n>>> a = np.random.randn(m, 1).astype(float, order='F')\n>>> b = np.random.randn(m, n).astype(float, order='F')\n>>> v = np.random.randn(n).astype(float, order='F')\n>>> incv = 1\n>>> tau = 1.5\n>>> from slicot import mb04ny\n>>> a_out = a.copy(order='F')\n>>> b_out = b.copy(order='F')\n>>> _slicot.mb04ny(m, n, v, incv, tau, a_out, b_out)",
  "mb04od": "QR factorization of structured block matrix.\n\nComputes QR factorization of first block column and applies\ntransformations to second block column:\n  Q' * [R  B] = [R_  B_]\n       [A  C]   [0   C_]\n\nParameters:\n  uplo (str): 'U' for A upper trapezoidal, 'F' for A full\n  n (int): Order of R\n  m (int): Columns in B, C\n  p (int): Rows in A, C\n  r (ndarray): n-by-n upper triangular matrix R (F-order), modified\n  a (ndarray): p-by-n matrix A (F-order), overwritten with Householder vectors\n  b (ndarray): n-by-m matrix B (F-order), modified\n  c (ndarray): p-by-m matrix C (F-order), modified\n\nReturns:\n  (r, a, b, c, tau): Updated matrices and Householder scalars\n\nExamples:\n\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> uplo = 'F'\n>>> r = np.array([\n...     [3., 2., 1.],\n...     [0., 2., 1.],\n...     [0., 0., 1.]\n...     ], dtype=float, order='F')\n>>> a = np.array([\n...     [2., 3., 1.],\n...     [4., 6., 5.]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [3., 2.],\n...     [1., 3.],\n...     [3., 2.]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [1., 3.],\n...     [3., 2.]\n...     ], dtype=float, order='F')\n>>> from slicot import mb04od\n>>> r_out, a_out, b_out, c_out, tau = mb04od(uplo, n, m, p, r, a, b, c)",
  "mb04ow": "Performs a QR factorization update.\n\nParameters:\n  m (int): Rows of U1\n  n (int): Rows of T\n  p (int): Columns of B, C\n  a (ndarray): Matrix U (lda x m+n), modified in place\n  t (ndarray): Matrix T (ldt x n), modified in place\n  x (ndarray): Vector x (m+n), modified in place\n  b (ndarray): Matrix B (ldb x p), modified in place\n  c (ndarray): Matrix C (ldc x p), modified in place\n  d (ndarray): Vector d (p), modified in place\n  incx (int, optional): Increment for x\n  incd (int, optional): Increment for d\n\nReturns:\n  (a, t, x, b, c, d): Modified arrays\n\nExamples:\n\n>>> from slicot import mb04ow\n>>> import numpy as np\n>>> m, n, p = 4, 3, 2\n>>> lda = m + 2\n>>> ldt = n + 2\n>>> ldb = m + 2\n>>> ldc = n + 2\n>>> u1 = np.triu(np.random.rand(m, m))\n>>> u2 = np.random.rand(m, n)\n>>> t = np.triu(np.random.rand(n, n))\n>>> a = np.zeros((lda, n + m), order='F')\n>>> a[:m, :m] = u1\n>>> a[:m, m:m+n] = u2\n>>> t_arr = np.zeros((ldt, n), order='F')\n>>> t_arr[:n, :n] = t\n>>> b = np.random.rand(m, p)\n>>> b_arr = np.zeros((ldb, p), order='F')\n>>> b_arr[:m, :p] = b\n>>> c = np.random.rand(n, p)\n>>> c_arr = np.zeros((ldc, p), order='F')\n>>> c_arr[:n, :p] = c\n>>> x = np.random.rand(m + n)\n>>> x_arr = x.copy() # MB04OW modifies X\n>>> d = np.random.rand(p)\n>>> d_arr = d.copy() # MB04OW modifies D\n>>> K = np.zeros((m + n + 1, m + n + p))\n>>> K[:m, :m] = u1\n>>> K[:m, m:m+n] = u2\n>>> K[:m, m+n:] = b\n>>> K[m:m+n, m:m+n] = t\n>>> K[m:m+n, m+n:] = c\n>>> K[m+n, :m+n] = x\n>>> K[m+n, m+n:] = d\n>>> a_out, t_out, x_out, b_out, c_out, d_out = mb04ow(m, n, p, a, t_arr, x_arr, b_arr, c_arr, d_arr)\n>>> K_out = np.zeros_like(K)\n>>> r1 = a_out[:m, :m] # Upper triangular\n>>> r2 = a_out[:m, m:m+n]\n>>> r3 = t_out[:n, :n] # Upper triangular\n>>> b_new = b_out[:m, :p]\n>>> c_new = c_out[:n, :p]\n>>> d_new = d_out\n>>> K_out[:m, :m] = np.triu(r1)\n>>> K_out[:m, m:m+n] = r2\n>>> K_out[:m, m+n:] = b_new\n>>> K_out[m:m+n, m:m+n] = np.triu(r3)\n>>> K_out[m:m+n, m+n:] = c_new\n>>> K_out[m+n, m+n:] = d_new\n>>> gram_in = K.T @ K\n>>> gram_out = K_out.T @ K_out",
  "mb04ox": "QR factorization update for rank-one modification.\n\nPerforms QR factorization: (U; x') = Q*(R; 0) where U,R are upper triangular.\n\nParameters:\n  a (ndarray): Upper triangular matrix U (n x n, F-order), overwritten by R\n  x (ndarray): Vector x (n,), overwritten\n\nReturns:\n  (r, x_out): Updated upper triangular matrix R, modified x\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04ox\n>>> n = 3\n>>> u = np.array([\n...     [2.0, 1.0, 0.5],\n...     [0.0, 3.0, 1.0],\n...     [0.0, 0.0, 4.0]\n...     ], order='F', dtype=float)\n>>> x = np.array([1.0, 1.0, 1.0], order='F', dtype=float)\n>>> r, x_out = mb04ox(u.copy(order='F'), x.copy(order='F'))\n>>> aug_norm_sq = np.sum(augmented**2)\n>>> r_norm_sq = np.sum(np.triu(r)**2)",
  "mb04oy": "Apply Householder reflector to matrix [A; B].\n\nApplies H = I - tau*[1;v]*[1;v]' to (m+1)-by-n matrix [A; B],\nwhere A has one row.\n\nParameters:\n  m (int): Number of rows of B\n  n (int): Number of columns\n  v (ndarray): Householder vector (m, F-order)\n  tau (float): Householder scalar\n  a (ndarray): Matrix A (1 x n, F-order, modified in place)\n  b (ndarray): Matrix B (m x n, F-order, modified in place)\n\nReturns:\n  (a, b): Updated matrices\n\nExamples:\n\n>>> import numpy as np\n>>> m, n = 1, 3\n>>> a = np.random.randn(1, n).astype(float, order='F')\n>>> b = np.random.randn(m, n).astype(float, order='F')\n>>> v = np.random.randn(m).astype(float, order='F')\n>>> tau = 1.5\n>>> from slicot import mb04oy\n>>> a_out = a.copy(order='F')\n>>> b_out = b.copy(order='F')\n>>> mb04oy(m, n, v, tau, a_out, b_out)",
  "mb04pa": "Reduce (skew-)Hamiltonian like matrix with orthogonal symplectic transformation.\n\nReduces a Hamiltonian H = [A G; Q -A'] or skew-Hamiltonian W = [A G; Q A']\nso that elements below (k+1)-th subdiagonal in first nb columns of A,\nand offdiagonal elements in first nb columns/rows of Q are zero.\nThis is an auxiliary routine called by MB04PB.\n\nParameters:\n  lham (bool): True for Hamiltonian, False for skew-Hamiltonian\n  n (int): Number of columns of A, n >= 0\n  k (int): Offset of reduction, k >= 0\n  nb (int): Number of columns/rows to reduce, n > nb >= 0\n  a (ndarray): (k+n)-by-n matrix A (F-order), modified on exit\n  qg (ndarray): (n+k)-by-(n+1) matrix containing Q and G (F-order)\n  xa (ndarray): n-by-(2*nb) output matrix XA (F-order)\n  xg (ndarray): (k+n)-by-(2*nb) output matrix XG (F-order)\n  xq (ndarray): n-by-(2*nb) output matrix XQ (F-order)\n  ya (ndarray): (k+n)-by-(2*nb) output matrix YA (F-order)\n  cs (ndarray): Output cosines/sines array (2*nb,)\n  tau (ndarray): Output scalar factors array (nb,)\n  dwork (ndarray): Workspace (3*nb,)\n\nReturns:\n  (a, qg, xa, xg, xq, ya, cs, tau): Modified arrays\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04pa\n>>> n, k, nb = 0, 0, 0\n>>> lda = 1\n>>> ldqg = 1\n>>> ldxa = 1\n>>> ldxg = 1\n>>> ldxq = 1\n>>> ldya = 1\n>>> a = np.zeros((1, 1), order='F')\n>>> qg = np.zeros((1, 2), order='F')\n>>> xa = np.zeros((1, 1), order='F')\n>>> xg = np.zeros((1, 1), order='F')\n>>> xq = np.zeros((1, 1), order='F')\n>>> ya = np.zeros((1, 1), order='F')\n>>> cs = np.zeros(1, order='F')\n>>> tau = np.zeros(1, order='F')\n>>> dwork = np.zeros(1, order='F')\n>>> a_out, qg_out, xa_out, xg_out, xq_out, ya_out, cs_out, tau_out = mb04pa(\n...     True, n, k, nb, a, qg, xa, xg, xq, ya, cs, tau, dwork\n...     )",
  "mb04pb": "Reduce Hamiltonian matrix to PVL form (blocked version).\n\nBlocked algorithm version of mb04pu. Reduces a Hamiltonian matrix\nH = [A G; Q -A^T] where A is N-by-N and G, Q are N-by-N symmetric,\nto PVL form where Aout is upper Hessenberg and Qout is diagonal.\n\nParameters:\n  n (int): Order of matrix A (n >= 0)\n  ilo (int): Starting index (1 <= ilo <= max(1,n) for n>0, ilo=1 for n=0)\n  a (ndarray): N-by-N matrix A (F-order), modified to Aout\n  qg (ndarray): N-by-(N+1) matrix with Q (lower) and G (upper) (F-order)\n\nReturns:\n  (a, qg, cs, tau, info):\n    a: Upper Hessenberg Aout with reflector info\n    qg: Diagonal Qout, upper tri Gout, reflector info\n    cs: Cosines and sines of Givens rotations (2*n-2,)\n    tau: Scalar factors of elementary reflectors (n-1,)\n    info: 0=success, <0=param -info invalid\n\nExamples:\n\n>>> from slicot import mb04pb\n>>> import numpy as np\n>>> n = 5\n>>> ilo = 1\n>>> a = np.array([\n...     [0.9501, 0.7621, 0.6154, 0.4057, 0.0579],\n...     [0.2311, 0.4565, 0.7919, 0.9355, 0.3529],\n...     [0.6068, 0.0185, 0.9218, 0.9169, 0.8132],\n...     [0.4860, 0.8214, 0.7382, 0.4103, 0.0099],\n...     [0.8913, 0.4447, 0.1763, 0.8936, 0.1389],\n...     ], order='F', dtype=float)\n>>> qg = np.array([\n...     [0.3869, 0.4055, 0.2140, 1.0224, 1.1103, 0.7016],\n...     [1.3801, 0.7567, 1.4936, 1.2913, 0.9515, 1.1755],\n...     [0.7993, 1.7598, 1.6433, 1.0503, 0.8839, 1.1010],\n...     [1.2019, 1.1956, 0.9346, 0.6824, 0.7590, 1.1364],\n...     [0.8780, 0.9029, 1.6565, 1.1022, 0.7408, 0.3793],\n...     ], order='F', dtype=float)\n>>> a_out, qg_out, cs, tau, info = mb04pb(n, ilo, a, qg)\n>>> expected_a = np.array([\n...     [0.9501, -1.5494, 0.5268, 0.3187, -0.6890],\n...     [-2.4922, 2.0907, -1.3598, 0.5682, 0.5618],\n...     [0.0000, -1.7723, 0.3960, -0.2624, -0.3709],\n...     [0.0000, 0.0000, -0.2648, 0.2136, -0.3226],\n...     [0.0000, 0.0000, 0.0000, -0.2308, 0.2319],\n...     ], order='F', dtype=float)\n>>> info\n0",
  "mb04pu": "Reduce Hamiltonian matrix to Paige/Van Loan (PVL) form.\n\nReduces a Hamiltonian matrix H = [A G; Q -A^T] where A is N-by-N\nand G, Q are N-by-N symmetric, to PVL form where Aout is upper\nHessenberg and Qout is diagonal. Uses orthogonal symplectic U.\n\nParameters:\n  n (int): Order of matrix A (n >= 0)\n  ilo (int): Starting index (1 <= ilo <= max(1,n) for n>0, ilo=1 for n=0)\n  a (ndarray): N-by-N matrix A (F-order), modified to Aout\n  qg (ndarray): N-by-(N+1) matrix with Q (lower) and G (upper) (F-order)\n\nReturns:\n  (a, qg, cs, tau, info):\n    a: Upper Hessenberg Aout with reflector info\n    qg: Diagonal Qout, upper tri Gout, reflector info\n    cs: Cosines and sines of Givens rotations (2*n-2,)\n    tau: Scalar factors of elementary reflectors (n-1,)\n    info: 0=success, <0=param -info invalid\n\nExamples:\n\n>>> from slicot import mb04pu\n>>> import numpy as np\n>>> n = 5\n>>> ilo = 1\n>>> a = np.array([\n...     [0.9501, 0.7621, 0.6154, 0.4057, 0.0579],\n...     [0.2311, 0.4565, 0.7919, 0.9355, 0.3529],\n...     [0.6068, 0.0185, 0.9218, 0.9169, 0.8132],\n...     [0.4860, 0.8214, 0.7382, 0.4103, 0.0099],\n...     [0.8913, 0.4447, 0.1763, 0.8936, 0.1389],\n...     ], dtype=float, order='F')\n>>> qg = np.array([\n...     [0.4055, 0.3869, 1.3801, 0.7993, 1.2019, 0.8780],\n...     [0.2140, 1.4936, 0.7567, 1.7598, 1.1956, 0.9029],\n...     [1.0224, 1.2913, 1.0503, 1.6433, 0.9346, 1.6565],\n...     [1.1103, 0.9515, 0.8839, 0.7590, 0.6824, 1.1022],\n...     [0.7016, 1.1755, 1.1010, 1.1364, 0.3793, 0.7408],\n...     ], dtype=float, order='F')\n>>> a_result, qg_result, cs, tau, info = mb04pu(n, ilo, a, qg)\n...     err_msg=f\"A[{i},{j}] magnitude mismatch\"\n...     )\n...     else:\n...     err_msg=f\"A[{i},{j}] mismatch\"\n...     )\n...     )\n...     )\n>>> info\n0",
  "mb04py": "Apply elementary reflector to matrix from left or right.\n\nApplies H = I - tau*[1;v]*[1;v]' to m-by-n matrix C.\nH*C if side='L', C*H if side='R'.\n\nParameters:\n  side (str): 'L' for left, 'R' for right\n  m (int): Number of rows of C\n  n (int): Number of columns of C\n  v (ndarray): Householder vector (m-1 if 'L', n-1 if 'R')\n  tau (float): Householder scalar\n  c (ndarray): Matrix C (m x n, F-order, modified in place)\n\nReturns:\n  c: Updated matrix\n\nExamples:\n\n>>> import numpy as np\n>>> m, n = 1, 3\n>>> c = np.random.randn(m, n).astype(float, order='F')\n>>> v = np.empty(0, dtype=float, order='F')\n>>> tau = 1.5\n>>> from slicot import mb04py\n>>> c_out = c.copy(order='F')\n>>> mb04py('L', m, n, v, tau, c_out)",
  "mb04qb": "Apply symplectic reflectors and Givens rotations (blocked).\n\nOverwrites C and D with Q*[op(C);op(D)] or Q^T*[op(C);op(D)] where\nQ is a product of symplectic reflectors and Givens rotations.\nBlocked version of mb04qu.\n\nParameters:\n  tranc (str): 'N' for op(C)=C, 'T'/'C' for op(C)=C^T\n  trand (str): 'N' for op(D)=D, 'T'/'C' for op(D)=D^T\n  tranq (str): 'N' for Q, 'T' for Q^T\n  storev (str): 'C' for columnwise V, 'R' for rowwise\n  storew (str): 'C' for columnwise W, 'R' for rowwise\n  m (int): Number of rows of op(C) and op(D)\n  n (int): Number of columns of op(C) and op(D)\n  k (int): Number of elementary reflectors\n  v (ndarray): Reflector vectors F(i)\n  w (ndarray): Reflector vectors H(i)\n  c (ndarray): Matrix C (F-order, modified)\n  d (ndarray): Matrix D (F-order, modified)\n  cs (ndarray): Cosines/sines of Givens rotations (2*k)\n  tau (ndarray): Scalar factors of reflectors F(i) (k)\n  ldwork (int, optional): Workspace size, -1 for query\n\nReturns:\n  (c, d, info): Modified matrices and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04qb\n>>> m, n, k = 4, 0, 2\n>>> v = np.eye(m, k, order='F')\n>>> w = np.eye(m, k, order='F')\n>>> c = np.zeros((m, 1), order='F')\n>>> d = np.zeros((m, 1), order='F')\n>>> cs = np.ones(2 * k, order='F')\n>>> tau = np.zeros(k, order='F')\n>>> c_out, d_out, info = mb04qb(\n...     'N', 'N', 'N', 'C', 'C', m, n, k,\n...     v, w, c, d, cs, tau\n...     )\n>>> info\n0",
  "mb04qc": "Apply symplectic block reflector to matrices.\n\nApplies Q or Q^T to [op(A); op(B)] from the left using block factors from MB04QF.\n\nParameters:\n  strab (str): 'Z' for zero structure, 'N' for no structure\n  trana (str): 'N' for A, 'T'/'C' for A^T\n  tranb (str): 'N' for B, 'T'/'C' for B^T\n  tranq (str): 'N' for Q, 'T' for Q^T\n  direct (str): Reserved (use 'F')\n  storev (str): 'C' for columnwise V, 'R' for rowwise\n  storew (str): 'C' for columnwise W, 'R' for rowwise\n  m, n, k (int): Dimensions (m rows, n cols, k reflectors)\n  v, w (ndarray): Reflector vector matrices\n  rs, t (ndarray): Block factors from MB04QF\n  a, b (ndarray): Input matrices (modified)\n\nReturns:\n  (a, b): Modified matrices\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04qc\n>>> m, n, k = 4, 3, 2\n>>> V = np.zeros((m, k), order='F', dtype=float)\n>>> W = np.zeros((m, k), order='F', dtype=float)\n...     V[i, i] = 1.0\n...     W[i, i] = 1.0\n>>> rs = np.zeros((k, 6*k), order='F', dtype=float)\n>>> t = np.zeros((k, 9*k), order='F', dtype=float)\n>>> A = np.random.randn(m, n).astype(float, order='F')\n>>> B = np.random.randn(m, n).astype(float, order='F')\n>>> A_out, B_out = mb04qc(\n...     'Z', 'N', 'N', 'N', 'F', 'C', 'C', m, n, k, V, W, rs, t, A.copy(), B.copy()\n...     )",
  "mb04qf": "Form triangular block factors of symplectic block reflector.\n\nForms R, S, T factors for SH = diag(F,F)*prod(H_i)*prod(G_i) representation.\n\nParameters:\n  direct (str): 'F' for forward, 'B' for backward\n  storev (str): 'C' for columnwise V, 'R' for rowwise\n  storew (str): 'C' for columnwise W, 'R' for rowwise\n  n (int): Order of reflectors\n  k (int): Number of reflectors\n  v (ndarray): V matrix storing F reflector vectors\n  w (ndarray): W matrix storing H reflector vectors\n  cs (ndarray): Givens rotation cosines/sines\n  tau (ndarray): F reflector scalars\n\nReturns:\n  (rs, t, info): Block factor matrices RS (k,6k), T (k,9k), exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04qf\n>>> n, k = 4, 2\n>>> V = np.zeros((n, k), order='F', dtype=float)\n>>> W = np.zeros((n, k), order='F', dtype=float)\n...     V[i, i] = 1.0\n...     W[i, i] = 0.0\n>>> cs = np.zeros(2*k, order='F', dtype=float)\n...     cs[2*i] = 1.0\n...     cs[2*i + 1] = 0.0\n>>> tau = np.zeros(k, order='F', dtype=float)\n>>> rs, t, info = mb04qf('F', 'C', 'C', n, k, V, W, cs, tau)\n>>> info\n0",
  "mb04qs": "Multiply by product of symplectic reflectors and Givens rotations.\n\nOverwrites C and D with U*[op(C);op(D)] or U^T*[op(C);op(D)] where\nU is defined as a product of symplectic reflectors and Givens\nrotations as returned by MB04PU or MB04RU.\n\nParameters:\n  tranc (str): 'N' for op(C)=C, 'T'/'C' for op(C)=C^T\n  trand (str): 'N' for op(D)=D, 'T'/'C' for op(D)=D^T\n  tranu (str): 'N' for U, 'T' for U^T\n  m (int): Number of rows of op(C) and op(D)\n  n (int): Number of columns of op(C) and op(D)\n  ilo (int): Index from previous MB04PU/MB04RU call (1 <= ilo <= m+1)\n  v (ndarray): M-by-M matrix with reflector vectors H(i)\n  w (ndarray): M-by-M matrix with reflector vectors F(i)\n  c (ndarray): Matrix C (F-order, modified)\n  d (ndarray): Matrix D (F-order, modified)\n  cs (ndarray): Cosines/sines of Givens rotations (2*(m-1))\n  tau (ndarray): Scalar factors of reflectors F(i) (m-1)\n  ldwork (int, optional): Workspace size, -1 for query\n\nReturns:\n  (c, d, info): Modified matrices and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04qs\n>>> m, n = 4, 0\n>>> ilo = 1\n>>> v = np.eye(m, order='F')\n>>> w = np.eye(m, order='F')\n>>> c = np.zeros((m, 1), order='F')\n>>> d = np.zeros((m, 1), order='F')\n>>> cs = np.ones(2 * m - 2 if m > 1 else 1, order='F')\n>>> tau = np.zeros(m - 1 if m > 1 else 1, order='F')\n>>> c_out, d_out, info = mb04qs('N', 'N', 'N', m, n, ilo, v, w, c, d, cs, tau)\n>>> info\n0",
  "mb04qu": "Apply symplectic reflectors and Givens rotations (unblocked).\n\nOverwrites C and D with Q*[op(C);op(D)] or Q^T*[op(C);op(D)] where\nQ is a product of symplectic reflectors and Givens rotations.\n\nParameters:\n  tranc (str): 'N' for op(C)=C, 'T'/'C' for op(C)=C^T\n  trand (str): 'N' for op(D)=D, 'T'/'C' for op(D)=D^T\n  tranq (str): 'N' for Q, 'T' for Q^T\n  storev (str): 'C' for columnwise V, 'R' for rowwise\n  storew (str): 'C' for columnwise W, 'R' for rowwise\n  c (ndarray): Matrix C (F-order, modified)\n  d (ndarray): Matrix D (F-order, modified)\n  v (ndarray): Reflector vectors F(i)\n  w (ndarray): Reflector vectors H(i)\n  cs (ndarray): Cosines/sines of Givens rotations (2*k)\n  tau (ndarray): Scalar factors of reflectors F(i) (k)\n  k (int, optional): Number of reflectors (default: infer from V)\n\nReturns:\n  (c, d, info): Modified matrices and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04qu\n>>> m, n, k = 4, 3, 2\n>>> V = np.zeros((m, k), order='F', dtype=float)\n>>> W = np.zeros((m, k), order='F', dtype=float)\n...     V[i, i] = 1.0\n...     W[i, i] = 0.0\n>>> C = np.random.randn(m, n).astype(float, order='F')\n>>> D = np.random.randn(m, n).astype(float, order='F')\n>>> cs = np.zeros(2*k, order='F', dtype=float)\n...     cs[2*i] = 1.0\n...     cs[2*i + 1] = 0.0\n>>> tau = np.zeros(k, order='F', dtype=float)\n>>> C_out, D_out, info = mb04qu(\n...     'N', 'N', 'N', 'C', 'C', C.copy(), D.copy(), V, W, cs, tau\n...     )\n>>> info\n0",
  "mb04rb": "Reduce skew-Hamiltonian matrix to PVL form (blocked).\n\nReduces a skew-Hamiltonian matrix W = [[A, G], [Q, A^T]] to\nPaige/Van Loan (PVL) form using orthogonal symplectic U:\n\n  U^T W U = [[Aout, Gout], [0, Aout^T]]\n\nwhere Aout is upper Hessenberg, G and Q are skew-symmetric.\nThis is the blocked version of MB04RU.\n\nParameters:\n  n (int): Order of matrix A. n >= 0.\n  ilo (int): Lower index of non-triangular block. 1 <= ilo <= n+1.\n  a (ndarray): N-by-N matrix A (F-order, modified in place).\n  qg (ndarray): N-by-(N+1) array. Cols 1:N contain strictly lower\n               triangular Q, cols 2:N+1 contain strictly upper\n               triangular G. Modified in place.\n\nReturns:\n  (a, qg, cs, tau, info):\n    a: Upper Hessenberg Aout with reflector info below subdiagonal\n    qg: Reflector info in cols 1:N-1, strictly upper Gout in cols 2:N+1\n    cs: Cosines/sines of Givens rotations G(i), length 2*(N-1)\n    tau: Scalar factors of reflectors F(i), length N-1\n    info: Exit code (0=success, <0=invalid parameter -info)\n\nExamples:\n\n>>> from slicot import mb04rb\n>>> import numpy as np\n>>> n = 3\n>>> ilo = 1\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [7.0, 8.0, 9.0]\n...     ], order='F', dtype=float)\n>>> qg = np.zeros((n, n + 1), order='F', dtype=float)\n>>> qg[1, 0] = 0.5\n>>> qg[2, 0] = 0.3\n>>> qg[2, 1] = 0.2\n>>> qg[0, 2] = 1.0\n>>> qg[0, 3] = 0.7\n>>> qg[1, 3] = 0.4\n>>> a_out, qg_out, cs, tau, info = mb04rb(n, ilo, a, qg)\n...     c = cs[2 * i]\n...     s = cs[2 * i + 1]\n...     err_msg=f\"Givens rotation {i} not normalized\")\n>>> info\n0",
  "mb04rd": "Block-diagonalize generalized real Schur form using well-conditioned transformations.\n\nReduces a matrix pair (A,B) in generalized real Schur form to block-diagonal\nform using non-orthogonal equivalence transformations bounded by PMAX.\nOptionally reorders blocks to cluster eigenvalues.\n\nParameters:\n  jobx (str): 'N' = don't accumulate left transforms, 'U' = accumulate in X\n  joby (str): 'N' = don't accumulate right transforms, 'U' = accumulate in Y\n  sort (str): 'N' = no reordering, 'S' = cluster eigenvalues,\n              'C' = closest-neighbour, 'B' = both strategies\n  n (int): Order of matrices A, B, X, Y (n >= 0)\n  pmax (float): Bound for transformation element magnitudes (pmax >= 1)\n  a (ndarray): N-by-N upper quasi-triangular matrix A (F-order, modified)\n  b (ndarray): N-by-N upper triangular matrix B (F-order, modified)\n  x (ndarray): N-by-N left transformation matrix (F-order, modified if jobx='U')\n  y (ndarray): N-by-N right transformation matrix (F-order, modified if joby='U')\n  tol (float): Clustering tolerance (if sort='S' or 'B'); 0 for default\n\nReturns:\n  (a, b, x, y, nblcks, blsize, alphar, alphai, beta, info):\n    Block-diagonalized matrices, number of blocks, block sizes,\n    eigenvalue components (alphar+i*alphai)/beta, exit code\n\nExamples:\n\n>>> from slicot import mb04rd\n>>> import numpy as np\n>>> n = 2\n>>> pmax = 1e10\n>>> tol = 0.0\n>>> a = np.array([[1.0, 0.0],\n...     [0.0, 4.0]], order='F', dtype=float)\n>>> b = np.array([[1.0, 0.0],\n...     [0.0, 2.0]], order='F', dtype=float)\n>>> x = np.eye(n, order='F', dtype=float)\n>>> y = np.eye(n, order='F', dtype=float)\n>>> a_out, b_out, x_out, y_out, nblcks, blsize, alphar, alphai, beta, info = mb04rd(\n...     'U', 'U', 'N', n, pmax, a, b, x, y, tol)\n>>> info\n0",
  "mb04rs": "Solve generalized real Sylvester equation with Schur form matrices.\n\nSolves the generalized real Sylvester equation:\n  A * R - L * B = scale * C,\n  D * R - L * E = scale * F,\n\nwhere R and L are unknown M-by-N matrices, and (A,D), (B,E) and\n(C,F) are given matrix pairs. (A,D) and (B,E) must be in generalized\nSchur canonical form (A,B upper quasi-triangular; D,E upper triangular).\n\nThe solution (R,L) overwrites (C,F). 0 <= scale <= 1 is an output\nscaling factor chosen to avoid overflow.\n\nParameters:\n  m (int): Order of A and D, row dimension of C, F, R, L. m >= 0.\n  n (int): Order of B and E, column dimension of C, F, R, L. n >= 0.\n  pmax (float): Upper bound for absolute value of solution elements. pmax >= 1.\n  a (ndarray): M-by-M upper quasi-triangular matrix (Schur form, F-order)\n  b (ndarray): N-by-N upper quasi-triangular matrix (Schur form, F-order)\n  c (ndarray): M-by-N matrix, RHS of first equation (F-order, modified)\n  d (ndarray): M-by-M upper triangular matrix (Schur form, F-order)\n  e (ndarray): N-by-N upper triangular matrix (Schur form, F-order)\n  f (ndarray): M-by-N matrix, RHS of second equation (F-order, modified)\n\nReturns:\n  (r, l, scale, info): Solution R (in c), solution L (in f),\n    scaling factor, exit code (0=success, 1=element > pmax, 2=singular)\n\nExamples:\n\n>>> from slicot import mb04rs\n>>> import numpy as np\n>>> m, n = 1, 1\n>>> pmax = 1e10\n>>> a = np.array([[2.0]], order='F', dtype=float)\n>>> b = np.array([[3.0]], order='F', dtype=float)\n>>> c = np.array([[1.0]], order='F', dtype=float)\n>>> d = np.array([[1.0]], order='F', dtype=float)\n>>> e = np.array([[4.0]], order='F', dtype=float)\n>>> f = np.array([[2.0]], order='F', dtype=float)\n>>> r, l_mat, scale, info = mb04rs(m, n, pmax, a, b, c, d, e, f)\n>>> rhs1 = a @ r - l_mat @ b\n>>> rhs2 = d @ r - l_mat @ e\n>>> info\n0",
  "mb04rt": "Blocked solver for generalized real Sylvester equation (Level 3 BLAS).\n\nSolves the generalized real Sylvester equation:\n  A * R - L * B = scale * C,\n  D * R - L * E = scale * F,\n\nusing Level 3 BLAS for improved performance on larger matrices.\nThis is the blocked version of mb04rs.\n\nParameters:\n  m (int): Order of A and D, row dimension of C, F, R, L. m >= 0.\n  n (int): Order of B and E, column dimension of C, F, R, L. n >= 0.\n  pmax (float): Upper bound for absolute value of solution elements. pmax >= 1.\n  a (ndarray): M-by-M upper quasi-triangular matrix (Schur form, F-order)\n  b (ndarray): N-by-N upper quasi-triangular matrix (Schur form, F-order)\n  c (ndarray): M-by-N matrix, RHS of first equation (F-order, modified)\n  d (ndarray): M-by-M upper triangular matrix (Schur form, F-order)\n  e (ndarray): N-by-N upper triangular matrix (Schur form, F-order)\n  f (ndarray): M-by-N matrix, RHS of second equation (F-order, modified)\n\nReturns:\n  (r, l, scale, info): Solution R (in c), solution L (in f),\n    scaling factor, exit code (0=success, 1=element > pmax, 2=singular)\n\nExamples:\n\n>>> from slicot import mb04rt\n>>> import numpy as np\n>>> m, n = 1, 1\n>>> pmax = 1e10\n>>> a = np.array([[2.0]], order='F', dtype=float)\n>>> b = np.array([[3.0]], order='F', dtype=float)\n>>> c = np.array([[1.0]], order='F', dtype=float)\n>>> d = np.array([[1.0]], order='F', dtype=float)\n>>> e = np.array([[4.0]], order='F', dtype=float)\n>>> f = np.array([[2.0]], order='F', dtype=float)\n>>> r, l_mat, scale, info = mb04rt(m, n, pmax, a, b, c, d, e, f)\n>>> rhs1 = a @ r - l_mat @ b\n>>> rhs2 = d @ r - l_mat @ e\n>>> info\n0",
  "mb04ru": "Reduce skew-Hamiltonian matrix to PVL form (unblocked).\n\nReduces a skew-Hamiltonian matrix W = [[A, G], [Q, A^T]] to\nPaige/Van Loan (PVL) form using orthogonal symplectic U:\n\n  U^T W U = [[Aout, Gout], [0, Aout^T]]\n\nwhere Aout is upper Hessenberg, G and Q are skew-symmetric.\n\nParameters:\n  n (int): Order of matrix A. n >= 0.\n  ilo (int): Lower index of non-triangular block. 1 <= ilo <= n+1.\n  a (ndarray): N-by-N matrix A (F-order, modified in place).\n  qg (ndarray): N-by-(N+1) array. Cols 1:N contain strictly lower\n               triangular Q, cols 2:N+1 contain strictly upper\n               triangular G. Modified in place.\n\nReturns:\n  (a, qg, cs, tau, info):\n    a: Upper Hessenberg Aout with reflector info below subdiagonal\n    qg: Reflector info in cols 1:N-1, strictly upper Gout in cols 2:N+1\n    cs: Cosines/sines of Givens rotations G(i), length 2*(N-1)\n    tau: Scalar factors of reflectors F(i), length N-1\n    info: Exit code (0=success, <0=invalid parameter -info)\n\nExamples:\n\n>>> from slicot import mb04ru\n>>> import numpy as np\n>>> n = 3\n>>> ilo = 1\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [7.0, 8.0, 9.0]\n...     ], order='F', dtype=float)\n>>> qg = np.zeros((n, n + 1), order='F', dtype=float)\n>>> qg[1, 0] = 0.5\n>>> qg[2, 0] = 0.3\n>>> qg[2, 1] = 0.2\n>>> qg[0, 2] = 1.0\n>>> qg[0, 3] = 0.7\n>>> qg[1, 3] = 0.4\n>>> a_out, qg_out, cs, tau, info = mb04ru(n, ilo, a, qg)\n...     c = cs[2 * i]\n...     s = cs[2 * i + 1]\n...     err_msg=f\"Givens rotation {i} not normalized\")\n>>> info\n0",
  "mb04rv": "Solve the generalized complex Sylvester equation.\n\nSolves the generalized complex Sylvester equation:\n  A * R - L * B = scale * C,\n  D * R - L * E = scale * F,\n\nwhere R and L are unknown M-by-N complex matrices, and (A,D), (B,E)\nand (C,F) are given complex matrix pairs. A, B, D, and E are upper\ntriangular (i.e., (A,D) and (B,E) are in generalized complex Schur form).\n\nThe solution (R,L) overwrites (C,F). 0 <= scale <= 1 is an output\nscaling factor chosen to avoid overflow.\n\nFor efficiency, the 'absolute value' of a complex number x is computed\nas |real(x)| + |imag(x)| (taxi-cab norm).\n\nParameters:\n  m (int): Order of A and D, row dimension of C, F, R, L. m >= 0.\n  n (int): Order of B and E, column dimension of C, F, R, L. n >= 0.\n  pmax (float): Upper bound for absolute value of solution elements. pmax >= 1.\n  a (ndarray): M-by-M upper triangular complex matrix (Schur form, F-order)\n  b (ndarray): N-by-N upper triangular complex matrix (Schur form, F-order)\n  c (ndarray): M-by-N complex matrix, RHS of first equation (F-order, modified)\n  d (ndarray): M-by-M upper triangular complex matrix (Schur form, F-order)\n  e (ndarray): N-by-N upper triangular complex matrix (Schur form, F-order)\n  f (ndarray): M-by-N complex matrix, RHS of second equation (F-order, modified)\n\nReturns:\n  (r, l, scale, info): Solution R (in c), solution L (in f),\n    scaling factor, exit code (0=success, 1=element > pmax, 2=singular/close eigenvalues)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04rv\n>>> m, n = 1, 1\n>>> pmax = 1e6\n>>> a = np.array([[2.0 + 1.0j]], dtype=complex, order='F')\n>>> b = np.array([[3.0 + 0.5j]], dtype=complex, order='F')\n>>> d = np.array([[1.0 + 0.0j]], dtype=complex, order='F')\n>>> e = np.array([[1.0 + 0.0j]], dtype=complex, order='F')\n>>> c = np.array([[3.0 + 2.0j]], dtype=complex, order='F')\n>>> f = np.array([[1.0 + 1.0j]], dtype=complex, order='F')\n>>> r, l, scale, info = mb04rv(m, n, pmax, a, b, c, d, e, f)\n>>> info\n0",
  "mb04rw": "Blocked solver for generalized complex Sylvester equation (Level 3 BLAS).\n\nSolves the generalized complex Sylvester equation:\n  A * R - L * B = scale * C,\n  D * R - L * E = scale * F,\n\nusing Level 3 BLAS for improved performance on larger matrices.\nThis is the blocked version of mb04rv.\n\nWhere R and L are unknown M-by-N complex matrices, and (A,D), (B,E)\nand (C,F) are given complex matrix pairs. A, B, D, and E are upper\ntriangular (i.e., (A,D) and (B,E) are in generalized complex Schur form).\n\nThe solution (R,L) overwrites (C,F). 0 <= scale <= 1 is an output\nscaling factor chosen to avoid overflow.\n\nFor efficiency, the 'absolute value' of a complex number x is computed\nas |real(x)| + |imag(x)| (taxi-cab norm).\n\nParameters:\n  m (int): Order of A and D, row dimension of C, F, R, L. m >= 0.\n  n (int): Order of B and E, column dimension of C, F, R, L. n >= 0.\n  pmax (float): Upper bound for absolute value of solution elements. pmax >= 1.\n  a (ndarray): M-by-M upper triangular complex matrix (Schur form, F-order)\n  b (ndarray): N-by-N upper triangular complex matrix (Schur form, F-order)\n  c (ndarray): M-by-N complex matrix, RHS of first equation (F-order, modified)\n  d (ndarray): M-by-M upper triangular complex matrix (Schur form, F-order)\n  e (ndarray): N-by-N upper triangular complex matrix (Schur form, F-order)\n  f (ndarray): M-by-N complex matrix, RHS of second equation (F-order, modified)\n\nReturns:\n  (r, l, scale, info): Solution R (in c), solution L (in f),\n    scaling factor, exit code (0=success, 1=element > pmax, 2=singular/close eigenvalues)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04rw\n>>> m, n = 2, 2\n>>> pmax = 1e6\n>>> a = np.array([[2.0+1.0j, 0.5+0.2j],\n...     [0.0+0.0j, 1.0+0.5j]], dtype=complex, order='F')\n>>> b = np.array([[1.0+0.3j, 0.3+0.1j],\n...     [0.0+0.0j, 0.8+0.2j]], dtype=complex, order='F')\n>>> d = np.array([[1.0+0.0j, 0.2+0.1j],\n...     [0.0+0.0j, 0.5+0.0j]], dtype=complex, order='F')\n>>> e = np.array([[0.5+0.0j, 0.1+0.0j],\n...     [0.0+0.0j, 0.3+0.0j]], dtype=complex, order='F')\n>>> c = np.array([[1.0+1.0j, 2.0+0.5j],\n...     [0.5+0.2j, 1.5+1.0j]], dtype=complex, order='F')\n>>> f = np.array([[0.5+0.5j, 1.0+0.3j],\n...     [0.3+0.1j, 0.8+0.6j]], dtype=complex, order='F')\n>>> r, l, scale, info = mb04rw(m, n, pmax, a, b, c, d, e, f)\n>>> info\n0",
  "mb04rz": "Block-diagonalize generalized complex Schur form using well-conditioned transformations.\n\nReduces a complex matrix pair (A,B) in generalized complex Schur form to\nblock-diagonal form using non-unitary equivalence transformations bounded by PMAX.\nOptionally reorders blocks to cluster eigenvalues.\n\nParameters:\n  jobx (str): 'N' = don't accumulate left transforms, 'U' = accumulate in X\n  joby (str): 'N' = don't accumulate right transforms, 'U' = accumulate in Y\n  sort (str): 'N' = no reordering, 'S' = cluster eigenvalues,\n              'C' = closest-neighbour, 'B' = both strategies\n  n (int): Order of matrices A, B, X, Y (n >= 0)\n  pmax (float): Bound for transformation element magnitudes (pmax >= 1)\n  a (ndarray): N-by-N complex upper triangular matrix A (F-order, modified)\n  b (ndarray): N-by-N complex upper triangular matrix B (F-order, modified)\n  x (ndarray): N-by-N complex left transformation matrix (F-order, modified if jobx='U')\n  y (ndarray): N-by-N complex right transformation matrix (F-order, modified if joby='U')\n  tol (float): Clustering tolerance (if sort='S' or 'B'); 0 for default\n\nReturns:\n  (a, b, x, y, nblcks, blsize, alpha, beta, info):\n    Block-diagonalized matrices, number of blocks, block sizes,\n    complex eigenvalue components alpha/beta, exit code\n\nExamples:\n\n>>> from slicot import mb04rz\n>>> import numpy as np\n>>> n = 2\n>>> pmax = 1e10\n>>> tol = 0.0\n>>> a = np.array([[1.0+1.0j, 0.0],\n...     [0.0, 4.0+2.0j]], order='F', dtype=complex)\n>>> b = np.array([[1.0+0.0j, 0.0],\n...     [0.0, 2.0+0.0j]], order='F', dtype=complex)\n>>> x = np.eye(n, order='F', dtype=complex)\n>>> y = np.eye(n, order='F', dtype=complex)\n>>> a_out, b_out, x_out, y_out, nblcks, blsize, alpha, beta, info = mb04rz(\n...     'U', 'U', 'N', n, pmax, a, b, x, y, tol)\n>>> info\n0",
  "mb04su": "Compute symplectic QR decomposition of a real 2M-by-N matrix [A; B].\n\nComputes [A; B] = Q * R where Q is symplectic orthogonal, R11 is upper\ntriangular, and R21 is strictly upper triangular. Unblocked version.\n\nQ = diag(H(1),H(1)) G(1) diag(F(1),F(1)) ... diag(H(k),H(k)) G(k) diag(F(k),F(k))\nwhere k = min(m,n), H(i) and F(i) are Householder reflectors, and G(i) are\nGivens rotations.\n\nParameters:\n  m (int): Number of rows in A and B (m >= 0)\n  n (int): Number of columns in A and B (n >= 0)\n  a (ndarray): M-by-N matrix A (F-order, modified in place)\n  b (ndarray): M-by-N matrix B (F-order, modified in place)\n\nReturns:\n  (a, b, cs, tau, info):\n    a: [R11 R12] with reflector info in zero parts\n    b: [R21 R22] with reflector info in zero parts\n    cs: Cosines/sines of Givens rotations G(i), length 2*min(m,n)\n    tau: Scalar factors of reflectors F(i), length min(m,n)\n    info: Exit code (0=success, <0=invalid parameter -info)\n\nExamples:\n\n>>> from slicot import mb04su\n>>> import numpy as np\n>>> m, n = 3, 3\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [7.0, 8.0, 10.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [0.1, 0.2, 0.3],\n...     [0.4, 0.5, 0.6],\n...     [0.7, 0.8, 0.9]\n...     ], dtype=float, order='F')\n>>> a_out, b_out, cs, tau, info = mb04su(m, n, a, b)\n>>> k = min(m, n)\n...     c, s = cs[2 * i], cs[2 * i + 1]\n...     err_msg=f\"Givens rotation {i} not normalized\")\n>>> info\n0",
  "mb04tb": "Symplectic URV decomposition (blocked).\n\nComputes H = U * R * V^T where H = [[op(A), G], [Q, op(B)]] is\na 2N-by-2N Hamiltonian matrix, U, V are orthogonal symplectic,\nand R = [[R11, R12], [0, R22]] with R11 upper triangular,\nR22 lower Hessenberg. Blocked version of mb04ts.\n\nParameters:\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A^T\n  tranb (str): 'N' for op(B)=B, 'T'/'C' for op(B)=B^T\n  n (int): Order of matrices (n >= 0)\n  ilo (int): Starting index for reduction (1 <= ilo <= n+1)\n  a (ndarray): N-by-N matrix A (F-order, modified)\n  b (ndarray): N-by-N matrix B (F-order, modified)\n  g (ndarray): N-by-N matrix G (F-order, modified)\n  q (ndarray): N-by-N matrix Q (F-order, modified)\n  ldwork (int, optional): Workspace size, -1 for query\n\nReturns:\n  (a, b, g, q, csl, csr, taul, taur, info):\n    Modified matrices, Givens rotations, reflector factors, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04tb\n>>> n = 5\n>>> A = np.array([\n...     [0.4643, 0.3655, 0.6853, 0.5090, 0.3718],\n...     [0.3688, 0.6460, 0.4227, 0.6798, 0.5135],\n...     [0.7458, 0.5043, 0.9419, 0.9717, 0.9990],\n...     [0.7140, 0.4941, 0.7802, 0.5272, 0.1220],\n...     [0.7418, 0.0339, 0.7441, 0.0436, 0.6564]\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [-0.4643, -0.3688, -0.7458, -0.7140, -0.7418],\n...     [-0.3655, -0.6460, -0.5043, -0.4941, -0.0339],\n...     [-0.6853, -0.4227, -0.9419, -0.7802, -0.7441],\n...     [-0.5090, -0.6798, -0.9717, -0.5272, -0.0436],\n...     [-0.3718, -0.5135, -0.9990, -0.1220, -0.6564]\n...     ], order='F', dtype=float)\n>>> G = np.array([\n...     [0.7933, 1.5765, 1.0711, 1.0794, 0.8481],\n...     [1.5765, 0.1167, 1.5685, 0.8756, 0.5037],\n...     [1.0711, 1.5685, 0.9902, 0.3858, 0.2109],\n...     [1.0794, 0.8756, 0.3858, 1.8834, 1.4338],\n...     [0.8481, 0.5037, 0.2109, 1.4338, 0.1439]\n...     ], order='F', dtype=float)\n>>> Q = np.array([\n...     [1.0786, 1.5264, 1.1721, 1.5343, 0.4756],\n...     [1.5264, 0.8644, 0.6872, 1.1379, 0.6499],\n...     [1.1721, 0.6872, 1.5194, 1.1197, 1.0158],\n...     [1.5343, 1.1379, 1.1197, 0.6612, 0.2004],\n...     [0.4756, 0.6499, 1.0158, 0.2004, 1.2188]\n...     ], order='F', dtype=float)\n>>> ilo = 1\n>>> A_out, B_out, G_out, Q_out, csl, csr, taul, taur, info = mb04tb(\n...     'N', 'N', n, ilo, A, B, G, Q\n...     )\n>>> info\n0",
  "mb04ts": "Symplectic URV decomposition (unblocked).\n\nComputes H = U * R * V^T where H = [[op(A), G], [Q, op(B)]] is\na 2N-by-2N Hamiltonian matrix, U, V are orthogonal symplectic,\nand R = [[R11, R12], [0, R22]] with R11 upper triangular,\nR22 lower Hessenberg.\n\nParameters:\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A^T\n  tranb (str): 'N' for op(B)=B, 'T'/'C' for op(B)=B^T\n  n (int): Order of matrices (n >= 0)\n  ilo (int): Starting index for reduction (1 <= ilo <= n)\n  a (ndarray): N-by-N matrix A (F-order, modified)\n  b (ndarray): N-by-N matrix B (F-order, modified)\n  g (ndarray): N-by-N matrix G (F-order, modified)\n  q (ndarray): N-by-N matrix Q (F-order, modified)\n\nReturns:\n  (a, b, g, q, csl, csr, taul, taur, info):\n    Modified matrices, Givens rotations, reflector factors, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04ts\n>>> n = 5\n>>> A = np.array([\n...     [0.4643, 0.3655, 0.6853, 0.5090, 0.3718],\n...     [0.3688, 0.6460, 0.4227, 0.6798, 0.5135],\n...     [0.7458, 0.5043, 0.9419, 0.9717, 0.9990],\n...     [0.7140, 0.4941, 0.7802, 0.5272, 0.1220],\n...     [0.7418, 0.0339, 0.7441, 0.0436, 0.6564]\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [-0.4643, -0.3688, -0.7458, -0.7140, -0.7418],\n...     [-0.3655, -0.6460, -0.5043, -0.4941, -0.0339],\n...     [-0.6853, -0.4227, -0.9419, -0.7802, -0.7441],\n...     [-0.5090, -0.6798, -0.9717, -0.5272, -0.0436],\n...     [-0.3718, -0.5135, -0.9990, -0.1220, -0.6564]\n...     ], order='F', dtype=float)\n>>> G = np.array([\n...     [0.7933, 1.5765, 1.0711, 1.0794, 0.8481],\n...     [1.5765, 0.1167, 1.5685, 0.8756, 0.5037],\n...     [1.0711, 1.5685, 0.9902, 0.3858, 0.2109],\n...     [1.0794, 0.8756, 0.3858, 1.8834, 1.4338],\n...     [0.8481, 0.5037, 0.2109, 1.4338, 0.1439]\n...     ], order='F', dtype=float)\n>>> Q = np.array([\n...     [1.0786, 1.5264, 1.1721, 1.5343, 0.4756],\n...     [1.5264, 0.8644, 0.6872, 1.1379, 0.6499],\n...     [1.1721, 0.6872, 1.5194, 1.1197, 1.0158],\n...     [1.5343, 1.1379, 1.1197, 0.6612, 0.2004],\n...     [0.4756, 0.6499, 1.0158, 0.2004, 1.2188]\n...     ], order='F', dtype=float)\n>>> A_out, B_out, G_out, Q_out, csl, csr, taul, taur, info = mb04ts(\n...     'N', 'N', n, 1, A.copy(), B.copy(), G.copy(), Q.copy()\n...     )\n>>> info\n0",
  "mb04tt": "Row compression with column echelon form preservation.\n\nTransforms submatrices (AA, EE) of A and E such that Aj is row compressed\nwhile keeping Ej in column echelon form. This is step j of Algorithm 3.2.1\nfrom Beelen's thesis for computing Kronecker structure of matrix pencils.\n\nLet AA = A(IFIRA:M, IFICA:N), EE = E(IFIRA:M, IFICA:N)\nLet Aj = A(IFIRA:M, IFICA:IFICA+NCA-1), Ej = E(IFIRA:M, IFICA+NCA:N)\n\nParameters:\n  updatq (bool): True to accumulate row transforms in Q\n  updatz (bool): True to accumulate column transforms in Z\n  m (int): Number of rows in A, E, Q (m >= 0)\n  n (int): Number of columns in A, E, Z (n >= 0)\n  ifira (int): First row index (1-based)\n  ifica (int): First column index (1-based)\n  nca (int): Number of columns in Aj\n  a (ndarray): M-by-N matrix A (F-order, modified)\n  e (ndarray): M-by-N matrix E in column echelon form (F-order, modified)\n  q (ndarray): M-by-M orthogonal matrix (F-order, modified if updatq)\n  z (ndarray): N-by-N orthogonal matrix (F-order, modified if updatz)\n  istair (ndarray): Column echelon encoding (+j=corner, -j=boundary)\n  tol (float): Tolerance for zero elements\n\nReturns:\n  (a, e, q, z, istair, rank, info):\n    Transformed matrices, updated staircase array, rank of Aj, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04tt\n>>> m, n = 3, 5\n>>> ifira, ifica, nca = 1, 1, 2\n>>> A = np.array([\n...     [1.0, 2.0, 0.5, 0.2, 0.1],\n...     [4.0, 5.0, 0.6, 0.3, 0.2],\n...     [7.0, 8.0, 0.7, 0.4, 0.3]\n...     ], order='F', dtype=float)\n>>> E = np.array([\n...     [0.0, 0.0, 1.0, 0.5, 0.2],\n...     [0.0, 0.0, 0.0, 2.0, 0.3],\n...     [0.0, 0.0, 0.0, 0.0, 1.5]\n...     ], order='F', dtype=float)\n>>> istair = np.array([3, 4, 5], dtype=np.int32)\n>>> Q = np.eye(m, order='F', dtype=float)\n>>> Z = np.eye(n, order='F', dtype=float)\n>>> A_out, E_out, Q_out, Z_out, istair_out, rank, info = mb04tt(\n...     True, True, m, n, ifira, ifica, nca, A.copy(), E.copy(),\n...     Q.copy(), Z.copy(), istair.copy(), 1e-10\n...     )\n>>> info\n0",
  "mb04tu": "Givens transformation with interchange (modified DROT).\n\nApplies row-permuted Givens transformation:\n  X_new = C*Y - S*X\n  Y_new = C*X + S*Y\n\nNOTE: This is NOT standard DROT (which computes X' = CX + SY, Y' = -SX + CY).\n\nParameters:\n  x (ndarray): Input array X (modified in place)\n  y (ndarray): Input array Y (modified in place)\n  c (float): Cosine of Givens rotation\n  s (float): Sine of Givens rotation\n  n (int, optional): Number of elements to transform (default: min(len(x), len(y)))\n  incx (int, optional): Increment for X (default: 1)\n  incy (int, optional): Increment for Y (default: 1)\n\nReturns:\n  (x, y): Transformed arrays\n\nExamples:\n\n>>> from slicot import mb04tu\n>>> import numpy as np\n>>> x = np.array([1.0, 2.0, 3.0], dtype=float, order='F')\n>>> y = np.array([4.0, 5.0, 6.0], dtype=float, order='F')\n>>> c = 1.0\n>>> s = 0.0\n>>> x_out, y_out = mb04tu(x, y, c, s)",
  "mb04tv": "Reduce submatrix A(k) to upper triangular form using column Givens rotations.\n\nReduces A(k) = A(IFIRA:ma, IFICA:na) where ma = IFIRA-1+NRA, na = IFICA-1+NCA\nto upper triangular form. Matrix A(k) must have full row rank.\n\nThe same column transformations are applied to E(k) = E(1:IFIRA-1, IFICA:na).\nNote: E uses the same column indices but different row indices than A.\n\nParameters:\n  n (int): Number of columns of A and E, n >= 0\n  nra (int): Number of rows in A to transform, 0 <= nra <= lda\n  nca (int): Number of columns in A to transform, 0 <= nca <= n\n  ifira (int): First row index in A (1-based)\n  ifica (int): First column index in A (1-based)\n  a (ndarray): Matrix A (F-order, modified in place)\n  e (ndarray): Matrix E (F-order, modified in place)\n  z (ndarray): Transform matrix Z (F-order, modified if updatz=True)\n  updatz (bool, optional): Whether to accumulate transforms in Z (default: False)\n\nReturns:\n  (a, e, z, info): Transformed matrices and exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb04tv\n>>> import numpy as np\n>>> n = 3\n>>> nra = 2\n>>> nca = 3\n>>> ifira = 1  # 1-based row index\n>>> ifica = 1  # 1-based column index\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     ], dtype=float, order='F')\n>>> e = np.zeros((0, 3), dtype=float, order='F')  # Empty, ifira-1=0 rows\n>>> z = np.eye(n, dtype=float, order='F')\n>>> a_out, e_out, z_out, info = mb04tv(\n...     n, nra, nca, ifira, ifica, a, e, z, updatz=True\n...     )\n>>> info\n0",
  "mb04tw": "Reduce submatrix E(k) to upper triangular form using row Givens rotations.\n\nReduces E(k) = E(IFIRE:me, IFICE:ne) where me = IFIRE-1+NRE, ne = IFICE-1+NCE\nto upper triangular form. Matrix E(k) must have full column rank.\n\nThe same row transformations are applied to A(k) = A(IFIRE:me, IFICA:N).\nNote: A uses the same row indices but different column indices than E.\n\nParameters:\n  m (int): Number of rows of A and E, m >= 0\n  n (int): Number of columns of A and E, n >= 0\n  nre (int): Number of rows in E to transform, 0 <= nre <= m\n  nce (int): Number of columns in E to transform, 0 <= nce <= n\n  ifire (int): First row index in E (1-based)\n  ifice (int): First column index in E (1-based)\n  ifica (int): First column index in A (1-based)\n  a (ndarray): Matrix A (F-order, modified in place)\n  e (ndarray): Matrix E (F-order, modified in place)\n  q (ndarray): Transform matrix Q (F-order, modified if updatq=True)\n  updatq (bool, optional): Whether to accumulate transforms in Q (default: False)\n\nReturns:\n  (a, e, q, info): Transformed matrices and exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb04tw\n>>> import numpy as np\n>>> m = 2\n>>> n = 2\n>>> nre = 2\n>>> nce = 2\n>>> ifire = 1  # 1-based\n>>> ifice = 1  # 1-based\n>>> ifica = 1  # 1-based\n>>> e = np.array([\n...     [1.0, 2.0],\n...     [3.0, 4.0],\n...     ], dtype=float, order='F')\n>>> a = np.array([\n...     [5.0, 6.0],\n...     [7.0, 8.0],\n...     ], dtype=float, order='F')\n>>> q = np.eye(m, dtype=float, order='F')\n>>> a_out, e_out, q_out, info = mb04tw(\n...     m, n, nre, nce, ifire, ifice, ifica, a, e, q, updatq=True\n...     )\n>>> info\n0",
  "mb04tx": "Separate pencils s*E(eps)-A(eps) and s*E(inf)-A(inf).\n\nSeparates the epsilon and infinite parts of the pencil s*E(eps,inf)-A(eps,inf)\nin staircase form using Algorithm 3.3.3 from Beelen's thesis.\n\nOn entry, matrices A and E are assumed to be in staircase form. On exit,\nthe pencil is separated into:\n  - s*E(eps)-A(eps): contains all Kronecker column indices\n  - s*E(inf)-A(inf): contains all infinite elementary divisors\n\nParameters:\n  a (ndarray): M-by-N matrix A (F-order, modified)\n  e (ndarray): M-by-N matrix E (F-order, modified)\n  inuk (ndarray): Row dimensions nu(k) of full-rank submatrices (modified)\n  imuk (ndarray): Column dimensions mu(k) of full-rank submatrices (modified)\n  q (ndarray, optional): M-by-M matrix for row transforms (if updatq=True)\n  z (ndarray, optional): N-by-N matrix for column transforms (if updatz=True)\n  m (int, optional): Number of rows (default: from array shape)\n  n (int, optional): Number of columns (default: from array shape)\n  updatq (bool, optional): Accumulate row transforms in Q (default: True)\n  updatz (bool, optional): Accumulate column transforms in Z (default: True)\n\nReturns:\n  (a, e, q, z, nblcks, inuk, imuk, mnei, info):\n    Transformed matrices, updated block count, dimensions, pencil sizes, exit code.\n    mnei = [meps, neps, minf, ninf] dimensions of epsilon and infinite pencils.\n\nExamples:\n\n>>> from slicot import mb04tx\n>>> import numpy as np\n>>> nblcks = 2\n>>> inuk = np.array([2, 1], dtype=np.int32)\n>>> imuk = np.array([3, 2], dtype=np.int32)\n>>> m = np.sum(inuk)  # 3\n>>> n = np.sum(imuk)  # 5\n>>> a = np.zeros((m, n), dtype=float, order='F')\n>>> e = np.zeros((m, n), dtype=float, order='F')\n>>> a[0, 0] = 1.0\n>>> a[0, 1] = 2.0\n>>> a[0, 2] = 3.0\n>>> a[1, 0] = 0.5\n>>> a[1, 1] = 1.5\n>>> a[1, 2] = 2.5\n>>> a[2, 3] = 1.0\n>>> a[2, 4] = 2.0\n>>> e[0, 1] = 1.0\n>>> e[0, 2] = 2.0\n>>> e[0, 3] = 3.0\n>>> e[1, 2] = 0.5\n>>> e[1, 3] = 1.5\n>>> e[1, 4] = 2.5\n>>> e[2, 4] = 1.0\n>>> q = np.eye(m, dtype=float, order='F')\n>>> z = np.eye(n, dtype=float, order='F')\n>>> a_out, e_out, q_out, z_out, nblcks_out, inuk_out, imuk_out, mnei, info = mb04tx(\n...     a, e, inuk, imuk, q=q, z=z, updatq=True, updatz=True\n...     )\n>>> meps, neps, minf, ninf = mnei\n>>> info\n0",
  "mb04ty": "Triangularize full rank submatrices in staircase pencil.\n\nPerforms triangularization of submatrices with full row and column rank\nin the pencil s*E(eps,inf)-A(eps,inf) using Algorithm 3.3.1 from Beelen's thesis.\n\nOn entry, A and E are assumed to be in generalized Schur form and\ns*E(eps,inf)-A(eps,inf) is in staircase form.\n\nParameters:\n  m (int): Number of rows of A and E, m >= 0\n  n (int): Number of columns of A and E, n >= 0\n  nblcks (int): Number of submatrices with full row rank in A(eps,inf)\n  inuk (ndarray): Row dimensions nu(k) of full-rank submatrices\n  imuk (ndarray): Column dimensions mu(k) of full-rank submatrices\n  a (ndarray): M-by-N matrix A (F-order, modified)\n  e (ndarray): M-by-N matrix E (F-order, modified)\n  q (ndarray): M-by-M transform matrix Q (F-order, modified if updatq=True)\n  z (ndarray): N-by-N transform matrix Z (F-order, modified if updatz=True)\n  updatq (bool, optional): Accumulate row transforms in Q (default: False)\n  updatz (bool, optional): Accumulate column transforms in Z (default: False)\n\nReturns:\n  (a, e, q, z, info): Transformed matrices and exit code.\n    info=0: success\n    info=1: incorrect dimensions of full column rank submatrix (mu(k+1) > nu(k))\n    info=2: incorrect dimensions of full row rank submatrix (nu(k) > mu(k))\n\nExamples:\n\n>>> from slicot import mb04ty\n>>> import numpy as np\n>>> m = 2\n>>> n = 2\n>>> nblcks = 1\n>>> inuk = np.array([2], dtype=np.int32)\n>>> imuk = np.array([2], dtype=np.int32)\n>>> a = np.random.randn(m, n).astype(float, order='F')\n>>> e = np.random.randn(m, n).astype(float, order='F')\n>>> q = np.eye(m, dtype=float, order='F')\n>>> z = np.eye(n, dtype=float, order='F')\n>>> a_out, e_out, q_out, z_out, info = mb04ty(\n...     m, n, nblcks, inuk, imuk, a, e, q, z, updatq=True, updatz=True\n...     )\n>>> info\n0",
  "mb04ud": "Reduce pencil sE-A to column echelon form with orthogonal transformations.\n\nComputes orthogonal Q and Z such that Q'(sE-A)Z has E in column echelon form.\nColumn echelon form: first (N-r) columns are zero, remaining columns have\nlast nonzero element with strictly increasing row indices.\n\nParameters:\n  jobq (str): 'N' - don't form Q, 'I' - init to I, 'U' - update input Q\n  jobz (str): 'N' - don't form Z, 'I' - init to I, 'U' - update input Z\n  m (int): Number of rows in A and E (m >= 0)\n  n (int): Number of columns in A and E (n >= 0)\n  a (ndarray): M-by-N matrix A (F-order, modified in place)\n  e (ndarray): M-by-N matrix E (F-order, modified in place)\n  q (ndarray, optional): M-by-M matrix Q (for jobq='U')\n  z (ndarray, optional): N-by-N matrix Z (for jobz='U')\n  tol (float, optional): Zero tolerance (default: eps*||E||_max)\n\nReturns:\n  (a, e, q, z, ranke, istair, info):\n    a: Transformed Q'*A*Z\n    e: Transformed Q'*E*Z in column echelon form\n    q: Orthogonal row transformation matrix (if jobq='I' or 'U')\n    z: Orthogonal column transformation matrix (if jobz='I' or 'U')\n    ranke: Computed rank of E\n    istair: Staircase structure array (+j=corner, -j=boundary)\n    info: Exit code (0=success, <0=invalid parameter -info)\n\nExamples:\n\n>>> import numpy as np\n>>> m, n = 4, 4\n>>> a = np.array([\n...     [2.0, 0.0, 2.0, -2.0],\n...     [0.0, -2.0, 0.0, 2.0],\n...     [2.0, 0.0, -2.0, 0.0],\n...     [2.0, -2.0, 0.0, 2.0]\n...     ], dtype=float, order='F')\n>>> e = np.array([\n...     [1.0, 0.0, 1.0, -1.0],\n...     [0.0, -1.0, 0.0, 1.0],\n...     [1.0, 0.0, -1.0, 0.0],\n...     [1.0, -1.0, 0.0, 1.0]\n...     ], dtype=float, order='F')\n>>> from slicot import mb04ud\n>>> a_out, e_out, q_out, z_out, ranke, istair, info = mb04ud('N', 'N', m, n, a, e)\n>>> info\n0",
  "mb04vd": "Upper block triangular form for rectangular pencil sE-A.\n\nComputes orthogonal transformations Q and Z such that Q'(sE-A)Z is in upper\nblock triangular form, where E is in column echelon form.\n\nMODE options:\n  'B': Basic reduction to staircase form\n  'T': Triangularization of full rank submatrices\n  'S': Separation of epsilon and infinite parts\n\nParameters:\n  mode (str): 'B', 'T', or 'S' - specifies desired structure\n  jobq (str): 'N', 'I', or 'U' - how to handle Q matrix\n  jobz (str): 'N', 'I', or 'U' - how to handle Z matrix\n  m (int): Number of rows in A, E (order of Q)\n  n (int): Number of columns in A, E (order of Z)\n  ranke (int): Rank of E in column echelon form\n  a (ndarray): M-by-N matrix A (F-order)\n  e (ndarray): M-by-N matrix E in column echelon form (F-order)\n  q (ndarray): Transform matrix Q (F-order)\n  z (ndarray): Transform matrix Z (F-order)\n  istair (ndarray): Column echelon info from MB04UD\n  tol (float, optional): Tolerance for zero elements (default: 0)\n\nReturns:\n  (a, e, q, z, nblcks, nblcki, imuk, inuk, imuk0, mnei, info):\n    Transformed matrices, block counts, dimension arrays, exit code.\n\nExamples:\n\n>>> from slicot import mb04vd\n>>> import numpy as np\n>>> m, n = 2, 4\n>>> a = np.array([\n...     [1.0, 0.0, -1.0, 0.0],\n...     [1.0, 1.0, 0.0, -1.0]\n...     ], dtype=float, order='F')\n>>> e = np.array([\n...     [0.0, -1.0, 0.0, 0.0],\n...     [0.0, -1.0, 0.0, 0.0]\n...     ], dtype=float, order='F')\n>>> a_ud, e_ud, q_ud, z_ud, ranke, istair, info = mb04ud(\n...     'I', 'I', m, n, a.copy(order='F'), e.copy(order='F')\n...     )\n>>> (a_vd, e_vd, q_vd, z_vd, nblcks, nblcki,\n...     imuk, inuk, imuk0, mnei, info_vd) = mb04vd(\n...     'S', 'U', 'U', m, n, ranke, a_ud.copy(order='F'), e_ud.copy(order='F'),\n...     q_ud.copy(order='F'), z_ud.copy(order='F'), istair.copy()\n...     )",
  "mb04vx": "Separate pencils s*E(eps)-A(eps) and s*E(inf)-A(inf) (variant).\n\nSimilar to MB04TX but with NBLCKS as input only and MNEI has 3 elements.\nSeparates the epsilon and infinite parts of the staircase pencil.\n\nParameters:\n  a (ndarray): M-by-N matrix A (F-order, modified)\n  e (ndarray): M-by-N matrix E (F-order, modified)\n  q (ndarray): Transform matrix Q (F-order, modified if updatq=True)\n  z (ndarray): Transform matrix Z (F-order, modified if updatz=True)\n  nblcks (int): Number of full-row-rank submatrices\n  inuk (ndarray): Row dimensions nu(k) (modified)\n  imuk (ndarray): Column dimensions mu(k) (modified)\n  updatq (bool, optional): Accumulate row transforms (default: False)\n  updatz (bool, optional): Accumulate column transforms (default: False)\n\nReturns:\n  (a, e, q, z, inuk, imuk, mnei): Transformed matrices and pencil dimensions.\n    mnei = [meps, neps, minf] dimensions of epsilon and infinite pencils.\n\nExamples:\n\n>>> from slicot import mb04vx\n>>> import numpy as np\n>>> m, n = 3, 4\n>>> nblcks = 2\n>>> inuk = np.array([2, 1], dtype=np.int32)\n>>> imuk = np.array([2, 2], dtype=np.int32)\n>>> a = np.array([\n...     [1.0, 2.0, 0.5, 0.3],\n...     [0.0, 3.0, 1.0, 0.2],\n...     [0.0, 0.0, 2.0, 0.1]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 0.5, 0.3, 0.2],\n...     [0.0, 1.0, 0.4, 0.1],\n...     [0.0, 0.0, 1.0, 0.5]\n...     ], order='F', dtype=float)\n>>> q = np.eye(m, order='F', dtype=float)\n>>> z = np.eye(n, order='F', dtype=float)\n>>> a_out, e_out, q_out, z_out, inuk_out, imuk_out, mnei = mb04vx(\n...     a, e, q, z, nblcks, inuk, imuk, updatq=True, updatz=True\n...     )\n>>> meps, neps, minf = mnei[0], mnei[1], mnei[2]",
  "mb04wd": "Generate matrix Q with orthogonal columns from symplectic reflectors (blocked version).\n\nBlocked version of MB04WU. Generates a matrix Q with orthogonal columns\n(spanning an isotropic subspace), which is defined as the first n columns\nof a product of symplectic reflectors and Givens rotations.\n\nQ is returned as [op(Q1), op(Q2)] where the full symplectic form is:\n  Q = [[op(Q1), op(Q2)], [-op(Q2), op(Q1)]]\n\nParameters:\n  tranq1 (bool): True for Q1 transposed, False for Q1 non-transposed\n  tranq2 (bool): True for Q2 transposed, False for Q2 non-transposed\n  m (int): Number of rows of Q1 and Q2 (m >= 0)\n  n (int): Number of columns of Q1 and Q2 (0 <= n <= m)\n  k (int): Number of symplectic Givens rotations (0 <= k <= n)\n  q1 (ndarray): Input reflectors F(i), output matrix Q1 or Q1' (F-order)\n  q2 (ndarray): Input reflectors H(i) with factors, output Q2 or Q2' (F-order)\n  cs (ndarray): Cosines/sines of Givens rotations G(i), length 2*k\n  tau (ndarray): Scalar factors of reflectors F(i), length k\n\nReturns:\n  (q1, q2, info): Generated orthogonal matrices, exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb04wd\n>>> import numpy as np\n>>> m, n = 3, 3\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [7.0, 8.0, 10.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [0.1, 0.2, 0.3],\n...     [0.4, 0.5, 0.6],\n...     [0.7, 0.8, 0.9]\n...     ], dtype=float, order='F')\n>>> a_qr, b_qr, cs, tau, info_su = mb04su(m, n, a, b)\n>>> k = min(m, n)\n>>> q1_in = a_qr.copy()\n>>> q2_in = b_qr.copy()\n>>> q1, q2, info = mb04wd(False, False, m, n, k, q1_in, q2_in, cs, tau)\n>>> q1_q1t = q1.T @ q1\n>>> q2_q2t = q2.T @ q2\n...     err_msg=\"Q1^T Q1 + Q2^T Q2 should equal I\")\n>>> info\n0",
  "mb04wp": "Generate orthogonal symplectic matrix U from MB04PU output.\n\nGenerates an orthogonal symplectic matrix U defined as a product of\nsymplectic reflectors and Givens rotations as returned by MB04PU.\nThe matrix U is returned in terms of its first N rows:\n  U = [[U1, U2], [-U2, U1]]\n\nParameters:\n  n (int): Order of matrices U1 and U2 (n >= 0)\n  ilo (int): Same value as in previous MB04PU call. U is identity except\n             in submatrix U([ilo+1:n n+ilo+1:2n], [ilo+1:n n+ilo+1:2n]).\n             1 <= ilo <= max(1,n)\n  u1 (ndarray): N-by-N matrix. Input: reflector vectors F(i) in columns.\n                Output: U1 (F-order)\n  u2 (ndarray): N-by-N matrix. Input: reflector vectors H(i) and scalars\n                on subdiagonal. Output: U2 (F-order)\n  cs (ndarray): Cosines/sines of Givens rotations G(i), length 2*n-2\n  tau (ndarray): Scalar factors of reflectors F(i), length n-1\n\nReturns:\n  (u1, u2, info): Generated orthogonal symplectic matrix blocks, exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb04wp\n>>> import numpy as np\n>>> n = 5\n>>> ilo = 1\n>>> a = np.array([\n...     [0.9501, 0.7621, 0.6154, 0.4057, 0.0579],\n...     [0.2311, 0.4565, 0.7919, 0.9355, 0.3529],\n...     [0.6068, 0.0185, 0.9218, 0.9169, 0.8132],\n...     [0.4860, 0.8214, 0.7382, 0.4103, 0.0099],\n...     [0.8913, 0.4447, 0.1763, 0.8936, 0.1389],\n...     ], dtype=float, order='F')\n>>> qg = np.array([\n...     [0.4055, 0.3869, 1.3801, 0.7993, 1.2019, 0.8780],\n...     [0.2140, 1.4936, 0.7567, 1.7598, 1.1956, 0.9029],\n...     [1.0224, 1.2913, 1.0503, 1.6433, 0.9346, 1.6565],\n...     [1.1103, 0.9515, 0.8839, 0.7590, 0.6824, 1.1022],\n...     [0.7016, 1.1755, 1.1010, 1.1364, 0.3793, 0.7408],\n...     ], dtype=float, order='F')\n>>> a_pvl, qg_pvl, cs, tau, info_pu = mb04pu(n, ilo, a, qg)\n>>> u1_in = np.tril(a_pvl).copy(order='F')\n>>> u2_in = np.tril(qg_pvl[:, :n]).copy(order='F')\n>>> u1, u2, info = mb04wp(n, ilo, u1_in, u2_in, cs, tau)\n...     u1[:, j] *= -1\n...     u2[:, j] *= -1\n...     break\n>>> info\n0",
  "mb04wr": "Generate orthogonal symplectic matrices U or V from symplectic reflectors.\n\nGenerates orthogonal symplectic matrices U or V, defined as products of\nsymplectic reflectors and Givens rotations, as returned by MB04TS or MB04TB.\n\nThe matrices U and V are returned in terms of their first N/2 rows:\n  U = [[U1, U2], [-U2, U1]]\n  V = [[V1, V2], [-V2, V1]]\n\nParameters:\n  job (str): 'U' to generate U, 'V' to generate V\n  trans (str): Must match TRANA (job='U') or TRANB (job='V') from MB04TS/MB04TB.\n               'N' for no transpose, 'T'/'C' for transpose\n  n (int): Order of matrices Q1 and Q2 (n >= 0)\n  ilo (int): Same value as in previous MB04TS/MB04TB call.\n             1 <= ilo <= max(1,n)\n  q1 (ndarray): N-by-N matrix. Input: reflector vectors FU/FV(i).\n                Output: U1/V1 or their transposes depending on job/trans (F-order)\n  q2 (ndarray): N-by-N matrix. Input: reflector vectors HU/HV(i).\n                Output: U2 or V2^T depending on job (F-order)\n  cs (ndarray): Cosines/sines of Givens rotations, length 2n (job='U') or 2n-2 (job='V')\n  tau (ndarray): Scalar factors of reflectors, length n (job='U') or n-1 (job='V')\n\nReturns:\n  (q1, q2, info): Generated orthogonal symplectic matrix blocks, exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb04wr\n>>> import numpy as np\n>>> n = 4\n>>> ilo = 1\n>>> A = np.random.randn(n, n).astype(float, order='F')\n>>> B = np.random.randn(n, n).astype(float, order='F')\n>>> G = np.random.randn(n, n)\n>>> G = (G + G.T).astype(float, order='F')\n>>> Q = np.random.randn(n, n).astype(float, order='F')\n>>> A_out, B_out, G_out, Q_out, csl, csr, taul, taur, info = mb04ts(\n...     'N', 'N', n, ilo, A.copy(), B.copy(), G.copy(), Q.copy()\n...     )\n>>> q1 = A_out.copy()\n>>> q2 = Q_out.copy()\n>>> q1_out, q2_out, info = mb04wr('U', 'N', n, ilo, q1, q2, csl, taul)\n>>> info\n0",
  "mb04wu": "Generate matrix Q with orthogonal columns from symplectic reflectors and Givens rotations.\n\nGenerates a matrix Q with orthogonal columns (spanning an isotropic subspace),\nwhich is defined as the first n columns of a product of symplectic reflectors\nand Givens rotations. This is the inverse operation of MB04SU.\n\nQ is returned as [op(Q1), op(Q2)] where the full symplectic form is:\n  Q = [[op(Q1), op(Q2)], [-op(Q2), op(Q1)]]\n\nParameters:\n  tranq1 (bool): True for Q1 transposed, False for Q1 non-transposed\n  tranq2 (bool): True for Q2 transposed, False for Q2 non-transposed\n  m (int): Number of rows of Q1 and Q2 (m >= 0)\n  n (int): Number of columns of Q1 and Q2 (0 <= n <= m)\n  k (int): Number of symplectic Givens rotations (0 <= k <= n)\n  q1 (ndarray): Input reflectors F(i), output matrix Q1 or Q1' (F-order)\n  q2 (ndarray): Input reflectors H(i) with factors, output Q2 or Q2' (F-order)\n  cs (ndarray): Cosines/sines of Givens rotations G(i), length 2*k\n  tau (ndarray): Scalar factors of reflectors F(i), length k\n\nReturns:\n  (q1, q2, info): Generated orthogonal matrices, exit code (0=success)\n\nExamples:\n\n>>> from slicot import mb04wu\n>>> import numpy as np\n>>> m, n = 3, 3\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [7.0, 8.0, 10.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [0.1, 0.2, 0.3],\n...     [0.4, 0.5, 0.6],\n...     [0.7, 0.8, 0.9]\n...     ], dtype=float, order='F')\n>>> a_qr, b_qr, cs, tau, info_su = mb04su(m, n, a, b)\n>>> k = min(m, n)\n>>> q1_in = a_qr.copy()\n>>> q2_in = b_qr.copy()\n>>> q1, q2, info = mb04wu(False, False, m, n, k, q1_in, q2_in, cs, tau)\n>>> q1_q1t = q1.T @ q1\n>>> q2_q2t = q2.T @ q2\n...     err_msg=\"Q1^T Q1 + Q2^T Q2 should equal I\")\n>>> info\n0",
  "mb04xd": "Compute basis for left/right singular subspace for smallest singular values.\n\nComputes a basis for the left and/or right singular subspace of an M-by-N\nmatrix A corresponding to its smallest singular values using Partial Singular\nValue Decomposition (PSVD).\n\nParameters:\n  jobu (str): 'N' = don't compute left subspace, 'A' = return (M-RANK) base\n              vectors in U, 'S' = return first (min(M,N)-RANK) vectors\n  jobv (str): 'N' = don't compute right subspace, 'A' = return (N-RANK) base\n              vectors in V, 'S' = return first (min(M,N)-RANK) vectors\n  a (ndarray): M-by-N matrix A (F-order, destroyed on exit)\n  rank (int): If < 0, compute rank as number of singular values > theta.\n              Otherwise specifies desired rank (rank <= min(M,N)).\n  theta (float): If rank < 0, upper bound on smallest singular values (>= 0).\n                 Otherwise initial estimate for computing upper bound.\n  tol (float): Tolerance for negligible elements and singular value multiplicity.\n               If <= 0, default tolerance is used.\n  reltol (float): Relative tolerance for bisection interval width.\n                  If < base*eps, base*eps is used.\n\nReturns:\n  (rank, theta, u, v, q, inul, iwarn, info):\n    Computed/adjusted rank; computed upper bound (if rank >= 0 on entry);\n    U matrix (or None if jobu='N'); V matrix (or None if jobv='N');\n    partially diagonalized bidiagonal q[0:p] diagonal, q[p:2p-1] superdiagonal;\n    boolean array where True indicates subspace basis columns;\n    warning (1 = rank lowered due to multiplicity);\n    exit code (0 = success, 1 = max QR/QL iterations exceeded)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb04xd\n>>> m, n = 6, 4\n>>> rank_in = -1\n>>> theta_in = 0.001\n>>> tol = 0.0\n>>> reltol = 0.0\n>>> jobu = 'A'\n>>> jobv = 'A'\n>>> a = np.array([\n...     [0.80010, 0.39985, 0.60005, 0.89999],\n...     [0.29996, 0.69990, 0.39997, 0.82997],\n...     [0.49994, 0.60003, 0.20012, 0.79011],\n...     [0.90013, 0.20016, 0.79995, 0.85002],\n...     [0.39998, 0.80006, 0.49985, 0.99016],\n...     [0.20002, 0.90007, 0.70009, 1.02994],\n...     ], order='F', dtype=float)\n>>> rank, theta, u, v, q, inul, iwarn, info = mb04xd(\n...     jobu, jobv, a, rank_in, theta_in, tol, reltol\n...     )\n>>> p = min(m, n)\n>>> info\n0",
  "mb04xy": "Apply Householder transformations from bidiagonalization to matrices.\n\nApplies the Householder transformations Pj stored in factored form into\nthe columns of array X, to the desired columns of matrix U by premultiplication,\nand/or the Householder transformations Qj stored in factored form into the\nrows of array X, to the desired columns of matrix V by premultiplication.\nThe Householder transformations Pj and Qj are stored as produced by DGEBRD.\n\nParameters:\n  jobu (str): 'N' - don't transform U, 'A' - transform U (M columns),\n              'S' - transform U (min(M,N) columns)\n  jobv (str): 'N' - don't transform V, 'A' - transform V (N columns),\n              'S' - transform V (min(M,N) columns)\n  m (int): Number of rows of matrix X (m >= 0)\n  n (int): Number of columns of matrix X (n >= 0)\n  x (ndarray): M-by-N matrix with Householder vectors (F-order, modified but restored)\n  taup (ndarray): Scalar factors of Pj transformations, length min(m,n)\n  tauq (ndarray): Scalar factors of Qj transformations, length min(m,n)\n  u (ndarray, optional): Matrix U to transform (F-order, required unless jobu='N')\n  v (ndarray, optional): Matrix V to transform (F-order, required unless jobv='N')\n  inul (ndarray): Boolean array of length max(m,n). inul[i]=True to transform column i.\n\nReturns:\n  (u, v, info): Transformed matrices, exit code (0=success, <0=-i param error)\n\nExamples:\n\n>>> import numpy as np\n>>> m, n = 4, 3\n>>> p = min(m, n)\n>>> x = np.random.randn(m, n).astype(float, order='F')\n>>> taup = np.zeros(p, dtype=float)\n>>> tauq = np.zeros(p, dtype=float)\n>>> u = np.eye(m, dtype=float, order='F')\n>>> v = np.eye(n, dtype=float, order='F')\n>>> inul = np.ones(max(m, n), dtype=bool)\n>>> from slicot import mb04xy\n>>> u_out, v_out, info = mb04xy('A', 'A', m, n, x, taup, tauq, u, v, inul)\n>>> info\n0",
  "mb04yd": "Partial diagonalization of a bidiagonal matrix.\n\nPartially diagonalizes a bidiagonal matrix J using QR or QL iterations\nsuch that J is split into unreduced bidiagonal submatrices whose singular\nvalues are either all larger than a given bound or all smaller than (or\nequal to) this bound.\n\nThe left- and right-hand Givens rotations performed on J may be optionally\naccumulated in matrices U and V.\n\nParameters:\n  jobu (str): 'N' do not form U, 'I' initialize U to identity and accumulate,\n              'U' update given matrix U\n  jobv (str): 'N' do not form V, 'I' initialize V to identity and accumulate,\n              'U' update given matrix V\n  m (int): Number of rows of matrix U (m >= 0)\n  n (int): Number of rows of matrix V (n >= 0)\n  rank (int): If < 0, compute rank as number of singular values > theta.\n              Otherwise specifies desired rank (rank <= min(m,n)).\n  theta (float): If rank < 0, upper bound on smallest singular values (>= 0).\n                 Otherwise initial estimate for computing upper bound.\n  q (ndarray): Diagonal elements of J, length min(m,n) (F-order)\n  e (ndarray): Superdiagonal elements of J, length min(m,n)-1 (F-order)\n  tol (float): Tolerance for negligible elements and singular value multiplicity.\n               If <= 0, taken as eps * max(|q|, |e|).\n  reltol (float): Relative tolerance for bisection interval width.\n                  If < base*eps, taken as base*eps.\n  u (ndarray, optional): Matrix U (required if jobu='U')\n  v (ndarray, optional): Matrix V (required if jobv='U')\n\nReturns:\n  Depends on jobu/jobv:\n  - jobu='N', jobv='N': (q, e, theta, rank, inul, iwarn, info)\n  - jobu='I'/'U': (q, e, u, theta, rank, inul, iwarn, info)\n  - jobv='I'/'U': (q, e, v, theta, rank, inul, iwarn, info)\n  - both: (q, e, u, v, theta, rank, inul, iwarn, info)\n  where inul (bool array) indicates elements with singular values <= theta.\n\nExamples:\n\n>>> from slicot import mb04yd\n>>> import numpy as np\n>>> m = 5\n>>> n = 5\n>>> p = min(m, n)\n>>> q = np.array([1.0, 2.0, 3.0, 4.0, 5.0], dtype=float, order='F')\n>>> e = np.array([2.0, 3.0, 4.0, 5.0], dtype=float, order='F')\n>>> theta = 2.0\n>>> rank = -1\n>>> tol = 0.0\n>>> reltol = 0.0\n>>> q_out, e_out, theta_out, rank_out, inul_out, iwarn, info = mb04yd(\n...     'N', 'N', m, n, rank, theta, q, e, tol, reltol\n...     )\n>>> info\n0",
  "mb04yw": "Perform one QR or QL iteration step on bidiagonal submatrix.\n\nPerforms either one QR or QL iteration step onto the unreduced bidiagonal\nsubmatrix Jk (from index l to k) of a bidiagonal matrix J. The submatrix Jk\nis transformed to S' Jk T where S and T are products of Givens rotations.\nOptionally accumulates these rotations into U and V matrices.\n\nParameters:\n  qrit (bool): True for QR iteration (top to bottom), False for QL (bottom to top)\n  updatu (bool): True to accumulate left rotations S into U\n  updatv (bool): True to accumulate right rotations T into V\n  m (int): Number of rows of matrix U (m >= 0)\n  n (int): Number of rows of matrix V (n >= 0)\n  l (int): Index of first diagonal entry of submatrix (1-based, l >= 1)\n  k (int): Index of last diagonal entry of submatrix (1-based, k <= min(m,n))\n  shift (float): Shift value for QR/QL iteration step\n  d (ndarray): Diagonal entries of bidiagonal J, length min(m,n) (F-order, modified)\n  e (ndarray): Superdiagonal entries of J, length min(m,n)-1 (F-order, modified)\n  u (ndarray, optional): M-by-p left transformation matrix (F-order, required if updatu)\n  v (ndarray, optional): N-by-p right transformation matrix (F-order, required if updatv)\n\nReturns:\n  (d, e, u, v, info): Transformed diagonal/superdiagonal, updated U/V, exit code (0=success)\n\nExamples:\n\n>>> import numpy as np\n>>> m, n = 4, 4\n>>> p = min(m, n)\n>>> d = np.abs(np.random.randn(p)) + 0.1\n>>> e = np.random.randn(p - 1) * 0.5\n>>> j = np.diag(d) + np.diag(e, 1)\n>>> d_out = d.astype(float, order='F').copy()\n>>> e_out = e.astype(float, order='F').copy()\n>>> l, k = 1, p\n>>> from slicot import mb04yw\n>>> d_res, e_res, u_out, v_out, info = mb04yw(\n...     True, False, False, m, n, l, k, 0.0,\n...     d_out, e_out, None, None\n...     )\n>>> j_new = np.diag(d_res) + np.diag(e_res, 1)\n>>> jtj_new = j_new.T @ j_new\n>>> eig_new = np.sort(np.linalg.eigvalsh(jtj_new))\n>>> info\n0",
  "mb04zd": "Hamiltonian matrix square-reduction.\n\nTransforms Hamiltonian H=[[A,G],[Q,-A^T]] to square-reduced form\nH'=[[A',G'],[Q',-A'^T]] by orthogonal symplectic similarity.\nSquare-reduced: Q'A' - A'^T Q' = 0.\n\nParameters:\n  compu (str): 'N' - no transform, 'I'/'F' - compute U, 'V'/'A' - accumulate\n  n (int): Order of matrices A, G, Q (n >= 0)\n  a (ndarray): N-by-N matrix A (F-order, modified)\n  qg (ndarray): N-by-(N+1) packed Q,G (F-order, modified)\n               Q in lower triangular, G in upper triangular cols 1:n\n  u (ndarray, optional): N-by-2N transform matrix (for 'V'/'A' modes)\n\nReturns:\n  (a, qg, u, info): Square-reduced matrices and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> n = 3\n>>> compu = 'N'\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [4.0, 5.0, 6.0],\n...     [7.0, 8.0, 9.0]\n...     ], dtype=float, order='F')\n>>> g_upper = np.array([\n...     [1.0, 1.0, 1.0],\n...     [0.0, 2.0, 2.0],\n...     [0.0, 0.0, 3.0]\n...     ], dtype=float, order='F')\n>>> q_lower = np.array([\n...     [7.0, 0.0, 0.0],\n...     [6.0, 8.0, 0.0],\n...     [5.0, 4.0, 9.0]\n...     ], dtype=float, order='F')\n>>> qg = np.zeros((n, n+1), dtype=float, order='F')\n...     qg[i, j] = q_lower[i, j]\n...     qg[i, j+1] = g_upper[i, j]\n>>> from slicot import mb04zd\n>>> a_out, qg_out, u_out, info = mb04zd(compu, n, a, qg)\n...     rtol=1e-3, atol=1e-4)\n...     rtol=1e-3, atol=1e-4)\n>>> info\n0",
  "mb05md": "Matrix exponential for a real non-defective matrix.\n\nComputes exp(A*delta) where A is a real N-by-N non-defective matrix\nusing eigenvalue/eigenvector decomposition (Moler-Van Loan Method 15).\n\nParameters:\n  balanc (str): 'N' - no scaling, 'S' - diagonal scaling\n  n (int): Order of matrix A (n >= 0)\n  delta (float): Scalar time parameter\n  a (ndarray): N-by-N matrix A (F-order, modified in place)\n\nReturns:\n  (exp_a_delta, v, y, valr, vali, info):\n    exp_a_delta: exp(A*delta)\n    v: Eigenvector matrix\n    y: Intermediate matrix (exp(A*delta) = V*Y)\n    valr: Real parts of eigenvalues\n    vali: Imaginary parts of eigenvalues\n    info: Exit code\n\nExamples:\n\n>>> from slicot import mb05md\n>>> import numpy as np\n>>> n = 4\n>>> delta = 1.0\n>>> a = np.array([\n...     [0.5, 0.0, 2.3, -2.6],\n...     [0.0, 0.5, -1.4, -0.7],\n...     [2.3, -1.4, 0.5, 0.0],\n...     [-2.6, -0.7, 0.0, 0.5],\n...     ], order='F', dtype=float)\n>>> exp_a_delta, v, y, valr, vali, info = mb05md('N', n, delta, a)\n>>> eig_computed = valr + 1j * vali\n...     sorted(eig_computed, key=lambda x: (x.real, x.imag)),\n...     rtol=1e-3, atol=1e-4\n>>> )\n...     if vali[i] == 0:  # Real eigenvalue\n...     f\"Eigenvector {i} failed: ||A*v - \u03bb*v|| = {np.linalg.norm(residual)}\"\n>>> mapping = {}\n...     mapping[i] = j\n...     break\n...     j = mapping[i]\n...     v_comp = v[:, i]\n...     np.allclose(v_comp, -v_exp, rtol=1e-3, atol=1e-4)), \\\n...     f\"Eigenvector {i} doesn't match expected column {j} (\u03bb={valr[i]})\"\n>>> info\n0",
  "mb05my": "Schur form, eigenvalues, and right eigenvectors.\n\nComputes for an N-by-N real nonsymmetric matrix A:\n  - Orthogonal matrix Q reducing A to real Schur form T\n  - Eigenvalues (WR + i*WI)\n  - Right eigenvectors R of T (upper triangular)\n\nParameters:\n  balanc (str): 'N' - no scaling, 'S' - diagonal scaling\n  a (ndarray): N-by-N matrix A (F-order)\n\nReturns:\n  (wr, wi, r, q, t, info): Eigenvalues, eigenvectors, Schur form\n\nExamples:\n\n>>> from slicot import mb05my\n>>> import numpy as np\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [0.0, 2.0, 1.0],\n...     [0.0, 0.0, 3.0],\n...     ], order='F', dtype=float)\n>>> wr, wi, r, q, t, info = mb05my('N', a)\n>>> eig_computed = np.sort(wr)\n>>> info\n0",
  "mb05nd": "Matrix exponential and integral.\n\nComputes F(delta) = exp(A*delta) and\nH(delta) = integral from 0 to delta of exp(A*s) ds.\n\nParameters:\n  n (int): Order of matrix A (n >= 0)\n  delta (float): Scalar time parameter\n  a (ndarray): n-by-n matrix A (F-order)\n  tol (float): Tolerance for Pade approximation order\n\nReturns:\n  (ex, exint, info): exp(A*delta), integral H(delta), exit code\n\nExamples:\n\n>>> from slicot import mb05nd\n>>> import numpy as np\n>>> n = 5\n>>> delta = 0.1\n>>> tol = 0.0001\n>>> a = np.array([\n...     [5.0, 4.0, 3.0, 2.0, 1.0],\n...     [1.0, 6.0, 0.0, 4.0, 3.0],\n...     [2.0, 0.0, 7.0, 6.0, 5.0],\n...     [1.0, 3.0, 1.0, 8.0, 7.0],\n...     [2.0, 5.0, 7.0, 1.0, 9.0],\n...     ], order='F', dtype=float)\n>>> ex, exint, info = mb05nd(n, delta, a, tol)\n>>> info\n0",
  "mb05od": "Matrix exponential with accuracy estimate.\n\nComputes exp(A*delta) where A is real N-by-N matrix using diagonal\nPade approximation with scaling and squaring.\n\nParameters:\n  balanc (str): 'N' - no balancing, 'S' - use scaling (via MB04MD)\n  n (int): Order of matrix A (n >= 0)\n  ndiag (int): Order of diagonal Pade approximant (1-15, default 9)\n  delta (float): Scalar time parameter\n  a (ndarray): N-by-N matrix A (F-order, modified in place)\n\nReturns:\n  (exp_a, mdig, idig, iwarn, info):\n    exp_a: exp(A*delta)\n    mdig: Minimal accurate digits in 1-norm of result\n    idig: Accurate digits at 95% confidence level\n    iwarn: Warning (0=ok, 1=possible, 2=severe inaccuracy, 3=balancing unused)\n    info: Exit code (0=ok, 1=norm too large, 2=singular, 3=overflow)\n\nExamples:\n\n>>> from slicot import mb05od\n>>> import numpy as np\n>>> n = 3\n>>> delta = 1.0\n>>> ndiag = 9\n>>> balanc = 'S'\n>>> a = np.array([\n...     [2.0, 1.0, 1.0],\n...     [0.0, 3.0, 2.0],\n...     [1.0, 0.0, 4.0],\n...     ], order='F', dtype=float)\n>>> exp_a, mdig, idig, iwarn, info = mb05od(balanc, n, ndiag, delta, a)\n>>> info\n0",
  "mb05oy": "Restore matrix after balancing transformations.\n\nComputes A <- P * D * A * D^{-1} * P' where P is permutation,\nD is diagonal scaling from DGEBAL.\n\nParameters:\n  job (str): 'N'=nothing, 'P'=permute, 'S'=scale, 'B'=both\n  n (int): Order of matrix A (n >= 0)\n  low (int): Low index from DGEBAL (1-based)\n  igh (int): High index from DGEBAL (1-based)\n  a (ndarray): N-by-N matrix (F-order, modified)\n  scale (ndarray): Permutation/scaling from DGEBAL\n\nReturns:\n  (a, info): Back-transformed matrix and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mb05oy\n>>> n = 4\n>>> low = 1  # 1-based\n>>> igh = 4  # 1-based\n>>> scale = np.array([1.0, 2.0, 4.0, 8.0], dtype=float)\n>>> D = np.diag(scale)\n>>> D_inv = np.diag(1.0 / scale)\n>>> a_test = a_balanced.copy(order='F')\n>>> a_out, info = mb05oy('S', n, low, igh, a_test, scale)\n>>> info\n0",
  "mb3jzp": "Reorder eigenvalues of complex skew-Hamiltonian/Hamiltonian pencil (panel variant).\n\nPanel-based blocked variant of MB03JZ for better performance on large matrices.\nMoves eigenvalues with strictly negative real parts of an N-by-N complex\nskew-Hamiltonian/Hamiltonian pencil aS - bH in structured Schur form to the\nleading principal subpencil, while keeping the triangular form.\n\nOn entry: S = [[A, D], [0, A']], H = [[B, F], [0, -B']]\nwhere A, B are upper triangular, D is skew-Hermitian, F is Hermitian.\n\nParameters:\n  compq (str): 'N'=no Q, 'I'=init Q to identity, 'U'=update Q\n  n (int): Order of the pencil (n >= 0, even)\n  a (ndarray): Upper triangular matrix A (n/2 x n/2, F-order, complex)\n  d (ndarray): Skew-Hermitian matrix D upper part (n/2 x n/2, F-order, complex)\n  b (ndarray): Upper triangular matrix B (n/2 x n/2, F-order, complex)\n  f (ndarray): Hermitian matrix F upper part (n/2 x n/2, F-order, complex)\n  q (ndarray, optional): Unitary matrix Q (n x n, F-order, complex)\n  tol (float, optional): Tolerance for eigenvalue sign (default: MIN(N,10)*EPS)\n\nReturns:\n  (a, d, b, f, q, neig, info):\n    a, d, b, f: Transformed matrices (complex)\n    q: Unitary matrix Q (complex)\n    neig (int): Number of eigenvalues with negative real part\n    info (int): 0 = success, <0 = -i means i-th argument invalid\n\nExamples:\n\n>>> from slicot import mb3jzp\n>>> import numpy as np\n>>> m = 2  # n = 2*m = 4\n>>> n = 2 * m\n>>> a = np.array([[1.0 + 0.0j, 0.3 - 0.2j],\n...     [0.0, 2.0 + 0.0j]], dtype=complex, order='F')\n>>> b = np.array([[1.0 + 0.0j, 0.2 + 0.1j],\n...     [0.0, 3.0 + 0.0j]], dtype=complex, order='F')\n>>> d = np.array([[0.5j, 0.1 + 0.2j],\n...     [0.0, -0.3j]], dtype=complex, order='F')\n>>> f = np.array([[1.0, 0.2 - 0.1j],\n...     [0.0, 0.8]], dtype=complex, order='F')\n>>> a_out, d_out, b_out, f_out, q_out, neig, info = mb3jzp(\n...     'I', n, a.copy(order='F'), d.copy(order='F'),\n...     b.copy(order='F'), f.copy(order='F')\n...     )\n...     rtol=1e-14, atol=1e-14)\n>>> info\n0",
  "mb3lzp": "Eigenvalues and deflating subspace of complex skew-Hamiltonian/Hamiltonian pencil.\n\nComputes eigenvalues of a complex N-by-N skew-Hamiltonian/Hamiltonian pencil\naS - bH where:\n  S = [[A, D], [E, A']], with D skew-Hermitian, E skew-Hermitian\n  H = [[B, F], [G, -B']], with F Hermitian, G Hermitian\n\nThe routine embeds the complex pencil into a real skew-Hamiltonian/\nskew-Hamiltonian pencil, applies MB04FP for the structured Schur form,\nMB3JZP to reorder eigenvalues, and optionally computes the right\ndeflating subspace via QR with pivoting or SVD.\n\nParameters:\n  compq (str): 'N'=eigenvalues only, 'C'=also compute deflating subspace\n  orth (str): Orthogonalization method (if compq='C'): 'P'=QR with pivoting, 'S'=SVD\n  n (int): Order of pencil (n >= 0, must be even)\n  a (ndarray): N/2-by-N/2 complex matrix A (F-order)\n  de (ndarray): N-by-N complex packed D and E matrices (F-order)\n  b (ndarray): N/2-by-N/2 complex matrix B (F-order)\n  fg (ndarray): N-by-N complex packed F and G matrices (F-order)\n\nReturns:\n  If compq='N':\n    (alphar, alphai, beta, neig, info)\n  If compq='C':\n    (a, de, b, fg, q, alphar, alphai, beta, neig, info)\n  where:\n    a, de, b, fg: Transformed matrices (complex)\n    q: 2N-by-2N complex unitary matrix, leading N-by-NEIG columns contain\n       orthonormal basis of right deflating subspace\n    alphar, alphai, beta: Eigenvalue components (lambda = (alphar+i*alphai)/beta)\n    neig: Number of eigenvalues with negative real part\n    info: 0=success, 1=MB04FP QZ failed, 2=ZHGEQZ failed, 3=ZGESVD failed, 4=singular\n\nExamples:\n\n>>> from slicot import mb3lzp\n>>> import numpy as np\n>>> m = 2  # n = 2*m = 4\n>>> n = 2 * m\n>>> a, de, b, fg = make_test_pencil(m)\n>>> alphar, alphai, beta, neig, info = mb3lzp(\n...     'N', 'P', n, a.copy(order='F'), de.copy(order='F'),\n...     b.copy(order='F'), fg.copy(order='F')\n...     )\n>>> info\n0",
  "mb3oyz": "Complex rank-revealing QR factorization with column pivoting.\n\nComputes truncated QR factorization A*P = Q*R with column pivoting,\nestimating effective rank using incremental condition estimation.\n\nParameters:\n  m (int): Number of rows (m >= 0)\n  n (int): Number of columns (n >= 0)\n  a (ndarray): Complex matrix (m x n, F-order)\n  rcond (float): Rank threshold (0 <= rcond <= 1)\n  svlmax (float): Estimate of largest singular value, or 0\n\nReturns:\n  (a, rank, info, sval, jpvt, tau): QR factors, rank, exit code,\n    singular value estimates, column permutation, reflector factors\n\nExamples:\n\n>>> from slicot import mb3oyz\n>>> import numpy as np\n>>> m, n = 6, 4\n>>> rcond = 1.0e-10\n>>> svlmax = 0.0\n>>> U = np.linalg.qr(np.random.randn(m, m) + 1j * np.random.randn(m, m))[0]\n>>> V = np.linalg.qr(np.random.randn(n, n) + 1j * np.random.randn(n, n))[0]\n>>> sigma = np.array([10.0, 5.0, 2.0, 1e-14])\n>>> Sigma = np.zeros((m, n), dtype=complex)\n...     Sigma[i, i] = sigma[i]\n>>> a = U @ Sigma @ V.conj().T\n>>> a = np.asfortranarray(a)\n>>> true_rank = np.linalg.matrix_rank(a, tol=rcond * sigma[0])\n>>> a_result, rank, info, sval, jpvt, tau = mb3oyz(m, n, a.copy(), rcond, svlmax)\n>>> info\n0",
  "mb3pyz": "Complex rank-revealing RQ factorization with row pivoting.\n\nComputes truncated RQ factorization P*A = R*Q with row pivoting,\nestimating effective rank using incremental condition estimation.\n\nParameters:\n  m (int): Number of rows (m >= 0)\n  n (int): Number of columns (n >= 0)\n  a (ndarray): Complex matrix (m x n, F-order)\n  rcond (float): Rank threshold (0 <= rcond <= 1)\n  svlmax (float): Estimate of largest singular value, or 0\n\nReturns:\n  (a, rank, info, sval, jpvt, tau): RQ factors, rank, exit code,\n    singular value estimates, row permutation, reflector factors\n\nExamples:\n\n>>> from slicot import mb3pyz\n>>> import numpy as np\n>>> m, n = 4, 6\n>>> rcond = 1.0e-10\n>>> svlmax = 0.0\n>>> U = np.linalg.qr(np.random.randn(m, m) + 1j * np.random.randn(m, m))[0]\n>>> V = np.linalg.qr(np.random.randn(n, n) + 1j * np.random.randn(n, n))[0]\n>>> sigma = np.array([10.0, 5.0, 2.0, 1e-14])\n>>> Sigma = np.zeros((m, n), dtype=complex)\n...     Sigma[i, i] = sigma[i]\n>>> a = U @ Sigma @ V.conj().T\n>>> a = np.asfortranarray(a)\n>>> true_rank = np.linalg.matrix_rank(a, tol=rcond * sigma[0])\n>>> a_result, rank, info, sval, jpvt, tau = mb3pyz(m, n, a.copy(), rcond, svlmax)\n>>> info\n0",
  "mb4dbz": "Inverse balancing transformation for complex skew-Hamiltonian/Hamiltonian eigenvectors.\n\nApplies from the left the inverse of a balancing transformation computed by MB4DPZ\nto the complex matrix [[V1], [sgn*V2]] where sgn is +1 or -1.\n\nParameters:\n  job (str): 'N' - do nothing, 'P' - permutation only, 'S' - scaling only, 'B' - both\n  sgn (str): 'P' - sgn=+1, 'N' - sgn=-1\n  n (int): Number of rows of V1 and V2 (n >= 0)\n  ilo (int): Index from MB4DPZ (1 <= ilo <= n+1)\n  lscale (ndarray): Permutation and left scaling factors (dimension n)\n  rscale (ndarray): Permutation and right scaling factors (dimension n)\n  v1 (ndarray): Complex N-by-M matrix V1 (F-order, modified in place)\n  v2 (ndarray): Complex N-by-M matrix V2 (F-order, modified in place)\n\nReturns:\n  (v1, v2, info): Modified matrices and exit code (info=0: success, <0: -info arg illegal)\n\nExamples:\n\n>>> from slicot import mb4dbz\n>>> import numpy as np\n>>> n = 3\n>>> m = 2\n>>> ilo = 1\n>>> v1 = (np.random.randn(n, m) + 1j * np.random.randn(n, m)).astype(\n...     complex, order='F')\n>>> v2 = (np.random.randn(n, m) + 1j * np.random.randn(n, m)).astype(\n...     complex, order='F')\n>>> lscale = np.array([2.0, 0.5, 4.0], dtype=float)\n>>> rscale = np.array([0.25, 8.0, 1.0], dtype=float)\n>>> v1_out, v2_out, info = mb4dbz('S', 'P', n, ilo, lscale, rscale, v1, v2)\n>>> info\n0",
  "mb4dlz": "Balance a complex matrix pencil (A,B).\n\nBalances a pair of N-by-N complex matrices (A,B) by equivalence transformations.\nThis involves permuting to isolate eigenvalues and/or diagonal scaling to make\nrows and columns as close in 1-norm as possible. Improves eigenvalue accuracy.\n\nParameters:\n  job (str): 'N' - none, 'P' - permute only, 'S' - scale only, 'B' - both\n  n (int): Order of matrices A and B (n >= 0)\n  thresh (float): Threshold for scaling (see SLICOT docs for negative values)\n  a (ndarray): Complex N-by-N matrix A (F-order, modified in place)\n  b (ndarray): Complex N-by-N matrix B (F-order, modified in place)\n\nReturns:\n  (a, b, ilo, ihi, lscale, rscale, dwork, iwarn, info):\n    a, b: Balanced matrices\n    ilo, ihi: Indices of isolated eigenvalues (1-based)\n    lscale: Left permutation/scaling factors\n    rscale: Right permutation/scaling factors\n    dwork: Contains initial/final 1-norms and threshold used\n    iwarn: Warning indicator (0=ok, 1=scaling reset to 1)\n    info: Exit code (0=success, <0: -info arg illegal)\n\nExamples:\n\n>>> from slicot import mb4dlz\n>>> import numpy as np\n>>> n = 4\n>>> a = np.array([\n...     [1+0.5j, 0, -1e-12, 0],\n...     [0, -2-1j, 0, 0],\n...     [1, -1-0.5j, -1+0.5j, 0],\n...     [-1+0.5j, -1, 0, 2-1j]\n...     ], order='F', dtype=np.complex128)\n>>> b = np.array([\n...     [1+0.5j, 0, 0, 0],\n...     [0, 1+0.5j, 0, 0],\n...     [0, 0, 1-0.5j, 0],\n...     [0, 0, 0, 1-0.5j]\n...     ], order='F', dtype=np.complex128)\n>>> a_out, b_out, ilo, ihi, lscale, rscale, dwork, iwarn, info = mb4dlz(\n...     'N', n, 0.0, a.copy(), b.copy()\n...     )\n>>> a_out, b_out, ilo, ihi, lscale, rscale, dwork, iwarn, info = mb4dlz(\n...     'B', n, -3.0, a.copy(), b.copy()\n...     )\n>>> info\n0",
  "mb4dpz": "Balance a complex skew-Hamiltonian/Hamiltonian pencil.\n\nBalances the 2N-by-2N complex pencil aS - bH where:\n  S = [[A, D], [E, A']] (skew-Hamiltonian, D,E skew-Hermitian)\n  H = [[C, V], [W, -C']] (Hamiltonian, V,W Hermitian)\nand ' denotes conjugate transpose.\n\nFirst permutes to isolate eigenvalues, then applies diagonal scaling\nto make row/column pairs close in 1-norm.\n\nParameters:\n  job (str): 'N' - none, 'P' - permute only, 'S' - scale only, 'B' - both\n  n (int): Order of matrices A, C, D, E, V, W (n >= 0)\n  thresh (float): Threshold for scaling (-1,-2,-3,-4 or <=-10 for auto search)\n  a (ndarray): Complex N-by-N matrix A (F-order, modified in place)\n  de (ndarray): Complex N-by-(N+1) matrix with lower tri of E in cols 1:N,\n                upper tri of D in cols 2:N+1 (F-order, modified in place)\n  c (ndarray): Complex N-by-N matrix C (F-order, modified in place)\n  vw (ndarray): Complex N-by-(N+1) matrix with lower tri of W in cols 1:N,\n                upper tri of V in cols 2:N+1 (F-order, modified in place)\n\nReturns:\n  (ilo, lscale, rscale, dwork, iwarn, info):\n    ilo: ILO-1 = number of deflated eigenvalues (1-based)\n    lscale: Left permutation/scaling factors\n    rscale: Right permutation/scaling factors\n    dwork: Contains initial/final 1-norms (S,H) and threshold used\n    iwarn: Warning indicator (0=ok, 1=scaling reset to 1)\n    info: Exit code (0=success, <0: -info arg illegal)\n\nExamples:\n\n>>> from slicot import mb4dpz\n>>> import numpy as np\n>>> n = 2\n>>> job = 'B'\n>>> thresh = -3.0\n>>> a = np.array([\n...     [1.0+0.5j, 0.0+0.0j],\n...     [0.0+0.0j, 1.0+0.5j]\n...     ], dtype=complex, order='F')\n>>> de = np.array([\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j]\n...     ], dtype=complex, order='F')\n>>> c = np.array([\n...     [1.0+0.5j, 0.0+0.0j],\n...     [0.0+0.0j, -2.0-1.0j]\n...     ], dtype=complex, order='F')\n>>> vw = np.array([\n...     [1.0+0.0j, -1e-12+0.0j, 0.0+0.0j],\n...     [-1.0+0.5j, -1.0+0.0j, 0.0+0.0j]\n...     ], dtype=complex, order='F')\n>>> ilo, lscale, rscale, dwork, iwarn, info = mb4dpz(job, n, thresh, a, de, c, vw)\n>>> info\n0",
  "mc01md": "Compute shifted polynomial coefficients using Horner's algorithm.\n\nGiven P(x) = p[0] + p[1]*x + ... + p[dp]*x^dp and scalar alpha,\ncomputes the first k coefficients of the shifted polynomial:\nP(x) = q[0] + q[1]*(x-alpha) + ... + q[k-1]*(x-alpha)^(k-1) + ...\n\nParameters:\n  alpha (float): Shift value\n  k (int): Number of shifted coefficients to compute (1 <= k <= dp+1)\n  p (ndarray): Polynomial coefficients in increasing powers of x\n\nReturns:\n  (q, info): Shifted coefficients (leading k meaningful), exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc01md\n>>> dp = 5\n>>> alpha = 2.0\n>>> k = 6\n>>> p = np.array([6.0, 5.0, 4.0, 3.0, 2.0, 1.0], order='F', dtype=float)\n>>> q, info = mc01md(alpha, k, p)\n>>> expected_q = np.array([120.0, 201.0, 150.0, 59.0, 12.0, 1.0])\n>>> info\n0",
  "mc01nd": "Evaluate real polynomial at complex point using Horner's algorithm.\n\nComputes P(x0) where P(x) = p[0] + p[1]*x + ... + p[dp]*x^dp is a\nreal polynomial and x0 = xr + xi*j is a complex point.\n\nParameters:\n  xr (float): Real part of evaluation point\n  xi (float): Imaginary part of evaluation point\n  p (ndarray): Polynomial coefficients in increasing powers of x\n\nReturns:\n  (vr, vi, info): Real and imaginary parts of P(x0), exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc01nd\n>>> dp = 4\n>>> xr = -1.56\n>>> xi = 0.29\n>>> p = np.array([5.0, 3.0, -1.0, 2.0, 1.0], order='F', dtype=float)\n>>> vr, vi, info = mc01nd(xr, xi, p)\n>>> info\n0",
  "mc01od": "Compute complex polynomial coefficients from zeros.\n\nComputes the coefficients of a complex polynomial P(x) from its zeros:\n  P(x) = (x - r(1)) * (x - r(2)) * ... * (x - r(K))\nwhere r(i) = REZ(i) + j*IMZ(i).\n\nParameters:\n  rez (ndarray): Real parts of zeros\n  imz (ndarray): Imaginary parts of zeros\n\nReturns:\n  (rep, imp, info): Real and imaginary parts of coefficients\n    (increasing powers), exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc01od\n>>> rez = np.array([1.1, 0.6, -2.0, -0.8, -0.3], order='F', dtype=float)\n>>> imz = np.array([0.9, -0.7, 0.3, 2.5, -0.4], order='F', dtype=float)\n>>> rep, imp, info = mc01od(rez, imz)\n>>> expected_rep = np.array([2.7494, -1.7590, 0.0290, -1.6500, 1.4000, 1.0000])\n>>> expected_imp = np.array([-2.1300, -5.4205, 2.8290, -1.7300, -2.6000, 0.0000])\n>>> info\n0",
  "mc01pd": "Compute polynomial coefficients from zeros.\n\nParameters:\n  rez (ndarray): Real parts of zeros\n  imz (ndarray): Imaginary parts of zeros\n\nReturns:\n  (p, info): Polynomial coefficients (increasing powers), exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc01pd\n>>> k = 5\n>>> rez = np.array([0.0, 0.0, 2.0, 1.0, 1.0], order='F', dtype=float)\n>>> imz = np.array([1.0, -1.0, 0.0, 3.0, -3.0], order='F', dtype=float)\n>>> p, info = mc01pd(rez, imz)\n>>> expected_p = np.array([-20.0, 14.0, -24.0, 15.0, -4.0, 1.0])\n>>> info\n0",
  "mc01py": "Compute polynomial coefficients from zeros (decreasing order).\n\nComputes the coefficients of a real polynomial P(x) from its zeros:\n  P(x) = (x - r(1)) * (x - r(2)) * ... * (x - r(K))\nwhere r(i) = REZ(i) + j*IMZ(i). Complex zeros must appear as\nconsecutive conjugate pairs.\n\nUnlike mc01pd, coefficients are stored in DECREASING powers of x.\n\nParameters:\n  rez (ndarray): Real parts of zeros\n  imz (ndarray): Imaginary parts of zeros\n\nReturns:\n  (p, info): Polynomial coefficients (decreasing powers), exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc01py\n>>> rez = np.array([3.0], order='F', dtype=float)\n>>> imz = np.array([0.0], order='F', dtype=float)\n>>> p, info = mc01py(rez, imz)\n>>> expected_p = np.array([1.0, -3.0])\n>>> info\n0",
  "mc01qd": "Polynomial division: quotient and remainder.\n\nComputes Q(x) and R(x) such that A(x) = B(x) * Q(x) + R(x)\nwhere deg(R) < deg(B).\n\nParameters:\n  a (ndarray): Dividend polynomial coefficients (increasing powers)\n  b (ndarray): Divisor polynomial coefficients (increasing powers)\n\nReturns:\n  (rq, db, iwarn, info): Combined [R | Q] array, divisor degree,\n    warning count (leading zeros removed), exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc01qd\n>>> a = np.array([2.0, 2.0, -1.0, 2.0, 1.0], order='F', dtype=float)\n>>> b = np.array([1.0, -1.0, 1.0], order='F', dtype=float)\n>>> rq, db_out, iwarn, info = mc01qd(a, b)\n>>> expected_rq = np.array([1.0, 0.0, 1.0, 3.0, 1.0])\n>>> info\n0",
  "mc01rd": "Compute polynomial P(x) = P1(x)*P2(x) + alpha*P3(x).\n\nComputes the coefficients of the polynomial:\n  P(x) = P1(x) * P2(x) + alpha * P3(x)\nwhere P1(x), P2(x), P3(x) are real polynomials and alpha is a scalar.\n\nParameters:\n  p1 (ndarray): Coefficients of P1(x) in increasing powers of x\n  p2 (ndarray): Coefficients of P2(x) in increasing powers of x\n  p3 (ndarray): Coefficients of P3(x) in increasing powers of x (modified on exit)\n  alpha (float): Scalar multiplier for P3(x)\n  dp1 (int, optional): Degree of P1(x), -1 for zero polynomial\n  dp2 (int, optional): Degree of P2(x), -1 for zero polynomial\n  dp3 (int, optional): Degree of P3(x), -1 for zero polynomial\n\nReturns:\n  (p, dp, info): Result polynomial coefficients, degree, exit code\n\nExamples:\n\n>>> from slicot import mc01rd\n>>> import numpy as np\n>>> p1 = np.array([1.0, 2.5], dtype=float)\n>>> p2 = np.array([1.0, 0.1, -0.4], dtype=float)\n>>> p3 = np.array([1.15, 1.5, 0.0, 0.0], dtype=float)\n>>> alpha = -2.2\n>>> p_out, dp_out, info = mc01rd(p1, p2, p3, alpha)\n>>> expected = np.array([-1.53, -0.70, -0.15, -1.0])\n>>> info\n0",
  "mc01sd": "Scale polynomial coefficients for minimal variation.\n\nScales the coefficients of real polynomial P(x) such that the\ncoefficients of Q(x) = s*P(t*x) have minimal variation, where\ns = BASE^S and t = BASE^T (BASE is the machine floating-point base).\n\nParameters:\n  p (ndarray): Polynomial coefficients in increasing powers of x\n\nReturns:\n  (q, s, t, mant, e, info): Scaled coefficients Q(x), scaling exponents S and T,\n    mantissas and exponents of Q(x) coefficients, exit code (0=success, 1=zero polynomial)\n\nExamples:\n\n>>> from slicot import mc01sd\n>>> import numpy as np\n>>> p = np.array([10.0, -40.5, 159.5, 0.0, 2560.0, -10236.5], order='F', dtype=float)\n>>> q, s, t, mant, e, info = mc01sd(p)\n>>> info\n0",
  "mc01sw": "Extract mantissa and exponent of a real number.\n\nFinds M and E such that A = M * B^E where 1 <= |M| < B.\nIf A = 0, then M = E = 0.\n\nParameters:\n  a (float): The real number to decompose\n  b (int): The base (>= 2)\n\nReturns:\n  (m, e): Mantissa and exponent\n\nExamples:\n\n>>> from slicot import mc01sw\n>>> import numpy as np\n>>> m, e = mc01sw(1000.0, 10)",
  "mc01sx": "Compute variation of exponents in floating-point series.\n\nParameters:\n  e (ndarray): Array of integer exponents\n  mant (ndarray): Array of mantissas (f64)\n\nReturns:\n  int: Variation V = max(E(j)) - min(E(j)) for non-zero mantissas\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc01sx\n>>> e = np.array([5, 10, 3, 8], dtype=np.int32)\n>>> mant = np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float64)\n>>> v = mc01sx(e, mant)",
  "mc01sy": "Reconstruct a real number from mantissa and exponent.\n\nComputes A = M * B^E given mantissa M and exponent E.\n\nParameters:\n  m (float): The mantissa\n  e (int): The exponent\n  b (int): The base (>= 2)\n\nReturns:\n  (a, ovflow): The reconstructed value and overflow flag\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc01sy\n>>> test_values = [1024.0, 0.5, -256.0, 1.5, 0.125]\n>>> base = 2\n...     m, e = mc01sw(original, base)\n...     reconstructed, ovflow = mc01sy(m, e, base)",
  "mc01td": "Determine polynomial stability (Routh or Schur-Cohn).\n\nParameters:\n  dico (str): 'C'=continuous-time, 'D'=discrete-time\n  p (ndarray): Polynomial coefficients in increasing powers\n\nReturns:\n  (stable, nz, dp_out, iwarn, info): Stability flag, unstable zeros,\n    actual degree, warning, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc01td\n>>> p = np.array([2.0, 0.0, 1.0, -1.0, 1.0], order='F', dtype=float)\n>>> stable, nz, dp_out, iwarn, info = mc01td('C', p)\n>>> info\n0",
  "mc01vd": "Compute roots of a quadratic equation with real coefficients.\n\nComputes the roots of: a*x^2 + b*x + c = 0\n\nThe algorithm uses a numerically stable formula to avoid loss of significance.\n\nParameters:\n  a (float): Coefficient of x^2\n  b (float): Coefficient of x\n  c (float): Constant term\n\nReturns:\n  (z1re, z1im, z2re, z2im, info): Real and imaginary parts of roots.\n    z1 is the largest root in magnitude, z2 is the smallest.\n    info = 0: success\n    info = 1: a=b=0 or a=0 and -c/b overflows\n    info = 2: a=0 (linear equation), z1re=BIG\n    info = 3: c=0 and -b/a overflows, or largest root overflows\n    info = 4: roots cannot be computed without overflow\n\nExamples:\n\n>>> from slicot import mc01vd\n>>> import numpy as np\n>>> a = 0.5\n>>> b = -1.0\n>>> c = 2.0\n>>> z1re, z1im, z2re, z2im, info = mc01vd(a, b, c)\n>>> info\n0",
  "mc01wd": "Compute polynomial quotient and remainder for quadratic divisor.\n\nDivides P(x) by (x^2 - u1*x + u2) returning quotient coefficients.\n\nParameters:\n  p (ndarray): Polynomial coefficients in increasing powers\n  u1 (float): Linear coefficient of divisor\n  u2 (float): Constant coefficient of divisor\n\nReturns:\n  (q, info): Quotient polynomial coefficients, exit code\n\nExamples:\n\n>>> from slicot import mc01wd\n>>> import numpy as np\n>>> p = np.array([0.62, 1.10, 1.64, 1.88, 2.12, 1.70, 1.00], dtype=float)\n>>> u1 = 0.60\n>>> u2 = 0.80\n>>> q, info = mc01wd(p, u1, u2)\n>>> expected_q1 = 0.10\n>>> expected_q2 = 0.20\n>>> expected_quotient = np.array([0.6, 0.7, 0.8, 0.9, 1.0])\n>>> info\n0",
  "mc01xd": "Compute roots of cubic polynomial.\n\nComputes roots of P(t) = alpha + beta*t + gamma*t^2 + delta*t^3.\nRoots are returned as quotients (EVR + i*EVI) / EVQ.\n\nParameters:\n  alpha (float): Constant coefficient\n  beta (float): Linear coefficient\n  gamma (float): Quadratic coefficient\n  delta (float): Cubic coefficient\n\nReturns:\n  (evr, evi, evq, info): Real parts, imaginary parts, quotients, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc01xd\n>>> alpha, beta, gamma, delta = -6.0, 11.0, -6.0, 1.0\n>>> evr, evi, evq, info = mc01xd(alpha, beta, gamma, delta)\n>>> roots = []\n...     roots.append(complex(evr[k], evi[k]) / evq[k])\n>>> real_roots = sorted([r.real for r in roots])\n>>> info\n0",
  "mc03md": "Compute polynomial matrix P(x) = P1(x)*P2(x) + alpha*P3(x).\n\nComputes the coefficients of the polynomial matrix:\n  P(x) = P1(x) * P2(x) + alpha * P3(x)\nwhere P1(x), P2(x), P3(x) are real polynomial matrices and alpha is a scalar.\n\nParameters:\n  p1 (ndarray): 3D array (rp1, cp1, dp1+1) of P1 coefficients\n  p2 (ndarray): 3D array (cp1, cp2, dp2+1) of P2 coefficients\n  p3 (ndarray): 3D array (rp1, cp2, dp3+1) of P3 coefficients\n  alpha (float): Scalar multiplier for P3(x)\n  dp1 (int, optional): Degree of P1(x), -1 for zero polynomial\n  dp2 (int, optional): Degree of P2(x), -1 for zero polynomial\n  dp3 (int, optional): Degree of P3(x), -1 for zero polynomial\n\nReturns:\n  (p, dp, info): Result polynomial matrix coefficients (rp1, cp2, max_deg+1), degree, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc03md\n>>> rp1, cp1, cp2 = 3, 2, 2\n>>> dp1, dp2, dp3 = 2, 1, 1\n>>> p1 = np.zeros((rp1, cp1, dp1 + 1), order='F', dtype=float)\n>>> p1[:, :, 0] = np.array([[1.0, 2.0], [0.0, -1.0], [3.0, 2.0]], order='F')\n>>> p1[:, :, 1] = np.array([[-2.0, 3.0], [4.0, 7.0], [9.0, -2.0]], order='F')\n>>> p1[:, :, 2] = np.array([[6.0, 1.0], [2.0, 2.0], [-3.0, 4.0]], order='F')\n>>> p2 = np.zeros((cp1, cp2, dp2 + 1), order='F', dtype=float)\n>>> p2[:, :, 0] = np.array([[6.0, 1.0], [1.0, 7.0]], order='F')\n>>> p2[:, :, 1] = np.array([[-9.0, 7.0], [-6.0, 8.0]], order='F')\n>>> p3 = np.zeros((rp1, cp2, max(dp1 + dp2, dp3) + 1), order='F', dtype=float)\n>>> p3[:, :, 0] = np.array([[1.0, 0.0], [1.0, 1.0], [0.0, 1.0]], order='F')\n>>> p3[:, :, 1] = np.array([[-1.0, -1.0], [1.0, -1.0], [1.0, 1.0]], order='F')\n>>> alpha = 1.0\n>>> p_out, dp_out, info = mc03md(p1, p2, p3.copy(), alpha)\n>>> info\n0",
  "mc03nd": "Compute minimal polynomial basis for right nullspace of polynomial matrix.\n\nComputes the coefficients of a minimal polynomial basis K(s) for the right\nnullspace of an MP-by-NP polynomial matrix P(s) of degree DP, solving:\n  P(s) * K(s) = 0\n\nK(s) = K(0) + K(1)*s + ... + K(DK)*s^DK\n\nParameters:\n  mp (int): Number of rows of P(s). mp >= 0.\n  np (int): Number of columns of P(s). np >= 0.\n  dp (int): Degree of P(s). dp >= 1.\n  p (ndarray): 3D array (mp, np, dp+1) of polynomial coefficients.\n               p[:,:,k] = coefficient matrix P(k) for s^k.\n  tol (float): Tolerance for rank determination.\n\nReturns:\n  (dk, gam, nullsp, ker, info):\n    dk (int): Degree of K(s). -1 if no right nullspace.\n    gam (ndarray): Information about nullspace vector ordering.\n    nullsp (ndarray): Right nullspace vectors in condensed form.\n    ker (ndarray): 3D array (np, nk, dk+1) of kernel coefficients.\n    info (int): Exit code. 0 = success.\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc03nd\n>>> mp, np_dim, dp = 5, 4, 2\n>>> p0 = np.array([\n...     [2.0, 2.0, 0.0, 3.0],\n...     [0.0, 4.0, 0.0, 6.0],\n...     [8.0, 8.0, 0.0, 12.0],\n...     [0.0, 0.0, 0.0, 0.0],\n...     [2.0, 2.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> p1 = np.array([\n...     [1.0, 0.0, 1.0, 0.0],\n...     [0.0, 0.0, 2.0, 0.0],\n...     [4.0, 0.0, 4.0, 0.0],\n...     [2.0, 2.0, 0.0, 3.0],\n...     [3.0, 2.0, 1.0, 3.0]\n...     ], order='F', dtype=float)\n>>> p2 = np.array([\n...     [0.0, 0.0, 0.0, 0.0],\n...     [1.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0],\n...     [1.0, 0.0, 1.0, 0.0],\n...     [1.0, 0.0, 1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> p = np.zeros((mp, np_dim, dp + 1), order='F', dtype=float)\n>>> p[:, :, 0] = p0\n>>> p[:, :, 1] = p1\n>>> p[:, :, 2] = p2\n>>> tol = 0.0\n>>> dk, gam, nullsp, ker, info = mc03nd(mp, np_dim, dp, p, tol)\n>>> nk = sum(gam[:dk + 1])\n>>> m1 = sum((i + 1) * gam[i] for i in range(dk + 1))\n...     ps = p0 + p1*s + p2*s**2\n...     ks = np.zeros((np_dim, nk), order='F', dtype=float)\n...     ks += ker[:np_dim, :nk, k] * (s**k)\n...     product = ps @ ks\n>>> info\n0",
  "mc03nx": "Construct companion pencil from polynomial matrix.\n\nConstructs the pencil s*E - A related to a polynomial matrix P(s) of degree dp:\n  P(s) = P(0) + P(1)*s + ... + P(dp)*s^dp\n\nThe pencil matrices have dimensions (dp*mp) x ((dp-1)*mp + np).\n\nParameters:\n  p (ndarray): 3D array (mp, np, dp+1) of polynomial coefficients.\n              p[:,:,k] = coefficient matrix P(k) for s^k.\n\nReturns:\n  (a, e): Companion pencil matrices A and E\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import mc03nx\n>>> mp, np_, dp = 2, 2, 2\n>>> P0 = np.array([[1.0, 2.0], [3.0, 4.0]], order='F', dtype=float)\n>>> P1 = np.array([[5.0, 6.0], [7.0, 8.0]], order='F', dtype=float)\n>>> P2 = np.array([[9.0, 10.0], [11.0, 12.0]], order='F', dtype=float)\n>>> p = np.zeros((mp, np_, dp + 1), order='F', dtype=float)\n>>> p[:, :, 0] = P0\n>>> p[:, :, 1] = P1\n>>> p[:, :, 2] = P2\n>>> a, e = mc03nx(p)\n>>> nrows = dp * mp\n>>> ncols = (dp - 1) * mp + np_",
  "mc03ny": "Minimal polynomial basis for right nullspace of staircase pencil.\n\nDetermines a minimal basis of the right nullspace of the subpencil\ns*E(eps)-A(eps) using the method given in Beelen's thesis. This pencil\nmust be in staircase form as supplied by MB04VD.\n\nNOTE: This routine is intended to be called only from MC03ND.\n\nParameters:\n  nblcks (int): Number of full row rank blocks (>= 0)\n  nra (int): Number of rows = sum(nu(i)) (>= 0)\n  nca (int): Number of columns = sum(mu(i)) (>= 0)\n  a (ndarray): Matrix A (nra x nca, F-order), modified on exit\n  e (ndarray): Matrix E (nra x nca, F-order), modified on exit\n  imuk (ndarray): Column dimensions mu(k), int32 array\n  inuk (ndarray): Row dimensions nu(k), int32 array\n\nReturns:\n  (veps, imuk, info): Minimal polynomial basis (nca x ncv),\n    restored mu(k) array, exit code (>0 means block not full row rank)\n\nExamples:\n\n>>> from slicot import mc03ny\n>>> import numpy as np\n>>> nblcks = 1\n>>> mu = np.array([3], dtype=np.int32)\n>>> nu = np.array([2], dtype=np.int32)\n>>> nra = np.sum(nu)\n>>> nca = np.sum(mu)\n>>> a = np.random.randn(nra, nca).astype(float, order='F')\n>>> e = np.random.randn(nra, nca).astype(float, order='F')\n>>> a[0, 1] = 2.0\n>>> a[1, 1] = 0.0\n>>> a[1, 2] = 3.0\n>>> ncv = 1 * (mu[0] - nu[0])\n>>> veps, imuk_out, info = mc03ny(nblcks, nra, nca, a, e, mu.copy(), nu)\n>>> info\n0",
  "md03ba": "QR factorization with column pivoting for Levenberg-Marquardt.\n\nParameters:\n  n (int): Number of columns of J\n  ipar (ndarray): Integer parameters (M=ipar[0])\n  fnorm (float): Norm of error vector\n  j (ndarray): Jacobian matrix (M x N, F-order)\n  e (ndarray): Error vector (M)\n\nReturns:\n  (r, e, jnorms, gnorm, ipvt, info): R factor, Q'*e, norms, gradient norm, permutation, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> try:\n>>> from slicot import md03ba\n>>> except ImportError:\n...     self.fail(\"Could not import md03ba\")\n>>> m, n = 5, 3\n>>> ipar = np.array([m], dtype=np.int32)\n>>> j_in = np.random.rand(m, n)\n>>> j = np.asfortranarray(j_in)\n>>> e_in = np.random.rand(m)\n>>> e = e_in.copy()\n>>> fnorm = np.linalg.norm(e)\n>>> j_out, e_out, jnorms, gnorm, ipvt, info = md03ba(n, ipar, fnorm, j, e)\n>>> norm_e_out = np.linalg.norm(e_out)\n>>> info\n0",
  "md03bb": "Compute Levenberg-Marquardt parameter for compressed Jacobian (Wrapper for MD03BY).\n\nParameters:\n  cond (str): 'E' = estimate condition, 'N' = check zeros, 'U' = use rank\n  n (int): Order of matrix R\n  r (ndarray): Upper triangular matrix R (n x n, F-order)\n  ipvt (ndarray): Permutation vector (1-based indices)\n  diag (ndarray): Diagonal scaling D (all nonzero)\n  qtb (ndarray): First n elements of Q'*b\n  delta (float): Trust region radius (> 0)\n  par (float): Initial LM parameter estimate (>= 0)\n  rank (int): Input rank (COND='U') or 0 otherwise\n  tol (float): Tolerance for rank determination (COND='E')\n\nReturns:\n  (r, par, rank, x, rx, info): Modified R, LM parameter, rank, solution, residual, exit code\n\nExamples:\n\n>>> from slicot import md03bb\n>>> import numpy as np\n>>> n = 3\n>>> ipar = np.array([0], dtype=np.int32)\n>>> r = np.triu(np.random.rand(n, n))\n>>> for i in range(n): r[i, i] += 2.0\n>>> r_in = np.asfortranarray(r)\n>>> ipvt = np.arange(1, n+1, dtype=np.int32)\n>>> diag = np.ones(n)\n>>> qtb = np.random.rand(n)\n>>> delta = 1.0\n>>> par = 0.0\n>>> ranks = np.array([n], dtype=np.int32)\n>>> tol = 0.0\n>>> r_out, par_out, ranks_out, x, rx, info = md03bb('N', n, ipar, r_in, ipvt, diag, qtb, delta, par, ranks, tol)\n>>> info\n0",
  "md03bd": "Levenberg-Marquardt nonlinear least squares optimizer.\n\nParameters:\n  m (int): Number of functions\n  n (int): Number of variables\n  x (ndarray): Initial guess (n,) or random if not provided\n  fcn (callable): Function f(x) returning residual vector (m,)\n  jac (callable): Function f(x) returning Jacobian matrix (m, n)\n  itmax (int): Maximum iterations (default 100)\n  ftol (float): Function tolerance (default sqrt(eps))\n  xtol (float): Solution tolerance (default sqrt(eps))\n  gtol (float): Gradient tolerance (default eps)\n\nReturns:\n  (x, nfev, njev, fnorm, iwarn, info): Solution, evaluations, norm, status\n\nExamples:\n\n>>> from slicot import md03bd\n>>> import numpy as np\n>>> m = 15\n>>> n = 3\n>>> y = np.array([\n...     0.14, 0.18, 0.22, 0.25, 0.29,\n...     0.32, 0.35, 0.39, 0.37, 0.58,\n...     0.73, 0.96, 1.34, 2.10, 4.39\n...     ], dtype=np.float64, order='F')\n>>> x0 = np.array([1.0, 1.0, 1.0], dtype=np.float64, order='F')\n>>> def fcn(x):\n...     e = np.zeros(m, dtype=np.float64, order='F')\n...     for i in range(1, m + 1):  # 1-based for compatibility\n...     tmp1 = float(i)\n...     tmp2 = float(16 - i)\n...     tmp3 = tmp2 if i > 8 else tmp1\n...     e[i-1] = y[i-1] - (x[0] + tmp1 / (x[1]*tmp2 + x[2]*tmp3))\n...     return e\n>>> def jac(x):\n...     j = np.zeros((m, n), dtype=np.float64, order='F')\n...     for i in range(1, m + 1):  # 1-based\n...     tmp1 = float(i)\n...     tmp2 = float(16 - i)\n...     tmp3 = tmp2 if i > 8 else tmp1\n...     tmp4 = (x[1]*tmp2 + x[2]*tmp3)**2\n...     j[i-1, 0] = -1.0\n...     j[i-1, 1] = tmp1*tmp2/tmp4\n...     j[i-1, 2] = tmp1*tmp3/tmp4\n...     return j\n>>> ftol = -1.0  # Use sqrt(eps)\n>>> xtol = -1.0  # Use sqrt(eps)\n>>> gtol = -1.0  # Use eps\n>>> x, nfev, njev, fnorm, iwarn, info = slicot.md03bd(\n...     m, n, x0, fcn, jac,\n...     itmax=100,\n...     ftol=ftol,\n...     xtol=xtol,\n...     gtol=gtol\n...     )\n>>> info\n0",
  "md03bf": "Kowalik-Osborne test function for nonlinear least squares.\n\nExample FCN callback implementing the Kowalik-Osborne test problem\nfrom MINPACK with m=15 observations and n=3 parameters.\n\nParameters:\n  iflag (int): Operation mode (1=error, 2=Jacobian, 3=workspace)\n  x (ndarray): Parameter vector (3,)\n\nReturns:\n  iflag=1: (e, info) - Error vector (15,), exit code\n  iflag=2: (j, e, nfevl, info) - Jacobian (15x3), error, evals, code\n  iflag=3: (ipar, info) - Workspace requirements tuple, exit code\n\nExamples:\n\n>>> from slicot import md03bf\n>>> import numpy as np\n>>> x = np.array([1.0, 1.0, 1.0], dtype=np.float64)\n>>> e, info = md03bf(1, x)\n>>> info\n0",
  "md03by": "Compute Levenberg-Marquardt parameter for trust region subproblem.\n\nParameters:\n  cond (str): 'E' = estimate condition, 'N' = check zeros, 'U' = use rank\n  n (int): Order of matrix R\n  r (ndarray): Upper triangular matrix R (n x n, F-order)\n  ipvt (ndarray): Permutation vector (1-based indices)\n  diag (ndarray): Diagonal scaling D (all nonzero)\n  qtb (ndarray): First n elements of Q'*b\n  delta (float): Trust region radius (> 0)\n  par (float): Initial LM parameter estimate (>= 0)\n  rank (int): Input rank (COND='U') or 0 otherwise\n  tol (float): Tolerance for rank determination (COND='E')\n\nReturns:\n  (r, par, rank, x, rx, info): Modified R, LM parameter, rank, solution, residual, exit code\n\nExamples:\n\n>>> from slicot import md03by\n>>> import numpy as np\n>>> n = 3\n>>> r = np.array([\n...     [10.0,  2.0,  1.0],\n...     [ 0.0,  8.0,  0.5],\n...     [ 0.0,  0.0,  5.0]\n...     ], dtype=float, order='F')\n>>> ipvt = np.array([1, 2, 3], dtype=np.int32)\n>>> diag = np.array([1.0, 1.0, 1.0], dtype=float)\n>>> qtb = np.array([5.0, 4.0, 2.5], dtype=float)\n>>> delta = 10.0  # Large trust radius - accept Gauss-Newton step\n>>> par = 0.0\n>>> tol = 0.0\n>>> r_out, par_out, rank, x, rx, info = md03by(\n...     cond='N', n=n, r=r, ipvt=ipvt, diag=diag,\n...     qtb=qtb, delta=delta, par=par, rank=0, tol=tol\n...     )\n>>> dxnorm = np.linalg.norm(diag * x)\n>>> info\n0",
  "nf01ay": "Calculate the output of a set of neural networks.\n\nParameters:\n  nsmp (int): Number of training samples\n  nz (int): Length of each input sample\n  l (int): Length of each output sample\n  ipar (ndarray): Integer parameters (nn, ...)\n  wb (ndarray): Weights and biases\n  z (ndarray): Input samples (nsmp x nz, F-order)\n\nReturns:\n  (y, info): Output samples, exit code\n\nExamples:\n\n>>> from slicot import nf01ay\n>>> import numpy as np\n>>> nsmp = 5\n>>> nz = 3\n>>> l = 2\n>>> nn = 4\n>>> ipar = np.array([nn], dtype=np.int32)\n>>> ldwb = nn * (nz + 2) + 1\n>>> lwb = ldwb * l\n>>> wb = np.random.rand(lwb)\n>>> wb = (wb - 0.5) * 2.0 \n>>> z = np.random.rand(nsmp, nz) # Row-major in python, but we pass it F-order\n>>> z_arr = np.asfortranarray(z)\n...     offset = k * ldwb\n...     wb_k = wb[offset : offset + ldwb]\n...     w_end = nn * nz\n...     w_flat = wb_k[:w_end]\n...     ws_start = w_end\n...     ws_end = ws_start + nn\n...     ws = wb_k[ws_start:ws_end]\n...     b_start = ws_end\n...     b = wb_k[b_start:] # length nn+1\n...     W = w_flat.reshape((nz, nn), order='F')\n...     linear_part = z @ W + b[:nn]\n...     hidden = np.tanh(linear_part)\n>>> y_act, info = nf01ay(nsmp, nz, l, ipar, wb, z_arr)\n>>> info\n0",
  "nf01br": "Solve system of linear equations R*x = b or R'*x = b in least squares sense.\n\nParameters:\n  cond (str): 'E' = estimate condition, 'N' = check zeros, 'U' = use rank\n  uplo (str): 'U' or 'L' - storage scheme\n  trans (str): 'N'/'T'/'C' - transpose option\n  n (int): Order of matrix R\n  ipar (ndarray): Integer parameters (st, bn, bsm, bsn)\n  r (ndarray): Matrix R (ldr x nc, F-order)\n  sdiag (ndarray): Diagonal elements (if uplo='L')\n  s (ndarray): Transpose of last block column (if uplo='L')\n  b (ndarray): RHS vector b\n  ranks (ndarray): Ranks\n  tol (float): Tolerance for rank determination\n\nReturns:\n  (b, ranks, info): Solution x, ranks, exit code\n\nExamples:\n\n>>> from slicot import nf01br\n>>> import numpy as np\n>>> n = 4\n>>> st = 0\n>>> bn = 1\n>>> bsm = 4\n>>> bsn = 4\n>>> ipar = np.array([st, bn, bsm, bsn], dtype=np.int32)\n>>> ldr = n\n>>> r = np.triu(np.random.rand(n, n))\n...     r[i, i] += 2.0\n>>> r_arr = np.asfortranarray(r)\n>>> b = np.random.rand(n)\n>>> b_in = b.copy()\n>>> sdiag = np.zeros(n)\n>>> s = np.zeros((1, 1))\n>>> ranks = np.zeros(bn+1, dtype=np.int32)\n>>> b_out, ranks_out, info = nf01br('N', 'U', 'N', n, ipar, r_arr, sdiag, s, b_in, ranks, 0.0)\n>>> x = b_out\n>>> b_rec = r @ x\n>>> info\n0",
  "nf01bs": "QR factorization of Jacobian in compressed form.\n\nParameters:\n  n (int): Number of columns of J\n  ipar (ndarray): Integer parameters (st, bn, bsm, bsn)\n  fnorm (float): Norm of error vector\n  j (ndarray): Jacobian matrix (ldj x nc, F-order)\n  e (ndarray): Error vector\n\nReturns:\n  (r, e, jnorms, gnorm, ipvt, info): R factor, Q'*e, norms, gradient norm, permutation, exit code\n\nExamples:\n\n>>> from slicot import nf01bs\n>>> import numpy as np\n>>> m, n = 5, 3\n>>> st = 0\n>>> bn = 1\n>>> bsm = 5\n>>> bsn = 3\n>>> ipar = np.array([st, bn, bsm, bsn], dtype=np.int32)\n>>> fnorm = 1.0\n>>> j_in = np.random.rand(m, n)\n>>> j = np.asfortranarray(j_in)\n>>> e_in = np.random.rand(m)\n>>> e = e_in.copy()\n>>> j_out, e_out, jnorms, gnorm, ipvt, info = nf01bs(n, ipar, fnorm, j, e)\n>>> r = np.triu(j_out[:n, :])\n>>> diag_r = np.abs(np.diag(j_out))\n>>> info\n0",
  "nf01by": "Compute the Jacobian of the error function for a neural network.\n\nParameters:\n  cjte (str): 'C' to compute J'*e, 'N' to skip\n  nsmp (int): Number of training samples\n  nz (int): Length of each input sample\n  l (int): Length of each output sample (must be 1)\n  ipar (ndarray): Integer parameters (nn, ...)\n  wb (ndarray): Weights and biases\n  z (ndarray): Input samples (nsmp x nz, F-order)\n  e (ndarray): Error vector (nsmp)\n\nReturns:\n  (j, jte, info): Jacobian, J'*e, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> try:\n>>> from slicot import nf01by\n>>> except ImportError:\n...     self.fail(\"Could not import nf01by\")\n>>> nsmp = 5\n>>> nz = 3\n>>> l = 1\n>>> nn = 4\n>>> ipar = np.array([nn], dtype=np.int32)\n>>> nwb = nn * (nz + 2) + 1\n>>> wb = np.random.rand(nwb)\n>>> wb = (wb - 0.5) * 2.0\n>>> z = np.random.rand(nsmp, nz)\n>>> z_arr = np.asfortranarray(z)\n>>> e = np.random.rand(nsmp)\n>>> j, jte, info = nf01by('C', nsmp, nz, l, ipar, wb, z_arr, e)\n>>> w_end = nn * nz\n>>> w_flat = wb[:w_end]\n>>> ws_start = w_end\n>>> ws_end = ws_start + nn\n>>> ws = wb[ws_start:ws_end]\n>>> b_start = ws_end\n>>> b = wb[b_start:] # nn+1\n>>> W = w_flat.reshape((nz, nn), order='F') # Input weights\n>>> linear = z @ W + b[:nn]\n>>> act = np.tanh(linear)\n>>> j_b_out = j[:, nwb-1]\n>>> j_ws = j[:, ws_start:ws_end]\n>>> d_act = 1.0 - act**2\n>>> expected_j_b = d_act * ws[None, :]\n>>> j_b = j[:, b_start:b_start+nn]\n...     j_w_i = j[:, i*nz : (i+1)*nz]\n...     expected_j_w_i = expected_j_b[:, i:i+1] * z\n>>> info\n0",
  "sb01bd": "Multi-input pole assignment using state feedback.\n\nComputes state feedback F such that A + B*F has specified eigenvalues.\n\nParameters:\n  dico (str): 'C' for continuous, 'D' for discrete\n  n (int): State dimension\n  m (int): Input dimension\n  np (int): Number of eigenvalues to assign\n  alpha (float): Threshold for fixed eigenvalues\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  wr (ndarray): Real parts of desired eigenvalues\n  wi (ndarray): Imaginary parts of desired eigenvalues\n  tol (float): Tolerance for controllability tests\n\nReturns:\n  (a, wr, wi, nfp, nap, nup, f, z, iwarn, info):\n    Schur form, eigenvalues, counts, feedback, transformation\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb01bd\n>>> n, m, np_poles = 4, 2, 2\n>>> alpha = -0.4\n>>> tol = 1e-8\n>>> a = np.array([\n...     [-6.8,  0.0, -207.0,  0.0],\n...     [ 1.0,  0.0,    0.0,  0.0],\n...     [43.2,  0.0,    0.0, -4.2],\n...     [ 0.0,  0.0,    1.0,  0.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [5.64, 0.0 ],\n...     [0.0,  0.0 ],\n...     [0.0,  1.18],\n...     [0.0,  0.0 ]\n...     ], order='F', dtype=float)\n>>> wr = np.array([-0.5, -0.5, -2.0, -0.4], dtype=float)\n>>> wi = np.array([ 0.15, -0.15, 0.0, 0.0], dtype=float)\n>>> result = sb01bd('C', n, m, np_poles, alpha, a.copy(order='F'),\n...     b.copy(order='F'), wr[:np_poles].copy(),\n...     wi[:np_poles].copy(), tol)\n>>> a_out, wr_out, wi_out, nfp, nap, nup, f, z, iwarn, info = result\n>>> eigs = np.linalg.eigvals(closed_loop)\n...     found = min(abs(e - expected) for e in eigs)\n>>> large_stable_found = sum(1 for e in eigs if abs(e.imag) > 50 and e.real < 0)",
  "sb01bx": "Select eigenvalue(s) closest to a given value.\n\nChooses real eigenvalue or complex conjugate pair at minimal distance.\n\nParameters:\n  reig (bool): True for real, False for complex pair\n  n (int): Number of eigenvalues\n  xr (float): Real part of target\n  xi (float): Imaginary part of target (for complex)\n  wr (ndarray): Real parts of eigenvalues\n  wi (ndarray): Imaginary parts of eigenvalues\n\nReturns:\n  (wr, wi, s, p): Reordered arrays, sum, product\n\nExamples:\n\n>>> from slicot import sb01bx\n>>> import numpy as np\n>>> reig = True\n>>> n = 5\n>>> xr = 2.5  # Target value\n>>> xi = 0.0  # Not used for real\n>>> wr = np.array([1.0, 4.0, 2.0, 6.0, 3.0], order='F', dtype=float)\n>>> wi = np.zeros(n, order='F', dtype=float)  # Not used\n>>> wr_out, wi_out, s, p = sb01bx(reig, n, xr, xi, wr, wi)",
  "sb01by": "Pole placement for N=1 or N=2 systems.\n\nConstructs feedback F such that A + B*F has prescribed eigenvalues.\n\nParameters:\n  n (int): Order of A (1 or 2)\n  m (int): Number of inputs\n  s (float): Sum of eigenvalues\n  p (float): Product of eigenvalues (for N=2)\n  a (ndarray): State matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  tol (float): Tolerance for controllability\n\nReturns:\n  (f, info): Feedback matrix (m x n), exit code\n\nExamples:\n\n>>> from slicot import sb01by\n>>> import numpy as np\n>>> n, m = 1, 1\n>>> s = -1.0  # Target eigenvalue\n>>> p = 0.0   # Not used for N=1\n>>> tol = 1e-10\n>>> a = np.array([[2.0]], order='F', dtype=float)\n>>> b = np.array([[1.0]], order='F', dtype=float)\n>>> f, info = sb01by(n, m, s, p, a, b, tol)\n>>> info\n0",
  "sb01dd": "Eigenstructure assignment for multi-input system in orthogonal canonical form.\n\nComputes feedback matrix G such that A - B*G has the desired eigenstructure.\nThe pair (A, B) must be in orthogonal canonical form from ab01nd.\n\nParameters:\n  a (ndarray): N-by-N matrix A in canonical form (F-order)\n  b (ndarray): N-by-M matrix B in canonical form (F-order)\n  indcon (int): Controllability index (0 <= indcon <= n)\n  nblk (ndarray): Block sizes (indcon elements, int32)\n  wr (ndarray): Real parts of desired poles\n  wi (ndarray): Imaginary parts of desired poles\n  z (ndarray): Orthogonal matrix from ab01nd (n x n, F-order)\n  y (ndarray): Free parameters for eigenvector design (m*n elements)\n  tol (float, optional): Tolerance for rank determination\n\nReturns:\n  (a_schur, b_out, z_out, g, count, info):\n    a_schur: Real Schur form of A-B*G\n    b_out: Transformed B\n    z_out: Orthogonal transformation\n    g: M-by-N feedback matrix\n    count: Number of Y elements used\n    info: 0=success, <0=invalid arg, 1=not controllable\n\nExamples:\n\n>>> from slicot import sb01dd\n>>> import numpy as np\n>>> n = 4\n>>> m = 2\n>>> tol = 0.0\n>>> a = np.array([\n...     [-1.0,  0.0,  2.0, -3.0],\n...     [ 1.0, -4.0,  3.0, -1.0],\n...     [ 0.0,  2.0,  4.0, -5.0],\n...     [ 0.0,  0.0, -1.0, -2.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> wr = np.array([-1.0, -1.0, -1.0, -1.0], dtype=float)\n>>> wi = np.array([0.0, 0.0, 0.0, 0.0], dtype=float)\n>>> y = np.array([1.0, 2.0, 2.0, 1.0, -1.0, -2.0, 3.0, 1.0], dtype=float)\n>>> a_can, b_can, ncont, indcon, nblk, z, tau, info1 = ab01nd(\n...     'I', a, b, tol\n...     )\n>>> a_schur, b_out, z_out, g, count, info2 = sb01dd(\n...     a_can, b_can, indcon, nblk[:indcon].copy(), wr, wi, z, y, tol=tol\n...     )",
  "sb01fy": "Inner denominator of right-coprime factorization (order 1 or 2).\n\nComputes F and V such that (A+B*F, B*V, F, V) is inner.\n\nParameters:\n  discr (bool): True for discrete-time\n  a (ndarray): State matrix (n x n, n=1 or 2)\n  b (ndarray): Input matrix (n x m)\n\nReturns:\n  (f, v, info): Feedback matrix (m x n), V matrix (m x m), exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb01fy\n>>> n = 1\n>>> m = 2\n>>> a = np.array([[2.0]], order='F', dtype=float)\n>>> b = np.array([[1.0, 0.5]], order='F', dtype=float)\n>>> f, v, info = sb01fy(False, a, b)\n>>> a_closed = a + b @ f\n>>> eig_closed = np.linalg.eigvals(a_closed)\n>>> info\n0",
  "sb01md": "Single-input pole assignment via state feedback.\n\nDetermines the one-dimensional state feedback matrix G such that\nthe closed-loop system dX/dt = (A - B*G)*X has desired poles.\nThe system must be reduced to orthogonal canonical form via AB01MD first.\n\nParameters:\n  ncont (int): Controllable order from AB01MD (ncont >= 0)\n  n (int): Order of matrix Z (n >= ncont)\n  a (ndarray): NCONT-by-NCONT canonical form of A (F-order)\n  b (ndarray): NCONT-element canonical form of B\n  wr (ndarray): Real parts of desired poles (NCONT elements)\n  wi (ndarray): Imaginary parts (complex conjugates consecutive)\n  z (ndarray): N-by-N orthogonal transformation from AB01MD (F-order)\n\nReturns:\n  (a_out, b_out, z_out, g, info):\n    a_out: Schur form S of closed-loop (A-B*G)\n    b_out: Transformed B (Z*B)\n    z_out: Orthogonal Z reducing (A-B*G) to Schur form\n    g: State feedback matrix (NCONT elements)\n    info: 0=success, <0=parameter -info invalid\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb01md\n>>> n = 4\n>>> tol = 0.0\n>>> a = np.array([\n...     [-1.0,  0.0,  2.0, -3.0],\n...     [ 1.0, -4.0,  3.0, -1.0],\n...     [ 0.0,  2.0,  4.0, -5.0],\n...     [ 0.0,  0.0, -1.0, -2.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([1.0, 0.0, 0.0, 0.0], order='F', dtype=float)\n>>> wr = np.array([-1.0, -1.0, -1.0, -1.0], dtype=float)\n>>> wi = np.array([0.0, 0.0, 0.0, 0.0], dtype=float)\n>>> result_ab = ab01md('I', a.copy(order='F'), b.copy(order='F'), tol)\n>>> a_can, b_can, ncont, z, tau, info_ab = result_ab\n>>> result_sb = sb01md(ncont, n, a_can.copy(order='F'), b_can.copy(order='F'),\n...     wr.copy(), wi.copy(), z.copy(order='F'))\n>>> a_out, b_out, z_out, g, info_sb = result_sb",
  "sb02cx": "Select purely imaginary eigenvalues for H-infinity norm.\n\nCallback function for DGEES eigenvalue selection. Returns True for\neigenvalues with |real part| < 100*eps, where eps is machine epsilon.\n\nUsed internally by AB13CD for H-infinity norm computation.\n\nParameters:\n  reig (float): Real part of eigenvalue\n  ieig (float): Imaginary part of eigenvalue (unused)\n\nReturns:\n  bool: True if purely imaginary, False otherwise\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02cx\n>>> result = sb02cx(0.0, 1.0)\n>>> assert_equal(result, True)\n>>> result = sb02cx(0.0, -5.5)\n>>> assert_equal(result, True)\n>>> result = sb02cx(0.0, 0.0)\n>>> assert_equal(result, True)",
  "sb02md": "Solve continuous/discrete-time algebraic Riccati equation.\n\nContinuous-time (DICO='C'):\n  Q + A'*X + X*A - X*G*X = 0\n\nDiscrete-time (DICO='D'):\n  X = A'*X*A - A'*X*B*(R + B'*X*B)^(-1)*B'*X*A + Q\n\nwhere G = B*R^(-1)*B' must be provided.\n\nUses Laub's Schur vector approach.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  hinv (str): 'D' symplectic, 'I' inverse symplectic (discrete-time)\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  scal (str): 'G' general scaling, 'N' no scaling\n  sort (str): 'S' stable eigenvalues first, 'U' unstable first\n  n (int): Order of A, G, Q (n >= 0)\n  a (ndarray): Matrix A (n x n, F-order)\n  g (ndarray): Symmetric matrix G = B*R^(-1)*B' (n x n, F-order)\n  q (ndarray): Symmetric matrix Q (n x n, F-order)\n\nReturns:\n  - X: Solution matrix (n x n)\n  - rcond: Reciprocal condition number of U(1,1) block\n  - wr: Real parts of eigenvalues (2n)\n  - wi: Imaginary parts of eigenvalues (2n)\n  - S: Schur form (2n x 2n)\n  - U: Orthogonal transformation (2n x 2n)\n  - info: Exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02md\n>>> n = 2\n>>> A = np.array([\n...     [0.0, 1.0],\n...     [0.0, 0.0]\n...     ], dtype=float, order='F')\n>>> Q = np.array([\n...     [1.0, 0.0],\n...     [0.0, 2.0]\n...     ], dtype=float, order='F')\n>>> G = np.array([\n...     [0.0, 0.0],\n...     [0.0, 1.0]\n...     ], dtype=float, order='F')\n>>> X, rcond, wr, wi, S, U, info = sb02md('C', 'D', 'U', 'N', 'S', n, A, G, Q)\n>>> info\n0",
  "sb02mr": "Select unstable eigenvalues for continuous-time Riccati.\n\nCallback function for DGEES eigenvalue selection. Returns True for\neigenvalues with real part >= 0 (unstable in continuous-time).\n\nUsed internally for continuous-time algebraic Riccati equation solvers.\n\nParameters:\n  reig (float): Real part of eigenvalue\n  ieig (float): Imaginary part of eigenvalue (unused)\n\nReturns:\n  bool: True if unstable (reig >= 0), False otherwise\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02mr\n>>> result = sb02mr(1.0, 0.0)\n>>> assert_equal(result, True)\n>>> result = sb02mr(0.5, 2.0)\n>>> assert_equal(result, True)\n>>> result = sb02mr(100.0, -50.0)\n>>> assert_equal(result, True)",
  "sb02ms": "Select unstable eigenvalues for discrete-time Riccati.\n\nCallback function for DGEES eigenvalue selection. Returns True for\neigenvalues with modulus >= 1 (unstable in discrete-time).\n\nUsed internally for discrete-time algebraic Riccati equation solvers.\n\nParameters:\n  reig (float): Real part of eigenvalue\n  ieig (float): Imaginary part of eigenvalue\n\nReturns:\n  bool: True if unstable (|lambda| >= 1), False otherwise\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02ms\n>>> result = sb02ms(2.0, 0.0)\n>>> assert_equal(result, True)\n>>> result = sb02ms(0.0, 1.5)\n>>> assert_equal(result, True)\n>>> result = sb02ms(0.8, 0.8)\n>>> assert_equal(result, True)\n>>> result = sb02ms(-1.5, 0.5)\n>>> assert_equal(result, True)",
  "sb02mt": "Riccati preprocessing - convert coupling weight problems to standard form.\n\nComputes:\n  G = B*R^(-1)*B'\n  A_bar = A - B*R^(-1)*L'\n  Q_bar = Q - L*R^(-1)*L'\n\nParameters:\n  jobg (str): 'G' to compute G, 'N' to skip\n  jobl (str): 'Z' if L is zero, 'N' if L is nonzero\n  fact (str): 'N' R unfactored, 'C' Cholesky, 'U' UdU'/LdL'\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  n (int): Order of A, Q, G (n >= 0)\n  m (int): Order of R (m >= 0)\n  a (ndarray or None): Matrix A (n x n, F-order) if jobl='N'\n  b (ndarray): Matrix B (n x m, F-order)\n  q (ndarray or None): Matrix Q (n x n, F-order) if jobl='N'\n  r (ndarray): Matrix R (m x m, F-order)\n  l (ndarray or None): Matrix L (n x m, F-order) if jobl='N'\n  g (ndarray or None): Output G (n x n, F-order) if jobg='G'\n\nReturns:\n  Variable outputs based on jobg and jobl:\n  - If jobg='G', jobl='Z': (g, oufact, info)\n  - If jobg='N', jobl='N': (a, b, q, l, oufact, info)\n  - If jobg='G', jobl='N': (a, b, q, l, g, oufact, info)\n\nExamples:\n\n>>> import numpy as np\n>>> n, m = 4, 2\n>>> B = np.random.randn(n, m).astype(float, order='F')\n>>> R_half = np.random.randn(m, m)\n>>> R = (R_half.T @ R_half + np.eye(m) * 3.0).astype(float, order='F')\n>>> R_inv = np.linalg.inv(R)\n>>> from slicot import sb02mt\n>>> G = np.zeros((n, n), dtype=float, order='F')\n>>> G_out, oufact, info = sb02mt(\n...     'G', 'Z', 'N', 'U',\n...     )\n>>> G_upper = np.triu(G_out)\n>>> info\n0",
  "sb02mu": "Construct Hamiltonian or symplectic matrix for Riccati equations.\n\nFor continuous-time (DICO='C'), constructs Hamiltonian:\n  S = [  A   -G ]\n      [ -Q   -A']\n\nFor discrete-time (DICO='D', HINV='D'), constructs symplectic:\n  S = [  A^(-1)        A^(-1)*G     ]\n      [ Q*A^(-1)   A' + Q*A^(-1)*G  ]\n\nFor discrete-time (DICO='D', HINV='I'), constructs inverse symplectic:\n  S = [ A + G*A^(-T)*Q   -G*A^(-T) ]\n      [    -A^(-T)*Q       A^(-T)  ]\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  hinv (str): 'D' or 'I' (only for discrete-time)\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  n (int): Order of A, G, Q (n >= 0)\n  a (ndarray): Matrix A (n x n, F-order)\n  g (ndarray): Symmetric matrix G (n x n, F-order)\n  q (ndarray): Symmetric matrix Q (n x n, F-order)\n\nReturns:\n  - S: Hamiltonian/symplectic matrix (2n x 2n)\n  - rcond: Reciprocal condition number of A (discrete) or 1.0 (continuous)\n  - info: Exit code (0=success)",
  "sb02mv": "Select stable eigenvalues for continuous-time Riccati.\n\nCallback function for DGEES eigenvalue selection. Returns True for\neigenvalues with real part < 0 (stable in continuous-time).\n\nUsed internally for continuous-time algebraic Riccati equation solvers.\n\nParameters:\n  reig (float): Real part of eigenvalue\n  ieig (float): Imaginary part of eigenvalue (unused)\n\nReturns:\n  bool: True if stable (reig < 0), False otherwise\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02mv\n>>> result = sb02mv(-1.0, 0.0)\n>>> assert_equal(result, True)\n>>> result = sb02mv(-0.5, 2.0)\n>>> assert_equal(result, True)\n>>> result = sb02mv(-100.0, 50.0)\n>>> assert_equal(result, True)",
  "sb02mw": "Select stable eigenvalues for discrete-time Riccati.\n\nCallback function for DGEES eigenvalue selection. Returns True for\neigenvalues with modulus < 1 (stable in discrete-time).\n\nUsed internally for discrete-time algebraic Riccati equation solvers.\n\nParameters:\n  reig (float): Real part of eigenvalue\n  ieig (float): Imaginary part of eigenvalue\n\nReturns:\n  bool: True if stable (|lambda| < 1), False otherwise\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02mw\n>>> result = sb02mw(0.0, 0.0)\n>>> assert_equal(result, True)\n>>> result = sb02mw(0.5, 0.0)\n>>> assert_equal(result, True)\n>>> result = sb02mw(0.0, 0.5)\n>>> assert_equal(result, True)\n>>> result = sb02mw(-0.5, 0.0)\n>>> assert_equal(result, True)\n>>> result = sb02mw(0.3, 0.4)\n>>> assert_equal(result, True)\n>>> result = sb02mw(0.6, -0.6)\n>>> assert_equal(result, True)",
  "sb02mx": "Extended Riccati preprocessing - convert coupling weight problems.\n\nComputes:\n  G = B*R^(-1)*B'\n  A_bar = A +/- op(B*R^(-1)*L')\n  Q_bar = Q +/- L*R^(-1)*L'\n\nExtended version of SB02MT with TRANS, FLAG, and DEF parameters.\n\nParameters:\n  jobg (str): 'G' to compute G, 'N' to skip\n  jobl (str): 'Z' if L is zero, 'N' if L is nonzero\n  fact (str): 'N' R unfactored, 'C' Cholesky, 'U' UdU'/LdL'\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  trans (str): 'N' op(W)=W, 'T'/'C' op(W)=W'\n  flag (str): 'P' plus sign, 'M' minus sign\n  def (str): 'D' R positive definite, 'I' R indefinite (for fact='N')\n  n (int): Order of A, Q, G (n >= 0)\n  m (int): Order of R (m >= 0)\n  a (ndarray or None): Matrix A (n x n, F-order) if jobl='N'\n  b (ndarray): Matrix B (n x m, F-order)\n  q (ndarray or None): Matrix Q (n x n, F-order) if jobl='N'\n  r (ndarray): Matrix R (m x m, F-order)\n  l (ndarray or None): Matrix L (n x m, F-order) if jobl='N'\n  g (ndarray or None): Output G (n x n, F-order) if jobg='G'\n\nReturns:\n  Variable outputs based on jobg and jobl:\n  - If jobg='G', jobl='Z': (g, oufact, info)\n  - If jobg='N', jobl='N': (a, b, q, l, oufact, info)\n  - If jobg='G', jobl='N': (a, b, q, l, g, oufact, info)\n\nExamples:\n\n>>> import numpy as np\n>>> n, m = 4, 2\n>>> B = np.random.randn(n, m).astype(float, order='F')\n>>> R_half = np.random.randn(m, m)\n>>> R = (R_half.T @ R_half + np.eye(m) * 3.0).astype(float, order='F')\n>>> R_inv = np.linalg.inv(R)\n>>> from slicot import sb02mx\n>>> G = np.zeros((n, n), dtype=float, order='F')\n>>> G_out, oufact, info = sb02mx(\n...     'G', 'Z', 'N', 'U', 'N', 'M', 'D',\n...     )\n>>> G_upper = np.triu(G_out)\n>>> info\n0",
  "sb02nd": "Optimal state feedback matrix for optimal control problem.\n\nComputes:\n  F = (R + B'XB)^(-1) (B'XA + L')  [discrete-time]\n  F = R^(-1) (B'X + L')            [continuous-time]\n\nParameters:\n  dico (str): 'D' for discrete-time, 'C' for continuous-time\n  fact (str): 'N' R unfactored, 'D' R=D'D, 'C' Cholesky, 'U' UdU'/LdL' (continuous only)\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  jobl (str): 'Z' if L is zero, 'N' if L is nonzero\n  n (int): Order of A, X (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Rows of D if fact='D' (p >= m for continuous)\n  rnorm (float): 1-norm of R (required for fact='U' only)\n  a (ndarray): State matrix A (n x n, F-order), discrete only\n  b (ndarray): Input matrix B (n x m, F-order)\n  r (ndarray): Weighting matrix R (m x m or p x m, F-order)\n  ipiv (ndarray): Pivot indices (m,), input for fact='U'\n  l (ndarray): Cross weighting L (n x m, F-order) if jobl='N'\n  x (ndarray): Riccati solution X (n x n, F-order)\n\nReturns:\n  (f, r_out, x_out, oufact, rcond, info):\n  - f: Optimal feedback matrix F (m x n)\n  - r_out: Factored R or R+B'XB\n  - x_out: Possibly modified X (for discrete with factored R)\n  - oufact: Array [fact_type, x_fact_type]\n  - rcond: Reciprocal condition number\n  - info: Exit code (0=success, m+1=singular)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02nd\n>>> n, m = 2, 1\n>>> p = 0\n>>> a = np.array([[2.0, -1.0],\n...     [1.0, 0.0]], order='F', dtype=float)\n>>> b = np.array([[1.0],\n...     [0.0]], order='F', dtype=float)\n>>> r = np.zeros((m, m), order='F', dtype=float)\n>>> x = np.eye(n, order='F', dtype=float)\n>>> l = np.zeros((n, m), order='F', dtype=float)\n>>> ipiv = np.zeros(m, dtype=np.int32)\n>>> rnorm = 0.0\n>>> f, r_out, x_out, oufact, rcond, info = sb02nd(\n...     'D', 'N', 'U', 'Z', n, m, p, a, b, r, ipiv, l, x, rnorm\n...     )\n>>> info\n0",
  "sb02od": "Solve continuous- or discrete-time algebraic Riccati equations.\n\nSolves for X either:\n  Continuous: Q + A'X + XA - (L+XB)R^(-1)(L+XB)' = 0\n  Discrete:   X = A'XA - (L+A'XB)(R + B'XB)^(-1)(L+A'XB)' + Q\n\nUses deflating subspaces with eigenvalue reordering.\nSuited for ill-conditioned R (uses internal scaling).\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  jobb (str): 'B' matrices B,R given, 'G' matrix G given\n  fact (str): 'N' Q,R given, 'C' Q=C'C, 'D' R=D'D, 'B' both factored\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  jobl (str): 'Z' L is zero, 'N' L is nonzero\n  sort (str): 'S' stable eigenvalues first, 'U' unstable first\n  n (int): State dimension (>= 0)\n  m (int): Number of inputs (>= 0, for JOBB='B')\n  p (int): Number of outputs (for FACT='C','D','B')\n  a (ndarray): N-by-N state matrix A (F-order)\n  b (ndarray): N-by-M input matrix B or N-by-N matrix G (F-order)\n  q (ndarray): N-by-N symmetric Q or P-by-N output matrix C (F-order)\n  r (ndarray or None): M-by-M symmetric R or P-by-M matrix D (F-order)\n  l (ndarray or None): N-by-M cross-weighting L (F-order)\n  tol (float): Tolerance for singularity test (<=0 uses eps)\n\nReturns:\n  (x, rcond, alfar, alfai, beta, s, t, u, info):\n    x: N-by-N solution matrix\n    rcond: Reciprocal condition number\n    alfar, alfai, beta: Generalized eigenvalues (lambda = (alfar+j*alfai)/beta)\n    s, t: 2N-by-2N Schur matrices\n    u: 2N-by-2N transformation matrix\n    info: 0=success, 1-6 various errors\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02od\n>>> n, m, p = 2, 1, 3\n>>> A = np.array([\n...     [0.0, 1.0],\n...     [0.0, 0.0]\n...     ], dtype=float, order='F')\n>>> B = np.array([\n...     [0.0],\n...     [1.0]\n...     ], dtype=float, order='F')\n>>> C = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [0.0, 0.0]\n...     ], dtype=float, order='F')\n>>> D = np.array([\n...     [0.0],\n...     [0.0],\n...     [1.0]\n...     ], dtype=float, order='F')\n>>> L = np.zeros((n, m), dtype=float, order='F')\n>>> X, rcond, alfar, alfai, beta, S, T, U, info = sb02od(\n...     'C', 'B', 'B', 'U', 'Z', 'S',\n...     n, m, p, A, B, C, D, L, 0.0\n...     )\n>>> info\n0",
  "sb02ou": "Select unstable generalized eigenvalues for continuous-time Riccati.\n\nCallback function for DGGES eigenvalue selection. Returns True for\ngeneralized eigenvalues with positive real part (unstable in continuous-time).\n\nSelection criterion: (ALPHAR < 0 AND BETA < 0) OR (ALPHAR > 0 AND BETA > 0)\nThis is equivalent to: Re(lambda) = ALPHAR/BETA > 0\n\nUsed internally by SB02OD for continuous-time algebraic Riccati equation solver.\n\nParameters:\n  alphar (float): Real part of eigenvalue numerator\n  alphai (float): Imaginary part of eigenvalue numerator (unused)\n  beta (float): Eigenvalue denominator\n\nReturns:\n  bool: True if unstable (Re(lambda) > 0), False otherwise\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02ou\n>>> result = sb02ou(1.0, 0.0, 2.0)",
  "sb02ov": "Select unstable generalized eigenvalues for discrete-time Riccati.\n\nCallback function for DGGES eigenvalue selection. Returns True for\ngeneralized eigenvalues with modulus >= 1 (unstable in discrete-time).\n\nSelection criterion: sqrt(ALPHAR^2 + ALPHAI^2) >= abs(BETA)\nThis is equivalent to: |lambda| = |ALPHAR + i*ALPHAI|/|BETA| >= 1\n\nUsed internally by discrete-time algebraic Riccati equation solvers.\n\nParameters:\n  alphar (float): Real part of eigenvalue numerator\n  alphai (float): Imaginary part of eigenvalue numerator\n  beta (float): Eigenvalue denominator\n\nReturns:\n  bool: True if unstable (|lambda| >= 1), False otherwise\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02ov\n>>> result = sb02ov(2.0, 0.0, 1.0)",
  "sb02ow": "Select stable generalized eigenvalues for continuous-time Riccati.\n\nCallback function for DGGES eigenvalue selection. Returns True for\ngeneralized eigenvalues with negative real part (stable in continuous-time).\n\nSelection criterion: (ALPHAR < 0 AND BETA > 0) OR (ALPHAR > 0 AND BETA < 0)\nThis is equivalent to: Re(lambda) = ALPHAR/BETA < 0\n\nUsed internally by SB02OD for continuous-time algebraic Riccati equation solver.\n\nParameters:\n  alphar (float): Real part of eigenvalue numerator\n  alphai (float): Imaginary part of eigenvalue numerator (unused)\n  beta (float): Eigenvalue denominator\n\nReturns:\n  bool: True if stable (Re(lambda) < 0), False otherwise\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02ow\n>>> result = sb02ow(-1.0, 0.0, 2.0)",
  "sb02ox": "Select stable generalized eigenvalues for discrete-time Riccati.\n\nCallback function for DGGES eigenvalue selection. Returns True for\ngeneralized eigenvalues with modulus less than 1 (stable in discrete-time).\n\nSelection criterion: sqrt(ALPHAR^2 + ALPHAI^2) < abs(BETA)\nThis is equivalent to: |lambda| = |ALPHAR + i*ALPHAI|/|BETA| < 1\n\nUsed internally by discrete-time algebraic Riccati equation solvers.\n\nParameters:\n  alphar (float): Real part of eigenvalue numerator\n  alphai (float): Imaginary part of eigenvalue numerator\n  beta (float): Eigenvalue denominator\n\nReturns:\n  bool: True if stable (|lambda| < 1), False otherwise\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02ox\n>>> result = sb02ox(1.0, 0.0, 2.0)",
  "sb02oy": "Construct extended Hamiltonian/symplectic matrix pairs for Riccati equations.\n\nConstructs extended matrix pairs for algebraic Riccati equations in optimal\ncontrol and spectral factorization problems, then compresses to 2N-by-2N.\n\nParameters:\n  type_str (str): 'O' optimal control, 'S' spectral factorization\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  jobb (str): 'B' matrices B,R given, 'G' matrix G given\n  fact (str): 'N' Q,R given, 'C' Q=C'C, 'D' R=D'D, 'B' both factored\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  jobl (str): 'Z' L is zero, 'N' L is nonzero\n  jobe (str): 'I' E is identity, 'N' E is general\n  n (int): Order of A, Q, E (>= 0)\n  m (int): Order of R, columns of B (>= 0, for JOBB='B')\n  p (int): Rows of C/D (for FACT='C','D','B' or TYPE='S')\n  a (ndarray): N-by-N state matrix A (F-order)\n  b (ndarray): N-by-M input matrix B or N-by-N matrix G (F-order)\n  q (ndarray): N-by-N symmetric Q or P-by-N output matrix C (F-order)\n  r (ndarray or None): M-by-M symmetric R or P-by-M matrix D (F-order)\n  l (ndarray or None): N-by-M cross-weighting L (F-order)\n  e (ndarray): N-by-N descriptor E (F-order)\n  tol (float): Tolerance for singularity test (<=0 uses eps)\n\nReturns:\n  For JOBB='B': (af, bf, rcond, info) - 2N-by-2N matrices, condition number\n  For JOBB='G', DICO='C', JOBE='I': (af, info) - 2N-by-2N matrix only\n  For JOBB='G' otherwise: (af, bf, info) - 2N-by-2N matrices\n\nExamples:\n\n>>> import numpy as np\n>>> n, m = 3, 2\n>>> A = np.random.randn(n, n).astype(float, order='F')\n>>> B = np.random.randn(n, m).astype(float, order='F')\n>>> Q_half = np.random.randn(n, n)\n>>> Q = ((Q_half.T @ Q_half) + np.eye(n) * 2.0).astype(float, order='F')\n>>> R_half = np.random.randn(m, m)\n>>> R = (R_half.T @ R_half + np.eye(m) * 3.0).astype(float, order='F')\n>>> L = np.zeros((n, m), dtype=float, order='F')\n>>> E = np.eye(n, dtype=float, order='F')\n>>> from slicot import sb02oy\n>>> AF, BF, rcond, info = sb02oy(\n...     'O', 'D', 'B', 'N', 'U', 'Z', 'I',\n...     n, m, 0, A, B, Q, R, L, E, 0.0\n...     )\n>>> info\n0",
  "sb02pd": "Continuous-time algebraic Riccati equation solver using matrix sign function.\n\nSolves the real continuous-time matrix algebraic Riccati equation:\n    op(A)'*X + X*op(A) + Q - X*G*X = 0\nwhere op(A) = A or A', G and Q are symmetric.\n\nOptionally computes error bound and condition estimate.\n\nParameters:\n  a (ndarray): N-by-N coefficient matrix A (F-order)\n  g (ndarray): N-by-N symmetric matrix G (F-order)\n  q (ndarray): N-by-N symmetric matrix Q (F-order)\n  job (str): 'X' solution only (default), 'A' all (solution, rcond, ferr)\n  trana (str): 'N' op(A)=A (default), 'T'/'C' op(A)=A'\n  uplo (str): 'U' upper triangle (default), 'L' lower triangle of G, Q\n\nReturns:\n  (X, rcond, ferr, wr, wi, info):\n  - X: N-by-N symmetric solution matrix\n  - rcond: Reciprocal condition number (if job='A')\n  - ferr: Forward error bound (if job='A')\n  - wr, wi: Real and imaginary parts of closed-loop eigenvalues (if job='A')\n  - info: 0=success, 1=imaginary eigenvalues, 2=no convergence (approx computed),\n          3=singular system, 4=Schur reduction failed\n\nExamples:\n\n>>> from slicot import sb02pd\n>>> import numpy as np\n>>> n = 2\n>>> a = np.array([\n...     [0.0, 1.0],\n...     [0.0, 0.0]\n...     ], dtype=float, order='F')\n>>> q = np.array([\n...     [1.0, 0.0],\n...     [0.0, 2.0]\n...     ], dtype=float, order='F')\n>>> g = np.array([\n...     [0.0, 0.0],\n...     [0.0, 1.0]\n...     ], dtype=float, order='F')\n>>> x, rcond, ferr, wr, wi, info = sb02pd(a, g, q, job='A', trana='N', uplo='U')\n>>> info\n0",
  "sb02qd": "Estimate conditioning and error bound for continuous-time Riccati equation.\n\nEstimates conditioning and computes forward error bound for:\n    op(A)'*X + X*op(A) + Q - X*G*X = 0\nwhere op(A) = A or A', Q and G are symmetric.\n\nParameters:\n  job (str): 'C' condition only, 'E' error only, 'B' both\n  fact (str): 'N' compute Schur, 'F' Schur factorization provided\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  uplo (str): 'U' for upper, 'L' for lower triangular Q, G\n  lyapun (str): 'O' for original, 'R' for reduced Lyapunov\n  a (ndarray): N-by-N matrix A (F-order)\n  t (ndarray): N-by-N Schur matrix T (F-order, input if fact='F', output if 'N')\n  u (ndarray): N-by-N orthogonal matrix U (F-order, input/output)\n  g (ndarray): N-by-N symmetric matrix G (F-order)\n  q (ndarray): N-by-N symmetric matrix Q (F-order)\n  x (ndarray): N-by-N symmetric solution X (F-order)\n\nReturns:\n  (sep, rcond, ferr, t, u, info):\n  - sep: Estimated separation sep(op(Ac), -op(Ac)')\n  - rcond: Reciprocal condition number estimate\n  - ferr: Forward error bound estimate\n  - t: Updated Schur form T\n  - u: Updated orthogonal matrix U\n  - info: Exit code (0=success, >0=algorithm error)\n\nExamples:\n\n>>> from slicot import sb02qd\n>>> import numpy as np\n>>> n = 2\n>>> a = np.array([[0.0, 1.0],\n...     [0.0, 0.0]], order='F', dtype=float)\n>>> q = np.array([[1.0, 0.0],\n...     [0.0, 2.0]], order='F', dtype=float)\n>>> g = np.array([[0.0, 0.0],\n...     [0.0, 1.0]], order='F', dtype=float)\n>>> x = np.array([[2.0, 1.0],\n...     [1.0, 2.0]], order='F', dtype=float)\n>>> t = np.zeros((n, n), order='F', dtype=float)\n>>> u = np.zeros((n, n), order='F', dtype=float)\n>>> sep, rcond, ferr, t_out, u_out, info = sb02qd(\n...     'B', 'N', 'N', 'U', 'O', a, t, u, g, q, x\n...     )\n>>> info\n0",
  "sb02rd": "Solve algebraic Riccati equation using Schur vector method.\n\nSolves continuous-time Riccati equation:\n  Q + A'*X + X*A - X*G*X = 0       (DICO='C')\nor discrete-time Riccati equation:\n  Q + A'*X*(I + G*X)^(-1)*A - X = 0  (DICO='D')\n\nParameters:\n  job (str): 'X' solution, 'C' condition, 'E' error bound, 'A' all\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  hinv (str): 'D' direct, 'I' inverse (for discrete-time)\n  trana (str): 'N' no transpose, 'T'/'C' transpose of A\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  scal (str): 'G' general scaling, 'N' no scaling\n  sort (str): 'S' stable eigenvalues first, 'U' unstable first\n  fact (str): 'N' compute Schur, 'F' Schur factorization provided\n  lyapun (str): 'O' original equations, 'R' reduced equations\n  A (ndarray): State matrix A (n x n, F-order)\n  Q (ndarray): Symmetric matrix Q (n x n, F-order)\n  G (ndarray): Symmetric matrix G = B*R^(-1)*B' (n x n, F-order)\n  T (ndarray, optional): Schur form matrix (n x n, F-order)\n  V (ndarray, optional): Schur vectors (n x n, F-order)\n\nReturns:\n  (X, sep, rcond, ferr, wr, wi, S, info):\n  - X: Solution matrix X (n x n)\n  - sep: Separation or scaling factor\n  - rcond: Reciprocal condition number\n  - ferr: Forward error bound\n  - wr, wi: Real and imaginary parts of eigenvalues (2*n,)\n  - S: Ordered Schur form (2*n x 2*n)\n  - info: Exit code (0=success, >0=error)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02rd\n>>> n = 2\n>>> A = np.array([[0.0, 1.0],\n...     [0.0, 0.0]], order='F', dtype=float)\n>>> Q = np.array([[1.0, 0.0],\n...     [0.0, 2.0]], order='F', dtype=float)\n>>> G = np.array([[0.0, 0.0],\n...     [0.0, 1.0]], order='F', dtype=float)\n>>> X, sep, rcond, ferr, wr, wi, s, info = sb02rd(\n...     job='X',\n...     dico='C',\n...     hinv='D',\n...     trana='N',\n...     uplo='U',\n...     scal='N',\n...     sort='S',\n...     fact='N',\n...     lyapun='O',\n...     A=A,\n...     Q=Q,\n...     G=G\n...     )\n>>> info\n0",
  "sb02ru": "Construct Hamiltonian or symplectic matrix for Riccati equation.\n\nFor continuous-time (DICO='C'), constructs Hamiltonian matrix:\n    S = [ op(A)   -G    ]\n        [  -Q   -op(A)' ]\n\nFor discrete-time (DICO='D'), constructs symplectic matrix.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  hinv (str): 'D' or 'I' for discrete formula variant\n  trana (str): 'N' op(A)=A, 'T'/'C' op(A)=A'\n  uplo (str): 'U' upper tri stored, 'L' lower tri stored\n  a (ndarray): N-by-N state matrix A (F-order)\n  g (ndarray): N-by-N symmetric G matrix (F-order)\n  q (ndarray): N-by-N symmetric Q matrix (F-order)\n\nReturns:\n  (s, rcond, pivotg, info): 2N-by-2N Hamiltonian/symplectic matrix,\n                           condition number (discrete only), pivot growth,\n                           exit code (0=success)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb02ru\n>>> n = 3\n>>> A = np.random.randn(n, n).astype(float, order='F')\n>>> G = np.eye(n, dtype=float, order='F') * 0.5\n>>> Q = np.eye(n, dtype=float, order='F')\n>>> S, rcond, pivotg, info = sb02ru('C', 'D', 'N', 'U', A, G, Q)\n>>> S11 = S[:n, :n]\n>>> S12 = S[:n, n:]\n>>> S21 = S[n:, :n]\n>>> S22 = S[n:, n:]\n>>> info\n0",
  "sb02sd": "Condition and error bound for discrete-time Riccati equation.\n\nEstimates conditioning and computes error bound for:\n    X = op(A)'*X*(I_n + G*X)^-1*op(A) + Q\n\nParameters:\n  job (str): 'C' for rcond only, 'E' for ferr only, 'B' for both\n  fact (str): 'N' to compute Schur, 'F' if Schur supplied\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  uplo (str): 'U' for upper, 'L' for lower triangular Q, G\n  lyapun (str): 'O' for original, 'R' for reduced Lyapunov\n  n (int): Order of matrices\n  a (ndarray): N-by-N matrix A (F-order)\n  t (ndarray): N-by-N Schur matrix T (F-order)\n  u (ndarray): N-by-N orthogonal matrix U (F-order)\n  g (ndarray): N-by-N symmetric matrix G (F-order)\n  q (ndarray): N-by-N symmetric matrix Q (F-order)\n  x (ndarray): N-by-N symmetric solution X (F-order)\n\nReturns:\n  (t, u, sepd, rcond, ferr, info): Updated T, U, separation, rcond, error, exit code\n\nExamples:\n\n>>> from slicot import sb02sd\n>>> import numpy as np\n>>> n = 3\n>>> a = np.random.randn(n, n).astype(float, order='F')\n...     a[i, i] = 0.5 + 0.1 * i\n>>> t = np.zeros((n, n), order='F', dtype=float)\n>>> u = np.eye(n, order='F', dtype=float)\n>>> g = np.eye(n, order='F', dtype=float) * 0.1\n>>> q = np.eye(n, order='F', dtype=float) * 0.5\n>>> x = np.eye(n, order='F', dtype=float) * 0.3\n>>> t_out, u_out, sepd, rcond, ferr, info = sb02sd(\n...     'C', 'N', 'N', 'U', 'O', n, a, t, u, g, q, x)\n>>> info\n0",
  "sb03md": "Solve continuous or discrete Lyapunov equation.\n\nSolves op(A)'*X + X*op(A) = scale*C (continuous) or\nop(A)'*X*op(A) - X = scale*C (discrete).\n\nParameters:\n  dico (str): 'C' for continuous, 'D' for discrete\n  job (str): 'X' solution, 'S' separation, 'B' both\n  fact (str): 'N' compute Schur, 'F' provided\n  trana (str): 'N' for A, 'T' for A'\n  n (int): Order of matrices\n  a (ndarray): Matrix A (n x n, F-order)\n  c (ndarray): Symmetric RHS C (n x n, F-order)\n  u (ndarray, optional): Schur transformation if FACT='F'\n\nReturns:\n  (x, a, u, wr, wi, scale, sep, ferr, info):\n    Solution, Schur form, transformation, eigenvalues, scale, info\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03md\n>>> n = 3\n>>> a = np.array([\n...     [3.0, 1.0, 1.0],\n...     [1.0, 3.0, 0.0],\n...     [0.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [25.0, 24.0, 15.0],\n...     [24.0, 32.0,  8.0],\n...     [15.0,  8.0, 40.0]\n...     ], order='F', dtype=float)\n>>> result = sb03md('D', 'X', 'N', 'N', n, a.copy(order='F'),\n...     c.copy(order='F'))\n>>> x, a_out, u, wr, wi, scale, sep, ferr, info = result",
  "sb03mu": "Solve small discrete-time Sylvester equation.\n\nSolves ISGN*op(TL)*X*op(TR) - X = SCALE*B where TL is N1-by-N1,\nTR is N2-by-N2, N1,N2 in {0,1,2}, ISGN = 1 or -1.\n\nParameters:\n  ltranl (bool): If True, op(TL)=TL', else op(TL)=TL\n  ltranr (bool): If True, op(TR)=TR', else op(TR)=TR\n  isgn (int): Sign of equation (1 or -1)\n  tl (ndarray): N1-by-N1 matrix TL (F-order)\n  tr (ndarray): N2-by-N2 matrix TR (F-order)\n  b (ndarray): N1-by-N2 RHS matrix B (F-order)\n\nReturns:\n  (X, scale, xnorm, info): Solution X, scale factor, inf-norm, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03mu\n>>> tl = np.array([[2.0]], order='F', dtype=float)\n>>> tr = np.array([[3.0]], order='F', dtype=float)\n>>> b = np.array([[1.0]], order='F', dtype=float)\n>>> x, scale, xnorm, info = sb03mu(False, False, 1, tl, tr, b)\n>>> residual = tl @ x @ tr - x - scale * b\n>>> info\n0",
  "sb03mv": "Solve 2x2 discrete-time Lyapunov equation.\n\nSolves op(T)'*X*op(T) - X = SCALE*B for symmetric X.\n\nParameters:\n  t (array): 2x2 matrix T\n  b (array): 2x2 symmetric matrix B\n  ltran (bool): If True, op(T)=T', else op(T)=T. Default: False\n  lupper (bool): If True, upper triangle. Default: True\n\nReturns:\n  (X, scale, xnorm, info): Solution X, scale factor, inf-norm, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03mv\n>>> T = np.array([\n...     [0.5, 0.1],\n...     [0.0, 0.3]\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [1.0, 0.2],\n...     [0.0, 0.5]  # Only upper triangle used\n...     ], order='F', dtype=float)\n>>> X, scale, xnorm, info = sb03mv(T, B, ltran=False, lupper=True)\n>>> X_sym = np.triu(X) + np.triu(X, 1).T\n>>> B_sym = np.triu(B) + np.triu(B, 1).T\n>>> residual = T.T @ X_sym @ T - X_sym - scale * B_sym\n>>> info\n0",
  "sb03mw": "Solve 2x2 continuous-time Lyapunov equation.\n\nSolves op(T)'*X + X*op(T) = SCALE*B for symmetric X.\n\nParameters:\n  t (array): 2x2 matrix T\n  b (array): 2x2 symmetric matrix B\n  ltran (bool): If True, op(T)=T', else op(T)=T. Default: False\n  lupper (bool): If True, upper triangle. Default: True\n\nReturns:\n  (X, scale, xnorm, info): Solution X, scale factor, inf-norm, exit code\n\nExamples:\n\n>>> from slicot import sb03mw\n>>> import numpy as np\n>>> t = np.array([[-2.0, 0.0], [1.0, -3.0]], order='F') # T is Upper in C (row 0: -2, 1; row 1: 0, -3) -> Wait, Fortran order.\n>>> t = np.array([[-2.0, 0.0], [1.0, -3.0]], order='F')\n>>> b = np.eye(2, order='F')\n>>> x, scale, xnorm, info = sb03mw(ltran=False, lupper=True, t=t, b=b)\n>>> x_full = np.triu(x) + np.triu(x, 1).T\n>>> res = t.T @ x_full + x_full @ t - scale * b\n>>> info\n0",
  "sb03mx": "Solve discrete-time Lyapunov for quasi-triangular A.\n\nSolves op(A)'*X*op(A) - X = scale*C where A is Schur form.\n\nParameters:\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  a (ndarray): Upper quasi-triangular matrix (n x n, F-order)\n  c (ndarray): Symmetric RHS C, overwritten with solution X (n x n, F-order)\n\nReturns:\n  (X, scale, info): Solution X, scale factor, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03mx\n>>> a = np.array([\n...     [0.5, 0.0, 0.0],\n...     [0.0, 0.3, 0.0],\n...     [0.0, 0.0, 0.4]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.2, 0.1],\n...     [0.2, 2.0, 0.3],\n...     [0.1, 0.3, 1.5]\n...     ], order='F', dtype=float)\n>>> n = 3\n>>> x, scale, info = sb03mx('N', a.copy(order='F'), c.copy(order='F'))\n>>> info\n0",
  "sb03my": "Solve continuous-time Lyapunov for quasi-triangular A.\n\nSolves op(A)'*X + X*op(A) = scale*C where A is Schur form.\n\nParameters:\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  a (ndarray): Upper quasi-triangular matrix (n x n, F-order)\n  c (ndarray): Symmetric RHS C, overwritten with solution X (n x n, F-order)\n\nReturns:\n  (X, scale, info): Solution X, scale factor, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03my\n>>> a = np.array([\n...     [-2.0, 0.0, 0.0],\n...     [ 0.0,-3.0, 0.0],\n...     [ 0.0, 0.0,-1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [4.0, 1.0, 0.5],\n...     [1.0, 3.0, 0.3],\n...     [0.5, 0.3, 2.0]\n...     ], order='F', dtype=float)\n>>> n = 3\n>>> x, scale, info = sb03my('N', a.copy(order='F'), c.copy(order='F'))\n>>> info\n0",
  "sb03od": "Solve stable Lyapunov equation for Cholesky factor.\n\nSolves either:\n  A'*X + X*A = -scale\u00b2*B'*B   (continuous-time)\n  A'*X*A - X = -scale\u00b2*B'*B   (discrete-time)\nwhere X = U'*U (Cholesky factorization)\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  fact (str): 'N' compute Schur, 'F' Schur factorization provided\n  trans (str): 'N' for no transpose, 'T' for transpose of A,B\n  a (ndarray): State matrix A (n x n, F-order) or Schur factor S\n  b (ndarray): Right-hand side B (m x n, F-order) if trans='N'\n               or (n x m, F-order) if trans='T'\n  q (ndarray): Schur vectors Q (n x n, F-order) if fact='F'\n\nReturns:\n  (u, q_out, wr, wi, scale, info):\n  - u: Upper triangular Cholesky factor U (n x n)\n  - q_out: Orthogonal Schur vectors (if computed)\n  - wr: Real parts of eigenvalues (n,)\n  - wi: Imaginary parts of eigenvalues (n,)\n  - scale: Scale factor (scale <= 1)\n  - info: Exit code (0=success, 1=nearly singular, 2/3=unstable)\n\nExamples:\n\n>>> from slicot import sb03od\n>>> import numpy as np\n>>> n, m = 4, 5\n>>> a = np.array([\n...     [-1.0, 37.0, -12.0, -12.0],\n...     [-1.0, -10.0, 0.0, 4.0],\n...     [2.0, -4.0, 7.0, -6.0],\n...     [2.0, 2.0, 7.0, -9.0]\n...     ], order='F', dtype=np.float64)\n>>> q = np.zeros((n, n), order='F', dtype=np.float64)\n>>> b = np.array([\n...     [1.0, 2.5, 1.0, 3.5],\n...     [0.0, 1.0, 0.0, 1.0],\n...     [-1.0, -2.5, -1.0, -1.5],\n...     [1.0, 2.5, 4.0, -5.5],\n...     [-1.0, -2.5, -4.0, 3.5]\n...     ], order='F', dtype=np.float64)\n>>> scale = ctypes.c_double(0.0)\n>>> wr = np.zeros(n, dtype=np.float64)\n>>> wi = np.zeros(n, dtype=np.float64)\n>>> ldwork = max(1, 4*n)\n>>> dwork = np.zeros(ldwork, dtype=np.float64)\n>>> info = ctypes.c_int(0)\n>>> ldb = max(n, m)\n>>> b_padded = np.zeros((ldb, max(m, n)), order='F', dtype=np.float64)\n>>> b_padded[:m, :n] = b\n>>> sb03od(\n...     b\"C\", b\"N\", b\"N\", n, m,\n...     a.ctypes.data_as(ctypes.POINTER(ctypes.c_double)), n,\n...     q.ctypes.data_as(ctypes.POINTER(ctypes.c_double)), n,\n...     b_padded.ctypes.data_as(ctypes.POINTER(ctypes.c_double)), ldb,\n...     ctypes.byref(scale),\n...     wr.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n...     wi.ctypes.data_as(ctypes.POINTER(ctypes.c_double)),\n...     dwork.ctypes.data_as(ctypes.POINTER(ctypes.c_double)), ldwork,\n...     ctypes.byref(info)\n...     )\n>>> u = np.triu(b_padded[:n, :n])",
  "sb03ou": "Solve Lyapunov equation for Cholesky factor.\n\nComputes upper triangular matrix U such that X = op(U)'*op(U) satisfies:\n  Continuous: op(A)'*X + X*op(A) = -scale^2 * op(B)'*op(B)\n  Discrete:   op(A)'*X*op(A) - X = -scale^2 * op(B)'*op(B)\n\nParameters:\n  discr (bool): If True, solve discrete equation\n  ltrans (bool): If True, op(K)=K'; otherwise op(K)=K\n  a (ndarray): N-by-N upper quasi-triangular matrix A in Schur form\n  b (ndarray): M-by-N (or N-by-M if ltrans) matrix B\n\nReturns:\n  (u, scale, info): Upper triangular Cholesky factor U, scale factor, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03ou\n>>> n = 3\n>>> m = 3\n>>> a = np.diag([-1.0, -2.0, -3.0]).astype(float, order='F')\n>>> b = np.eye(m, n, dtype=float, order='F')\n>>> u, scale, info = sb03ou(False, False, a, b.copy(order='F'))\n>>> x = u.T @ u\n>>> residual = a.T @ x + x @ a + (scale**2) * (b.T @ b)\n>>> info\n0",
  "sb03ov": "Construct complex plane rotation for Lyapunov solver.\n\nParameters:\n  a_re (float): Real part of complex number a\n  a_im (float): Imaginary part of complex number a\n  b (float): Real number b\n  small (float): Threshold for unit matrix\n\nReturns:\n  (d, c_re, c_im, s, info): d, complex cosine, real sine, exit code\n\nExamples:\n\n>>> from slicot import sb03ov\n>>> import numpy as np\n>>> a_re, a_im = 3.0, 4.0\n>>> b = 5.0\n>>> small = 1e-15\n>>> d, c_re, c_im, s, info = sb03ov(a_re, a_im, b, small)\n>>> expected_d = np.sqrt(a_re**2 + a_im**2 + b**2)\n>>> info\n0",
  "sb03pd": "Solve discrete-time Lyapunov equation with separation estimation.\n\nSolves op(A)'*X*op(A) - X = scale*C and/or estimates separation.\n\nParameters:\n  job (str): 'X' solution only, 'S' separation only, 'B' both\n  fact (str): 'N' compute Schur, 'F' Schur provided\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  a (ndarray): N-by-N matrix A (F-order)\n  c (ndarray): N-by-N symmetric RHS C (F-order)\n  u (ndarray): N-by-N orthogonal U if fact='F' (optional)\n\nReturns:\n  For job='X': (a, u, x, scale, wr, wi, info)\n  For job='S': (a, u, None, scale, sepd, wr, wi, info)\n  For job='B': (a, u, x, scale, sepd, ferr, wr, wi, info)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03pd\n>>> n = 3\n>>> a = np.array([\n...     [0.5, 0.1, 0.0],\n...     [0.0, 0.3, 0.2],\n...     [0.0, 0.0, 0.4]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.2, 0.1],\n...     [0.2, 1.5, 0.3],\n...     [0.1, 0.3, 2.0]\n...     ], order='F', dtype=float)\n>>> a_out, u, x, scale, wr, wi, info = sb03pd('X', 'N', 'N', a.copy(order='F'), c.copy(order='F'))\n>>> residual = a.T @ x @ a - x - scale * c\n>>> info\n0",
  "sb03qd": "Estimate conditioning and forward error bound for continuous-time Lyapunov.\n\nEstimates the conditioning and computes an error bound on the solution of:\n  op(A)' * X + X * op(A) = scale * C\nwhere op(A) = A or A^T, C is symmetric.\n\nParameters:\n  job (str): 'C' condition only, 'E' error only, 'B' both\n  fact (str): 'F' Schur form provided, 'N' compute Schur\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A^T\n  uplo (str): 'U' upper triangle of C, 'L' lower triangle\n  lyapun (str): 'O' original equations, 'R' reduced equations\n  scale (float): Scale factor from Lyapunov solver (0 <= scale <= 1)\n  a (ndarray): N-by-N matrix A (F-order)\n  t (ndarray): N-by-N Schur form matrix T (F-order)\n  u (ndarray): N-by-N orthogonal Schur factor U (F-order)\n  c (ndarray): N-by-N symmetric matrix C (F-order)\n  x (ndarray): N-by-N symmetric solution matrix X (F-order)\n\nReturns:\n  (sep, rcond, ferr, t_out, u_out, info):\n  sep: Separation estimate sep(op(A),-op(A)')\n  rcond: Reciprocal condition number estimate\n  ferr: Forward error bound\n  t_out: Schur form of A\n  u_out: Orthogonal transformation matrix\n  info: 0=success, 1..n=DGEES fail, n+1=near-common eigenvalues\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03qd\n>>> n = 3\n>>> a = np.array([\n...     [3.0, 1.0, 1.0],\n...     [1.0, 3.0, 0.0],\n...     [0.0, 0.0, 3.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [25.0, 24.0, 15.0],\n...     [24.0, 32.0,  8.0],\n...     [15.0,  8.0, 40.0]\n...     ], order='F', dtype=float)\n>>> result = sb03md('C', 'X', 'N', 'N', n, a.copy(order='F'), c.copy(order='F'))\n>>> x, t_out, u_out, wr, wi, scale, sep_md, ferr_md, info_md = result\n>>> sep, rcond, ferr, t_out2, u_out2, info = sb03qd(\n...     'B', 'F', 'N', 'U', 'O', scale, a, t_out, u_out, c, x\n...     )\n>>> info\n0",
  "sb03qx": "Estimate forward error bound for continuous-time Lyapunov equation.\n\nEstimates forward error bound for solution X of op(A)'*X + X*op(A) = C.\n\nParameters:\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  uplo (str): 'U' for upper, 'L' for lower triangle of R\n  lyapun (str): 'O' for original (use U), 'R' for reduced form\n  n (int): Order of matrices\n  xanorm (float): Max-norm of solution matrix X\n  t (ndarray): Schur form matrix T (n x n, F-order)\n  u (ndarray): Orthogonal transformation U (n x n, F-order)\n  r (ndarray): Absolute residual matrix R (n x n, F-order)\n\nReturns:\n  (ferr, r, info): Forward error bound, symmetrized R, exit code",
  "sb03qy": "Estimate separation and 1-norm of Theta for continuous-time Lyapunov equation.\n\nEstimates sep(op(A), -op(A)') = min norm(op(A)'*X + X*op(A))/norm(X)\nand/or 1-norm of Theta operator for op(A)'*X + X*op(A) = C.\n\nParameters:\n  job (str): 'S' for separation, 'T' for Theta norm, 'B' for both\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  lyapun (str): 'O' for original (use U), 'R' for reduced form\n  t (ndarray): Schur form matrix T (n x n, F-order)\n  u (ndarray): Orthogonal transformation U (n x n, F-order)\n  x (ndarray): Lyapunov solution matrix X (n x n, F-order)\n\nReturns:\n  (sep, thnorm, info): Separation, Theta norm, exit code (N+1=close eigenvalues)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03qy\n>>> n = 3\n>>> t = np.array([\n...     [-2.0, 0.0, 0.0],\n...     [ 0.0,-3.0, 0.0],\n...     [ 0.0, 0.0,-1.0]\n...     ], order='F', dtype=float)\n>>> u = np.eye(n, order='F', dtype=float)\n>>> x = np.zeros((n, n), order='F', dtype=float)\n>>> sep, thnorm, info = sb03qy('S', 'N', 'R', t, u, x)\n>>> info\n0",
  "sb03rd": "Solve continuous-time Lyapunov equation with separation estimation.\n\nSolves: op(A)' * X + X * op(A) = scale * C\nwhere op(A) = A or A^T, C is symmetric.\n\nParameters:\n  job (str): 'X' solution only, 'S' separation only, 'B' both\n  fact (str): 'F' Schur form provided, 'N' compute Schur\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A^T\n  a (ndarray): N-by-N matrix A (F-order)\n  c (ndarray): N-by-N symmetric matrix C (F-order)\n  u (ndarray, optional): N-by-N orthogonal matrix (if fact='F')\n\nReturns:\n  (a_out, u, x, scale, sep, ferr, wr, wi, info):\n  a_out: Schur form of A\n  u: Orthogonal Schur factor\n  x: Solution matrix\n  scale: Scale factor (0 < scale <= 1)\n  sep: Separation estimate (job='S' or 'B')\n  ferr: Forward error bound (job='B')\n  wr, wi: Real/imaginary eigenvalue parts (fact='N')\n  info: 0=success, -i=arg i invalid, 1..n=DGEES fail, n+1=singular\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03rd\n>>> n = 3\n>>> a = np.array([\n...     [-1.0,  0.5,  0.0],\n...     [ 0.0, -2.0,  0.3],\n...     [ 0.0,  0.0, -3.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [ 2.0,  0.5,  0.1],\n...     [ 0.5,  3.0,  0.2],\n...     [ 0.1,  0.2,  4.0]\n...     ], order='F', dtype=float)\n>>> a_out, u, x, scale, sep, ferr, wr, wi, info = sb03rd('X', 'N', 'N', a, c)\n>>> info\n0",
  "sb03sd": "Estimate conditioning and forward error for discrete-time Lyapunov.\n\nEstimates the conditioning and computes an error bound on the solution of:\n  op(A)' * X * op(A) - X = scale * C\nwhere op(A) = A or A^T, C is symmetric.\n\nParameters:\n  job (str): 'C' condition only, 'E' error only, 'B' both\n  fact (str): 'F' Schur form provided, 'N' compute Schur\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A^T\n  uplo (str): 'U' upper triangle of C, 'L' lower triangle\n  lyapun (str): 'O' original equations, 'R' reduced equations\n  n (int): Order of matrices\n  scale (float): Scale factor from Lyapunov solver (0 <= scale <= 1)\n  a (ndarray): N-by-N matrix A (F-order)\n  t (ndarray): N-by-N Schur form matrix T (F-order)\n  u (ndarray): N-by-N orthogonal Schur factor U (F-order)\n  c (ndarray): N-by-N symmetric matrix C (F-order)\n  x (ndarray): N-by-N symmetric solution matrix X (F-order)\n\nReturns:\n  (sepd, rcond, ferr, info):\n  sepd: Separation estimate sepd(op(A),op(A)')\n  rcond: Reciprocal condition number estimate\n  ferr: Forward error bound\n  info: 0=success, 1..n=DGEES fail, n+1=near-reciprocal eigenvalues\n\nExamples:\n\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([\n...     [0.5, 0.1, 0.05],\n...     [0.0, 0.6, 0.1],\n...     [0.0, 0.0, 0.7]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.5, 0.2],\n...     [0.5, 2.0, 0.5],\n...     [0.2, 0.5, 1.5]\n...     ], order='F', dtype=float)\n>>> t = a.copy()\n>>> u = np.eye(n, order='F', dtype=float)\n>>> from slicot import sb03sd\n>>> a_work = a.copy(order='F')\n>>> c_work = c.copy(order='F')\n>>> result = sb03md('D', 'X', 'N', 'N', n, a_work, c_work)\n>>> x = result[2]\n>>> scale = result[5]\n>>> info = result[-1]\n>>> result = sb03sd('B', 'F', 'N', 'U', 'O', n, scale,\n...     a, t, u, c, x)\n>>> sepd, rcond, ferr, info = result",
  "sb03sx": "Estimate forward error for discrete-time Lyapunov solution.\n\nEstimates forward error bound for solution X of op(A)'*X*op(A) - X = C.\n\nParameters:\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  uplo (str): 'U' for upper, 'L' for lower triangle of R\n  lyapun (str): 'O' for original, 'R' for reduced form\n  n (int): Order of matrices\n  xanorm (float): 1-norm of matrix A\n  t (ndarray): Schur form matrix T (n x n, F-order)\n  u (ndarray): Orthogonal transformation U (n x n, F-order)\n  r (ndarray): Cholesky factor of solution X (n x n, F-order)\n\nReturns:\n  (ferr, r, info): Forward error bound, modified R, exit code\n\nExamples:\n\n>>> from slicot import sb03sx\n>>> import numpy as np\n>>> n = 4\n>>> t = np.zeros((n, n), order='F', dtype=float)\n...     t[i, i] = 0.5 + 0.1 * i\n...     t[i, j] = np.random.randn() * 0.1\n>>> xanorm = 1.5\n>>> r = np.random.randn(n, n).astype(float, order='F')\n>>> r = (r + r.T) / 2\n>>> r = np.triu(r)\n>>> u = np.eye(n, order='F', dtype=float)\n>>> ferr, r_out, info = sb03sx('N', 'U', 'R', n, xanorm, t, u, r)\n>>> info\n0",
  "sb03sy": "Estimate separation and Theta norm for discrete-time Lyapunov.\n\nEstimates sepd(op(A),op(A)') and/or 1-norm of Theta operator.\n\nParameters:\n  job (str): 'S' for separation, 'T' for Theta, 'B' for both\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A'\n  lyapun (str): 'O' for original, 'R' for reduced form\n  n (int): Order of matrices\n  t (ndarray): Schur form matrix T (n x n, F-order)\n  u (ndarray): Orthogonal transformation U (n x n, F-order)\n  xa (ndarray): Matrix X*op(A) or U'*X*U*op(T) (n x n, F-order)\n\nReturns:\n  (sepd, thnorm, info): Separation, Theta norm, exit code\n\nExamples:\n\n>>> from slicot import sb03sy\n>>> import numpy as np\n>>> n = 4\n>>> t = np.zeros((n, n), order='F', dtype=float)\n...     t[i, i] = 0.5 + 0.1 * i\n...     t[i, j] = np.random.randn() * 0.1\n>>> u = np.eye(n, order='F', dtype=float)\n>>> xa = np.eye(n, order='F', dtype=float)\n>>> sepd, thnorm, info = sb03sy('S', 'N', 'R', n, t, u, xa)\n>>> info\n0",
  "sb03td": "Solve continuous-time Lyapunov equation with conditioning/error bounds.\n\nSolves: op(A)' * X + X * op(A) = scale * C\nwhere op(A) = A or A^T, C and X are N-by-N symmetric.\nOptionally estimates conditioning and computes error bound.\n\nParameters:\n  job (str): 'X' solution only, 'S' separation only, 'C' condition only,\n             'E' error only, 'A' all of the above\n  fact (str): 'F' Schur form provided, 'N' compute Schur\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A^T\n  uplo (str): 'U' upper triangle of C, 'L' lower triangle\n  lyapun (str): 'O' original equations, 'R' reduced (Schur form)\n  a (ndarray): N-by-N matrix A (if fact='N' or lyapun='O' and job!='X')\n  c (ndarray): N-by-N symmetric matrix C (if job!='S')\n  t (ndarray, optional): N-by-N Schur form T (if fact='F')\n  u (ndarray, optional): N-by-N orthogonal U (if fact='F' and lyapun='O')\n  x (ndarray, optional): N-by-N solution X (if job='C' or 'E')\n  scale (float, optional): Scale factor (if job='C' or 'E')\n\nReturns:\n  (x, t, u, wr, wi, scale, sep, rcond, ferr, info):\n  x: Solution matrix (if job='X' or 'A')\n  t: Schur form matrix T\n  u: Orthogonal Schur factor U\n  wr, wi: Eigenvalue real/imaginary parts (if fact='N')\n  scale: Scale factor to prevent overflow\n  sep: Separation estimate sep(op(A),-op(A)')\n  rcond: Reciprocal condition number (if job='C' or 'A')\n  ferr: Forward error bound (if job='E' or 'A')\n  info: 0=success, -i=arg i invalid, 1..n=DGEES fail, n+1=close eigenvalues\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb03td\n>>> n = 3\n>>> a = np.array([\n...     [3.0, 1.0, 1.0],\n...     [1.0, 3.0, 0.0],\n...     [0.0, 0.0, 3.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [25.0, 24.0, 15.0],\n...     [24.0, 32.0,  8.0],\n...     [15.0,  8.0, 40.0]\n...     ], dtype=float, order='F')\n>>> x, t, u, wr, wi, scale, sep, rcond, ferr, info = sb03td(\n...     'A', 'N', 'N', 'U', 'O', a, c\n...     )\n>>> info\n0",
  "sb03ud": "Solve discrete-time Lyapunov equation with conditioning/error bounds.\n\nSolves: op(A)' * X * op(A) - X = scale * C\nwhere op(A) = A or A^T, C and X are N-by-N symmetric.\nOptionally estimates conditioning and computes error bound.\n\nParameters:\n  job (str): 'X' solution only, 'S' separation only, 'C' condition only,\n             'E' error only, 'A' all of the above\n  fact (str): 'F' Schur form provided, 'N' compute Schur\n  trana (str): 'N' for op(A)=A, 'T'/'C' for op(A)=A^T\n  uplo (str): 'U' upper triangle of C, 'L' lower triangle\n  lyapun (str): 'O' original equations, 'R' reduced (Schur form)\n  a (ndarray): N-by-N matrix A (if fact='N' or lyapun='O' and job!='X')\n  c (ndarray): N-by-N symmetric matrix C (if job!='S')\n  t (ndarray, optional): N-by-N Schur form T (if fact='F')\n  u (ndarray, optional): N-by-N orthogonal U (if fact='F' and lyapun='O')\n  x (ndarray, optional): N-by-N solution X (if job='C' or 'E')\n  scale (float, optional): Scale factor (if job='C' or 'E')\n\nReturns:\n  (x, scale, sepd, rcond, ferr, wr, wi, info):\n  x: Solution matrix (if job='X' or 'A')\n  scale: Scale factor to prevent overflow\n  sepd: Separation estimate (if job='S', 'C', or 'A')\n  rcond: Reciprocal condition number (if job='C' or 'A')\n  ferr: Forward error bound (if job='E' or 'A')\n  wr, wi: Eigenvalue real/imaginary parts (if fact='N')\n  info: 0=success, -i=arg i invalid, 1..n=DGEES fail, n+1=near-reciprocal\n\nExamples:\n\n>>> from slicot import sb03ud\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([\n...     [3.0, 1.0, 1.0],\n...     [1.0, 3.0, 0.0],\n...     [0.0, 0.0, 3.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [25.0, 24.0, 15.0],\n...     [24.0, 32.0,  8.0],\n...     [15.0,  8.0, 40.0]\n...     ], dtype=float, order='F')\n>>> x, scale, sepd, rcond, ferr, wr, wi, info = sb03ud(\n...     job='A', fact='N', trana='N', uplo='U', lyapun='O',\n...     a=a, c=c\n...     )\n>>> info\n0",
  "sb04md": "Solve continuous-time Sylvester equation AX + XB = C (Hessenberg-Schur).\n\nSolves the continuous-time Sylvester equation AX + XB = C using the\nHessenberg-Schur method. A is reduced to upper Hessenberg form,\nB is reduced to real Schur form.\n\nParameters:\n  a (ndarray): N-by-N coefficient matrix A (F-order)\n  b (ndarray): M-by-M coefficient matrix B (F-order)\n  c (ndarray): N-by-M coefficient matrix C (F-order)\n\nReturns:\n  (x, z, info): Solution matrix X, orthogonal matrix Z, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04md\n>>> n = 3\n>>> m = 2\n>>> a = np.array([\n...     [2.0, 1.0, 3.0],\n...     [0.0, 2.0, 1.0],\n...     [6.0, 1.0, 2.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [2.0, 1.0],\n...     [1.0, 6.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [2.0, 1.0],\n...     [1.0, 4.0],\n...     [0.0, 5.0]\n...     ], dtype=float, order='F')\n>>> x, z, info = sb04md(a, b, c)\n>>> info\n0",
  "sb04mr": "Solve linear system with compact storage (second subdiagonal zeros).\n\nSolves a linear algebraic system of order M whose coefficient matrix\nhas zeros below the second subdiagonal. Matrix stored compactly, row-wise.\n\nParameters:\n  m (int): Order of system (m >= 0)\n  d (ndarray): Compact array (m*(m+1)/2 + 3*m elements, F-order)\n\nReturns:\n  (d, ipr, info): Updated d, solution indices, exit code (0=success, 1=singular)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04mr\n>>> m = 2\n>>> d_len = m * (m + 1) // 2 + 3 * m  # 3 + 6 = 9\n>>> d = np.zeros(d_len, dtype=float, order='F')\n>>> d[0] = 2.0  # a11\n>>> d[1] = 1.0  # a12\n>>> d[2] = 1.0  # a21\n>>> d[3] = 3.0  # a22\n>>> d[7] = 5.0   # b1\n>>> d[8] = 10.0  # b2\n>>> d_out, ipr, info = sb04mr(m, d.copy())\n>>> x = np.zeros(m)\n...     x[i] = d_out[ipr[i] - 1]  # Convert 1-based to 0-based\n>>> info\n0",
  "sb04mw": "Solve linear system with compact storage (upper Hessenberg).\n\nSolves a linear algebraic system of order M whose coefficient matrix\nis in upper Hessenberg form, stored compactly, row-wise.\n\nParameters:\n  m (int): Order of system (m >= 0)\n  d (ndarray): Compact array (m*(m+1)/2 + 2*m elements, F-order)\n\nReturns:\n  (d, ipr, info): Updated d, solution indices, exit code (0=success, 1=singular)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04mw\n>>> m = 2\n>>> d_len = m * (m + 1) // 2 + 2 * m  # 3 + 4 = 7\n>>> d = np.zeros(d_len, dtype=float, order='F')\n>>> d[0] = 2.0\n>>> d[1] = 1.0\n>>> d[2] = 1.0\n>>> d[3] = 3.0\n>>> d[5] = 5.0   # b1 = 2*1 + 1*3 = 5\n>>> d[6] = 10.0  # b2 = 1*1 + 3*3 = 10\n>>> d_out, ipr, info = sb04mw(m, d.copy())\n>>> x = np.zeros(m)\n...     x[i] = d_out[ipr[i] - 1]\n>>> info\n0",
  "sb04nd": "Solve continuous-time Sylvester equation AX + XB = C.\n\nSolves the continuous-time Sylvester equation AX + XB = C, where at least\none of the matrices A or B is in Schur form and the other is in Hessenberg\nor Schur form (both either upper or lower).\n\nUses the Hessenberg-Schur back substitution method proposed by\nGolub, Nash and Van Loan.\n\nParameters:\n  abschu (str): 'A' = A Schur, B Hessenberg; 'B' = B Schur, A Hessenberg;\n                'S' = Both in Schur form\n  ula (str): 'U' for upper, 'L' for lower (A matrix)\n  ulb (str): 'U' for upper, 'L' for lower (B matrix)\n  a (ndarray): N-by-N coefficient matrix A (F-order)\n  b (ndarray): M-by-M coefficient matrix B (F-order)\n  c (ndarray): N-by-M coefficient matrix C (F-order)\n  tol (float, optional): Tolerance for singularity test (default 0 = EPS)\n\nReturns:\n  (x, info): Solution matrix X and exit code (0=success, 1=singular)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04nd\n>>> n = 5\n>>> m = 3\n>>> a = np.array([\n...     [17.0, 24.0,  1.0,  8.0, 15.0],\n...     [23.0,  5.0,  7.0, 14.0, 16.0],\n...     [ 0.0,  6.0, 13.0, 20.0, 22.0],\n...     [ 0.0,  0.0, 19.0, 21.0,  3.0],\n...     [ 0.0,  0.0,  0.0,  2.0,  9.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [8.0, 1.0, 6.0],\n...     [0.0, 5.0, 7.0],\n...     [0.0, 9.0, 2.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [ 62.0, -12.0, 26.0],\n...     [ 59.0, -10.0, 31.0],\n...     [ 70.0,  -6.0,  9.0],\n...     [ 35.0,  31.0, -7.0],\n...     [ 36.0, -15.0,  7.0]\n...     ], dtype=float, order='F')\n>>> x, info = sb04nd('B', 'U', 'U', a, b, c, tol=0.0)\n>>> info\n0",
  "sb04nv": "Construct right-hand sides for Sylvester solver (2 RHS case).\n\nConstructs right-hand sides D for a system of equations in\nHessenberg form solved via sb04nx (case with 2 right-hand sides).\n\nParameters:\n  abschr (str): 'A' = AB contains A, 'B' = AB contains B\n  ul (str): 'U' for upper Hessenberg, 'L' for lower Hessenberg\n  indx (int): Position of first column/row of C to use (1-based)\n  c (ndarray): N-by-M coefficient matrix C (F-order)\n  ab (ndarray): Matrix A or B depending on abschr (F-order)\n\nReturns:\n  d (ndarray): Right-hand side vector (2*N or 2*M elements)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04nv\n>>> n = 3\n>>> m = 4\n>>> c = np.random.randn(n, m).astype(float, order='F')\n>>> ab = np.triu(np.random.randn(m, m).astype(float, order='F'), k=-1)\n>>> indx = 2\n>>> d = sb04nv('B', 'U', indx, c, ab)",
  "sb04nw": "Construct right-hand side for Sylvester solver (1 RHS case).\n\nConstructs right-hand side D for a system of equations in\nHessenberg form solved via sb04ny (case with 1 right-hand side).\n\nParameters:\n  abschr (str): 'A' = AB contains A, 'B' = AB contains B\n  ul (str): 'U' for upper Hessenberg, 'L' for lower Hessenberg\n  indx (int): Position of column/row of C to use (1-based)\n  c (ndarray): N-by-M coefficient matrix C (F-order)\n  ab (ndarray): Matrix A or B depending on abschr (F-order)\n\nReturns:\n  d (ndarray): Right-hand side vector (N or M elements)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04nw\n>>> n = 3\n>>> m = 4\n>>> c = np.random.randn(n, m).astype(float, order='F')\n>>> ab = np.triu(np.random.randn(m, m).astype(float, order='F'), k=-1)\n>>> indx = 3\n>>> d = sb04nw('B', 'U', indx, c, ab)",
  "sb04nx": "Solve Hessenberg system with two offdiagonals and two RHS.\n\nSolves a system of equations in Hessenberg form with two consecutive\noffdiagonals and two right-hand sides.\n\nParameters:\n  rc (str): 'R' for row transforms, 'C' for column transforms\n  ul (str): 'U' for upper Hessenberg, 'L' for lower Hessenberg\n  a (ndarray): M-by-M Hessenberg matrix A (F-order)\n  d (ndarray): Right-hand sides (2*M elements, F-order)\n  lambd1, lambd2, lambd3, lambd4 (float): 2x2 block for diagonal\n  tol (float): Tolerance for singularity test\n\nReturns:\n  (d, info): Solution vector and exit code (0=success, 1=singular)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04nx\n>>> m = 3\n>>> a = np.triu(np.random.randn(m, m).astype(float, order='F'), k=-1)\n...     a[i + 1, i] = np.random.randn() * 0.5\n...     a[i, i] = 2.0 + i\n>>> lambd1 = 1.0\n>>> lambd2 = 0.1\n>>> lambd3 = -0.1\n>>> lambd4 = 1.5\n>>> d = np.random.randn(2 * m).astype(float, order='F')\n>>> tol = 1e-10\n>>> d_result, info = sb04nx('R', 'U', a, d, lambd1, lambd2, lambd3, lambd4, tol)\n>>> h = np.zeros((2 * m, 2 * m), dtype=float, order='F')\n...     j2 = 2 * j\n...     ml = min(j + 2, m)\n...     h[2 * i, j2] = a[i, j]\n...     h[2 * i + 1, j2 + 1] = a[i, j]\n...     h[j2, j2] += lambd1\n...     h[j2 + 1, j2] = lambd3\n...     h[j2, j2 + 1] = lambd2\n...     h[j2 + 1, j2 + 1] += lambd4\n>>> info\n0",
  "sb04ny": "Solve Hessenberg system with one offdiagonal and one RHS.\n\nSolves a system of equations in Hessenberg form with one offdiagonal\nand one right-hand side.\n\nParameters:\n  rc (str): 'R' for row transforms, 'C' for column transforms\n  ul (str): 'U' for upper Hessenberg, 'L' for lower Hessenberg\n  a (ndarray): M-by-M Hessenberg matrix A (F-order)\n  d (ndarray): Right-hand side (M elements, F-order)\n  lambda_ (float): Value to add to diagonal elements\n  tol (float): Tolerance for singularity test\n\nReturns:\n  (d, info): Solution vector and exit code (0=success, 1=singular)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04ny\n>>> m = 4\n>>> a = np.triu(np.random.randn(m, m).astype(float, order='F'), k=-1)\n...     a[i + 1, i] = np.random.randn() * 0.5\n...     a[i, i] = 2.0 + i\n>>> lambda_val = 1.0\n>>> d = np.random.randn(m).astype(float, order='F')\n>>> tol = 1e-10\n>>> d_result, info = sb04ny('R', 'U', a, d, lambda_val, tol)\n>>> h = a.copy()\n...     h[i, i] += lambda_val\n>>> info\n0",
  "sb04od": "Solve generalized Sylvester equations with separation estimation.\n\nSolves for R and L one of the generalized Sylvester equations:\n  A * R - L * B = scale * C, D * R - L * E = scale * F  (equation 1)\nor\n  A' * R + D' * L = scale * C, R * B' + L * E' = scale * (-F)  (equation 2)\n\nOptionally reduces (A,D) and/or (B,E) to generalized Schur form and\ncomputes a Dif estimate measuring separation of spectra.\n\nParameters:\n  reduce (str): 'R' reduce both, 'A' reduce (A,D), 'B' reduce (B,E), 'N' none\n  trans (str): 'N' solve equation (1), 'T' solve equation (2)\n  jobd (str): '1' one-norm Dif, '2' Frobenius Dif, 'D'/'F' solve+Dif, 'N' no Dif\n  a (ndarray): M-by-M matrix A (F-order)\n  b (ndarray): N-by-N matrix B (F-order)\n  c (ndarray): M-by-N matrix C (F-order)\n  d (ndarray): M-by-M matrix D (F-order)\n  e (ndarray): N-by-N matrix E (F-order)\n  f (ndarray): M-by-N matrix F (F-order)\n\nReturns:\n  (a, b, c, d, e, f, scale, dif, p, q, u, v, info):\n    Modified matrices (Schur form), solution R in c, L in f,\n    scale factor, Dif estimate, transformation matrices, exit code.\n    P,Q for (A,D), U,V for (B,E); None if not computed.\n    info: 0=success, 1=Schur fail, 2=not quasi-triangular, 3=singular\n\nExamples:\n\n>>> from slicot import sb04od\n>>> import numpy as np\n>>> m, n = 3, 2\n>>> a = np.array([\n...     [1.6, -3.1, 1.9],\n...     [-3.8, 4.2, 2.4],\n...     [0.5, 2.2, -4.5]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.1, 0.1],\n...     [-1.3, -3.1]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [-2.0, 28.9],\n...     [-5.7, -11.8],\n...     [12.9, -31.7]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [2.5, 0.1, 1.7],\n...     [-2.5, 0.0, 0.9],\n...     [0.1, 5.1, -7.3]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [6.0, 2.4],\n...     [-3.6, 2.5]\n...     ], order='F', dtype=float)\n>>> f = np.array([\n...     [0.5, 23.8],\n...     [-11.0, -10.4],\n...     [39.5, -74.8]\n...     ], order='F', dtype=float)\n>>> (a_out, b_out, c_out, d_out, e_out, f_out,\n...     scale, dif, p, q, u, v, info) = sb04od(\n...     'R', 'N', 'D', a, b, c, d, e, f)",
  "sb04ow": "Solve periodic Sylvester equation with matrices in periodic Schur form.\n\nSolves the periodic Sylvester equation:\n  A * R - L * B = scale * C\n  D * L - R * E = scale * F\n\nwhere R and L are unknown M-by-N matrices, (A, D), (B, E) and (C, F) are\ngiven matrix pairs. (A, D) and (B, E) must be in periodic Schur form,\ni.e., A, B are upper quasi triangular and D, E are upper triangular.\nThe solution (R, L) overwrites (C, F).\n\nParameters:\n  m (int): Order of A and D, row dimension of C, F, R, L. m > 0.\n  n (int): Order of B and E, column dimension of C, F, R, L. n > 0.\n  a (ndarray): M-by-M upper quasi triangular matrix A (F-order)\n  b (ndarray): N-by-N upper quasi triangular matrix B (F-order)\n  c (ndarray): M-by-N matrix C, contains R on exit (F-order)\n  d (ndarray): M-by-M upper triangular matrix D (F-order)\n  e (ndarray): N-by-N upper triangular matrix E (F-order)\n  f (ndarray): M-by-N matrix F, contains L on exit (F-order)\n\nReturns:\n  (r, l, scale, info):\n    r: Solution matrix R (modified c)\n    l: Solution matrix L (modified f)\n    scale: Scaling factor (0 <= scale <= 1)\n    info: 0=success, >0=common eigenvalues in A*D and B*E\n\nExamples:\n\n>>> from slicot import sb04ow\n>>> import numpy as np\n>>> m, n = 1, 1\n>>> a = np.array([[2.0]], order='F', dtype=float)\n>>> b = np.array([[3.0]], order='F', dtype=float)\n>>> c = np.array([[1.0]], order='F', dtype=float)\n>>> d = np.array([[4.0]], order='F', dtype=float)\n>>> e = np.array([[5.0]], order='F', dtype=float)\n>>> f = np.array([[2.0]], order='F', dtype=float)\n>>> c_in = c.copy()\n>>> f_in = f.copy()\n>>> r, l, scale, info = sb04ow(m, n, a, b, c, d, e, f)\n>>> res1, res2 = verify_periodic_sylvester(a, b, c_in, d, e, f_in, r, l, scale)\n>>> info\n0",
  "sb04pd": "Solve continuous-time or discrete-time Sylvester equations.\n\nSolves for X either the continuous-time Sylvester equation:\n  op(A)*X + ISGN*X*op(B) = scale*C\n\nor the discrete-time Sylvester equation:\n  op(A)*X*op(B) + ISGN*X = scale*C\n\nwhere op(M) = M or M**T, and ISGN = 1 or -1. If A and/or B are not\nquasi-triangular, they are reduced to Schur canonical form.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  facta (str): 'F' Schur supplied, 'N' compute Schur, 'S' already Schur\n  factb (str): 'F' Schur supplied, 'N' compute Schur, 'S' already Schur\n  trana (str): 'N' for A, 'T' or 'C' for A**T\n  tranb (str): 'N' for B, 'T' or 'C' for B**T\n  isgn (int): Sign in equation (must be 1 or -1)\n  a (ndarray): M-by-M matrix A (F-order)\n  b (ndarray): N-by-N matrix B (F-order)\n  c (ndarray): M-by-N right-hand side matrix C (F-order)\n\nReturns:\n  (x, a, u, b, v, scale, info):\n    x: M-by-N solution matrix\n    a: Schur form of A (if facta='N')\n    u: Schur vectors of A (None if facta='S')\n    b: Schur form of B (if factb='N')\n    v: Schur vectors of B (None if factb='S')\n    scale: Scale factor (0 < scale <= 1)\n    info: 0=success, <0=arg error, >0=algorithm error\n\nExamples:\n\n>>> from slicot import sb04pd\n>>> import numpy as np\n>>> m = 3\n>>> n = 2\n>>> a = np.array([\n...     [2.0, 1.0, 3.0],\n...     [0.0, 2.0, 1.0],\n...     [6.0, 1.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [2.0, 1.0],\n...     [1.0, 6.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [2.0, 1.0],\n...     [1.0, 4.0],\n...     [0.0, 5.0]\n...     ], order='F', dtype=float)\n>>> x, a_out, u, b_out, v, scale, info = sb04pd(\n...     'D', 'N', 'N', 'N', 'N', 1, a, b, c\n...     )\n>>> info\n0",
  "sb04py": "Solve discrete-time Sylvester equation with Schur matrices.\n\nSolves for X the discrete-time Sylvester equation:\n  op(A)*X*op(B) + ISGN*X = scale*C\n\nwhere op(A) = A or A**T, A and B are both upper quasi-triangular\n(Schur canonical form), and ISGN = 1 or -1. Solution X overwrites C.\n\nParameters:\n  trana (str): 'N' for A, 'T' or 'C' for A**T\n  tranb (str): 'N' for B, 'T' or 'C' for B**T\n  isgn (int): Sign of the equation (must be 1 or -1)\n  a (ndarray): M-by-M upper quasi-triangular matrix A (F-order)\n  b (ndarray): N-by-N upper quasi-triangular matrix B (F-order)\n  c (ndarray): M-by-N right-hand side matrix C (F-order)\n\nReturns:\n  (x, scale, info): Solution X, scale factor, exit code\n  scale: Scale factor (0 < scale <= 1) to prevent overflow\n  info: 0=success, 1=A and -ISGN*B have almost reciprocal eigenvalues\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04py\n>>> a = np.array([[2.0, 0.0], [0.0, 3.0]], dtype=float, order='F')\n>>> b = np.array([[1.0, 0.0], [0.0, 2.0]], dtype=float, order='F')\n>>> c = np.array([[6.0, 10.0], [8.0, 14.0]], dtype=float, order='F')\n>>> x, scale, info = sb04py('N', 'N', 1, a, b, c)\n>>> info\n0",
  "sb04qd": "Solve discrete-time Sylvester equation X + AXB = C (Hessenberg-Schur).\n\nSolves the discrete-time Sylvester equation X + AXB = C using the\nHessenberg-Schur method. A is reduced to upper Hessenberg form,\nB is reduced to real Schur form.\n\nParameters:\n  a (ndarray): N-by-N coefficient matrix A (F-order)\n  b (ndarray): M-by-M coefficient matrix B (F-order)\n  c (ndarray): N-by-M coefficient matrix C (F-order)\n\nReturns:\n  (x, z, info): Solution matrix X, orthogonal matrix Z, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04qd\n>>> n = 3\n>>> m = 3\n>>> a = np.array([\n...     [1.0, 2.0, 3.0],\n...     [6.0, 7.0, 8.0],\n...     [9.0, 2.0, 3.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [7.0, 2.0, 3.0],\n...     [2.0, 1.0, 2.0],\n...     [3.0, 4.0, 1.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [271.0, 135.0, 147.0],\n...     [923.0, 494.0, 482.0],\n...     [578.0, 383.0, 287.0]\n...     ], dtype=float, order='F')\n>>> x, z, info = sb04qd(a, b, c)\n>>> info\n0",
  "sb04qr": "Solve linear system with compact storage (third subdiagonal pattern).\n\nSolves a linear algebraic system of order M whose coefficient matrix\nhas zeros below third subdiagonal with special pattern. Matrix stored compactly.\n\nParameters:\n  m (int): Order of system (m >= 0, m even)\n  d (ndarray): Compact array (m*m/2 + 4*m elements, F-order)\n\nReturns:\n  (d, ipr, info): Updated d, solution indices, exit code (0=success, 1=singular)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04qr\n>>> m = 4\n>>> d_len = m * m // 2 + 4 * m  # 8 + 16 = 24\n>>> d = np.zeros(d_len, dtype=float, order='F')\n>>> d[0] = 5.0   # a11\n>>> d[1] = 1.0   # a12\n>>> d[2] = 0.5   # a13\n>>> d[3] = 0.2   # a14\n>>> d[4] = 1.0   # a21\n>>> d[5] = 4.0   # a22\n>>> d[6] = 1.0   # a23\n>>> d[7] = 0.3   # a24\n>>> d[8] = 0.8   # a31\n>>> d[9] = 0.7   # a32\n>>> d[10] = 3.5  # a33\n>>> d[11] = 0.5  # a34\n>>> d[12] = 0.6  # a42\n>>> d[13] = 0.5  # a43\n>>> d[14] = 3.0  # a44\n>>> rhs_start = m * m // 2 + 3 * m\n>>> d[rhs_start] = 7.7\n>>> d[rhs_start + 1] = 6.3\n>>> d[rhs_start + 2] = 5.0\n>>> d[rhs_start + 3] = 3.6\n>>> d_out, ipr, info = sb04qr(m, d.copy())\n>>> x = np.zeros(m)\n...     x[i] = d_out[ipr[i] - 1]\n>>> info\n0",
  "sb04rd": "Solve discrete-time Sylvester equation (Hessenberg-Schur method).\n\nSolves X + A*X*B = C where at least one of A or B is in Schur form\nand the other in Hessenberg or Schur form.\n\nParameters:\n  abschu (str): 'A' = A in Schur, B in Hessenberg\n                'B' = B in Schur, A in Hessenberg\n                'S' = both in Schur form\n  ula (str): 'U' = A is upper, 'L' = A is lower\n  ulb (str): 'U' = B is upper, 'L' = B is lower\n  a (ndarray): N-by-N coefficient matrix A (F-order)\n  b (ndarray): M-by-M coefficient matrix B (F-order)\n  c (ndarray): N-by-M RHS matrix C (F-order)\n  tol (float, optional): Tolerance for singularity test (default: machine eps)\n\nReturns:\n  (x, info): Solution matrix X and exit code\n    info=0: success, info=1: nearly singular matrix encountered\n\nExamples:\n\n>>> from slicot import sb04rd\n>>> import numpy as np\n>>> n = 5\n>>> m = 5\n>>> a = np.array([\n...     [1.0, 2.0, 3.0, 4.0, 5.0],\n...     [6.0, 7.0, 8.0, 9.0, 1.0],\n...     [0.0, 2.0, 3.0, 4.0, 5.0],\n...     [0.0, 0.0, 6.0, 7.0, 8.0],\n...     [0.0, 0.0, 0.0, 9.0, 1.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [1.0, 2.0, 3.0, 4.0, 5.0],\n...     [0.0, 1.0, 2.0, 3.0, 4.0],\n...     [0.0, 0.0, 1.0, 2.0, 3.0],\n...     [0.0, 0.0, 0.0, 1.0, -5.0],\n...     [0.0, 0.0, 0.0, 4.0, 1.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [2.0, 4.0, 10.0, 40.0, 7.0],\n...     [6.0, 20.0, 40.0, 74.0, 38.0],\n...     [0.0, 2.0, 8.0, 36.0, 2.0],\n...     [0.0, 0.0, 6.0, 52.0, -9.0],\n...     [0.0, 0.0, 0.0, 13.0, -43.0]\n...     ], dtype=float, order='F')\n>>> x, info = sb04rd('B', 'U', 'U', a, b, c)\n>>> info\n0",
  "sb04rv": "Construct RHS for quasi-Hessenberg Sylvester solver (2 RHS case).\n\nConstructs right-hand sides D for a system of equations in quasi-Hessenberg\nform solved via SB04RX (case with 2 right-hand sides).\n\nFor the Sylvester equation X + AXB = C:\n  - If abschr='B': ab contains B (m-by-m), ba contains A (n-by-n), D has 2*n elements\n  - If abschr='A': ab contains A (n-by-n), ba contains B (m-by-m), D has 2*m elements\n\nParameters:\n  abschr (str): 'A' if ab contains A, 'B' if ab contains B\n  ul (str): 'U' if ab is upper Hessenberg, 'L' if lower Hessenberg\n  indx (int): Position of first column/row of C to use (1-based)\n  c (ndarray): N-by-M coefficient/solution matrix (F-order)\n  ab (ndarray): Hessenberg matrix A or B (F-order)\n  ba (ndarray): Matrix B or A (the one not in ab) (F-order)\n\nReturns:\n  d (ndarray): Right-hand side vector (2*n or 2*m elements, interleaved)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04rv\n>>> n = 3\n>>> m = 4\n>>> c = np.random.randn(n, m).astype(float, order='F')\n>>> ab = np.triu(np.random.randn(m, m).astype(float, order='F'), k=-1)  # M-by-M upper Hessenberg\n>>> ba = np.random.randn(n, n).astype(float, order='F')  # N-by-N\n>>> indx = 2\n>>> d = sb04rv('B', 'U', indx, c, ab, ba)\n...     dwork1 = c[:, :indx - 1] @ ab[:indx - 1, indx - 1]\n...     dwork2 = c[:, :indx - 1] @ ab[:indx - 1, indx]",
  "sb04rw": "Construct RHS for Hessenberg Sylvester solver (1 RHS case).\n\nConstructs right-hand side D for a system of equations in Hessenberg\nform solved via SB04RY (case with 1 right-hand side).\n\nFor the Sylvester equation X + AXB = C:\n  - If abschr='B': ab contains B (m-by-m), ba contains A (n-by-n), D has n elements\n  - If abschr='A': ab contains A (n-by-n), ba contains B (m-by-m), D has m elements\n\nParameters:\n  abschr (str): 'A' if ab contains A, 'B' if ab contains B\n  ul (str): 'U' if ab is upper Hessenberg, 'L' if lower Hessenberg\n  indx (int): Position of column/row of C to use (1-based)\n  c (ndarray): N-by-M coefficient/solution matrix (F-order)\n  ab (ndarray): Hessenberg matrix A or B (F-order)\n  ba (ndarray): Matrix B or A (the one not in ab) (F-order)\n\nReturns:\n  d (ndarray): Right-hand side vector (n or m elements)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04rw\n>>> n = 3\n>>> m = 4\n>>> c = np.random.randn(n, m).astype(float, order='F')\n>>> ab = np.triu(np.random.randn(m, m).astype(float, order='F'), k=-1)  # M-by-M upper Hessenberg\n>>> ba = np.random.randn(n, n).astype(float, order='F')  # N-by-N\n>>> indx = 3\n>>> d = sb04rw('B', 'U', indx, c, ab, ba)\n...     dwork = c[:, :indx - 1] @ ab[:indx - 1, indx - 1]",
  "sb04rx": "Solve quasi-Hessenberg system with two right-hand sides.\n\nSolves a system of equations in quasi-Hessenberg form (Hessenberg form\nplus two consecutive offdiagonals) with two right-hand sides via QR\ndecomposition with Givens rotations.\n\nThe system matrix H is formed as I (x) A * Lambda + Lambda (x) A\nwhere Lambda is a 2x2 block and (x) denotes Kronecker product.\n\nParameters:\n  rc (str): 'R' for row transformations, 'C' for column transformations\n  ul (str): 'U' if A is upper Hessenberg, 'L' if lower Hessenberg\n  a (ndarray): M-by-M Hessenberg matrix A (F-order)\n  lambd1 (float): Element (1,1) of 2x2 block\n  lambd2 (float): Element (1,2) of 2x2 block\n  lambd3 (float): Element (2,1) of 2x2 block\n  lambd4 (float): Element (2,2) of 2x2 block\n  d (ndarray): 2*M RHS vector, stored row-wise (F-order)\n  tol (float): Tolerance for near-singularity test\n\nReturns:\n  (d, info): Solution vector (2*M elements) and exit code\n    info=0: success, info=1: system is (numerically) singular\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04rx\n>>> m = 4\n>>> a = np.triu(np.random.randn(m, m).astype(float, order='F'), k=-1)  # Upper Hessenberg\n>>> lambd1 = 0.5\n>>> lambd2 = 0.2\n>>> lambd3 = -0.1\n>>> lambd4 = 0.8\n>>> d_init = np.random.randn(2 * m).astype(float, order='F')\n>>> d = d_init.copy()\n>>> tol = 1e-12\n>>> d_out, info = sb04rx('R', 'U', a, lambd1, lambd2, lambd3, lambd4, d, tol)\n>>> H = build_quasi_hessenberg_system(a, lambd1, lambd2, lambd3, lambd4, 'U')\n>>> d_reconstructed = H @ d_out\n>>> info\n0",
  "sb04ry": "Solve Hessenberg system with one right-hand side.\n\nSolves a system of equations (I + lambda*A)*x = d in Hessenberg form\nwith one right-hand side via QR decomposition with Givens rotations.\n\nParameters:\n  rc (str): 'R' for row transformations, 'C' for column transformations\n  ul (str): 'U' if A is upper Hessenberg, 'L' if lower Hessenberg\n  a (ndarray): M-by-M Hessenberg matrix A (F-order)\n  lambda (float): Scalar multiplier for A\n  d (ndarray): M-element RHS vector (F-order)\n  tol (float): Tolerance for near-singularity test\n\nReturns:\n  (d, info): Solution vector (M elements) and exit code\n    info=0: success, info=1: system is (numerically) singular\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb04ry\n>>> m = 4\n>>> a = np.triu(np.random.randn(m, m).astype(float, order='F'), k=-1)  # Upper Hessenberg\n>>> lambd = 0.5\n>>> d_init = np.random.randn(m).astype(float, order='F')\n>>> d = d_init.copy()\n>>> tol = 1e-12\n>>> d_out, info = sb04ry('R', 'U', a, lambd, d, tol)\n>>> H = build_hessenberg_system(a, lambd, 'U')\n>>> d_reconstructed = H @ d_out\n>>> info\n0",
  "sb06nd": "Minimum norm feedback matrix for deadbeat control.\n\nConstructs the minimum norm feedback matrix F to perform 'deadbeat control'\non a (A,B)-pair reduced to staircase form by AB01OD such that R = A + BFU'\nis nilpotent.\n\nParameters:\n  n (int): State dimension, order of matrix A. n >= 0.\n  m (int): Input dimension. m >= 0.\n  kmax (int): Number of stairs in staircase form from AB01OD. 0 <= kmax <= n.\n  a (ndarray): N-by-N state matrix in staircase form (F-order).\n  b (ndarray): N-by-M input matrix in triangular form (F-order).\n  kstair (ndarray): KMAX-element array of stair dimensions from AB01OD.\n  u (ndarray): N-by-N transformation matrix or identity (F-order).\n\nReturns:\n  (a, b, u, f, info): Modified A (U'AU + U'BF), modified B (U'B),\n    modified U, deadbeat feedback matrix F, and exit code.\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb06nd\n>>> n = 5\n>>> m = 2\n>>> tol = 0.0\n>>> a_data = np.array([\n...     -17.0, 23.0, 34.0, 10.0, 11.0,\n...     24.0, -35.0, 26.0, 12.0, 18.0,\n...     41.0, 27.0, -13.0, 19.0, 25.0,\n...     68.0, 14.0, 20.0, -21.0, 52.0,\n...     15.0, 16.0, 22.0, 63.0, -29.0\n...     ], dtype=float)\n>>> a = a_data.reshape((n, n), order='F')\n>>> b_data = np.array([\n...     -31.0, 14.0,\n...     74.0, -69.0,\n...     -59.0, 16.0,\n...     16.0, -25.0,\n...     -25.0, 36.0\n...     ], dtype=float)\n>>> b = b_data.reshape((n, m), order='C')\n>>> b = np.asfortranarray(b)\n>>> result = ab01od('A', 'N', 'N', a, b, tol)\n>>> a_stair, b_stair, u_dummy, v_dummy, ncont, kmax, kstair, info_ab = result\n>>> u = np.eye(n, order='F', dtype=float)\n>>> a_out, b_out, u_out, f, info = sb06nd(n, m, kmax, a_stair, b_stair, kstair[:kmax], u)\n>>> eigvals = np.linalg.eigvals(a_out)\n...     err_msg=\"Closed-loop matrix is not nilpotent\")\n>>> info\n0",
  "sb08cd": "Left coprime factorization with inner denominator.\n\nComputes a left coprime factorization G = R^{-1}*Q with co-inner denominator R\nof a given state-space representation (A,B,C,D). The factorization satisfies\nR(s)*R'(-s) = I (continuous) or R(z)*R'(1/z) = I (discrete).\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  a (ndarray): N-by-N state matrix (F-order)\n  b (ndarray): N-by-max(M,P) input matrix (F-order)\n  c (ndarray): max(M,P)-by-N output matrix (F-order)\n  d (ndarray): max(M,P)-by-max(M,P) feedthrough matrix (F-order)\n  tol (float, optional): Tolerance for observability test (default: auto)\n\nReturns:\n  (nq, nr, br, dr, iwarn, info): Order of Q/R, order of minimal R,\n    output injection matrix Z'*H (N-by-P), lower triangular V (P-by-P),\n    warning count, exit code\n\nExamples:\n\n>>> from slicot import sb08cd\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> tol = 1e-10\n>>> a = np.array([\n...     [-0.04165,   0.0,    4.92,    0.492,   0.0,      0.0,    0.0],\n...     [-5.21,    -12.5,    0.0,     0.0,     0.0,      0.0,    0.0],\n...     [ 0.0,       3.33,  -3.33,    0.0,     0.0,      0.0,    0.0],\n...     [ 0.545,     0.0,    0.0,     0.0,     0.0545,   0.0,    0.0],\n...     [ 0.0,       0.0,    0.0,    -0.492,   0.004165, 0.0,    4.92],\n...     [ 0.0,       0.0,    0.0,     0.0,     0.521,  -12.5,    0.0],\n...     [ 0.0,       0.0,    0.0,     0.0,     0.0,      3.33,  -3.33],\n...     ], order='F', dtype=float)\n>>> b = np.zeros((n, max(m, p)), order='F', dtype=float)\n>>> b[1, 0] = 12.5\n>>> b[5, 1] = 12.5\n>>> c = np.zeros((max(m, p), n), order='F', dtype=float)\n>>> c[0, 0] = 1.0\n>>> c[1, 3] = 1.0\n>>> c[2, 4] = 1.0\n>>> d = np.zeros((max(m, p), max(m, p)), order='F', dtype=float)\n>>> nq, nr, br, dr, iwarn, info = sb08cd('C', a, b, c, d, tol=tol)\n>>> aq = a[:nq, :nq]\n>>> eigvals = np.linalg.eigvals(aq)\n>>> ar = a[:nr, :nr]\n>>> ar_eigs = np.linalg.eigvals(ar)\n>>> ar_eigs_sorted = sorted(ar_eigs, key=lambda x: x.imag)\n>>> info\n0",
  "sb08dd": "Right coprime factorization with inner denominator.\n\nComputes a right coprime factorization G = N*M^(-1) with inner denominator\nof a given state-space representation (A,B,C,D).\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  a (ndarray): N-by-N state matrix (F-order)\n  b (ndarray): N-by-M input matrix (F-order)\n  c (ndarray): P-by-N output matrix (F-order)\n  d (ndarray): P-by-M feedthrough matrix (F-order)\n  tol (float): Tolerance for rank determination\n\nReturns:\n  (a, b, c, d, nq, nr, cr, dr, iwarn, info): Modified matrices, orders,\n    denominator matrices CR and DR, warning and exit codes\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb08dd\n>>> n, m, p = 7, 2, 3\n>>> a = np.array([\n...     [-0.04165,  0.0000,  4.9200,  0.4920,  0.0000,  0.0000,  0.0000],\n...     [-5.2100, -12.500,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.0000,  3.3300, -3.3300,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [ 0.5450,  0.0000,  0.0000,  0.0000,  0.0545,  0.0000,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000, -0.4920,  0.004165, 0.0000,  4.9200],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.5210, -12.500,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  3.3300, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0000,  0.0000],\n...     [12.500,  0.0000],\n...     [0.0000,  0.0000],\n...     [0.0000,  0.0000],\n...     [0.0000,  0.0000],\n...     [0.0000,  12.500],\n...     [0.0000,  0.0000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n...     [0.0000,  0.0000,  0.0000,  1.0000,  0.0000,  0.0000,  0.0000],\n...     [0.0000,  0.0000,  0.0000,  0.0000,  1.0000,  0.0000,  0.0000]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0000,  0.0000],\n...     [0.0000,  0.0000],\n...     [0.0000,  0.0000]\n...     ], order='F', dtype=float)\n>>> tol = 1e-10\n>>> a_out, b_out, c_out, d_out, nq, nr, cr, dr, iwarn, info = sb08dd(\n...     'C', a.copy(order='F'), b.copy(order='F'), c.copy(order='F'),\n...     d.copy(order='F'), tol)\n>>> info\n0",
  "sb08ed": "Left coprime factorization with prescribed stability degree.\n\nConstructs output injection matrix H and orthogonal transformation Z such that\nQ = (Z'*(A+H*C)*Z, Z'*(B+H*D), C*Z, D) and R = (Z'*(A+H*C)*Z, Z'*H, C*Z, I)\nprovide stable left coprime factorization G = R^(-1) * Q.\n\nUndetectable parts are automatically deflated. Input arrays A, B, C, D are\nmodified in-place to contain the factorization results.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  a (ndarray): N-by-N state matrix (F-order, modified to contain AQ in Schur)\n  b (ndarray): N-by-M input matrix (F-order, modified to contain BQ)\n  c (ndarray): P-by-N output matrix (F-order, modified to contain CQ)\n  d (ndarray): P-by-M feedthrough matrix (F-order, = DQ unchanged)\n  alpha (ndarray): [stability_degree, stability_margin]. For continuous:\n    eigenvalues outside alpha[1]-region get real parts = alpha[0] < 0.\n    For discrete: 0 <= alpha[i] < 1.\n  tol (float, optional): Tolerance for observability test (default: auto)\n\nReturns:\n  (nq, nr, br, dr, iwarn, info):\n    nq = order of factors Q and R, nr = order of minimal R,\n    br = NQ-by-P output injection matrix Z'*H (first NR rows = BR of R),\n    dr = P-by-P identity matrix, iwarn = warning count, info = exit code\n\nExamples:\n\n>>> from slicot import sb08ed\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> a = np.array([\n...     [-0.04165,  0.0000,  4.9200,   0.4920,  0.0000,   0.0000,  0.0000],\n...     [-5.2100,  -12.500,  0.0000,   0.0000,  0.0000,   0.0000,  0.0000],\n...     [ 0.0000,   3.3300, -3.3300,   0.0000,  0.0000,   0.0000,  0.0000],\n...     [ 0.5450,   0.0000,  0.0000,   0.0000,  0.0545,   0.0000,  0.0000],\n...     [ 0.0000,   0.0000,  0.0000,  -0.4920,  0.004165, 0.0000,  4.9200],\n...     [ 0.0000,   0.0000,  0.0000,   0.0000,  0.5210,  -12.500,  0.0000],\n...     [ 0.0000,   0.0000,  0.0000,   0.0000,  0.0000,   3.3300, -3.3300],\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [ 0.0000,   0.0000],\n...     [12.500,    0.0000],\n...     [ 0.0000,   0.0000],\n...     [ 0.0000,   0.0000],\n...     [ 0.0000,   0.0000],\n...     [ 0.0000,  12.500],\n...     [ 0.0000,   0.0000],\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [1.0000,  0.0000,  0.0000,   0.0000,  0.0000,  0.0000,  0.0000],\n...     [0.0000,  0.0000,  0.0000,   1.0000,  0.0000,  0.0000,  0.0000],\n...     [0.0000,  0.0000,  0.0000,   0.0000,  1.0000,  0.0000,  0.0000],\n...     ], dtype=float, order='F')\n>>> d = np.array([\n...     [0.0000,  0.0000],\n...     [0.0000,  0.0000],\n...     [0.0000,  0.0000],\n...     ], dtype=float, order='F')\n>>> alpha = np.array([-1.0, -1.0], dtype=float)\n>>> tol = 1.0e-10\n>>> nq, nr, br, dr, iwarn, info = sb08ed(\n...     'C', a, b, c, d, alpha, tol\n...     )\n>>> eig_computed = np.linalg.eigvals(a[:nq, :nq])\n>>> )\n>>> )\n>>> info\n0",
  "sb08fd": "Right coprime factorization with prescribed stability degree.\n\nConstructs feedback matrix F and orthogonal transformation Z such that\nQ = (Z'*(A+B*F)*Z, Z'*B, (C+D*F)*Z, D) and R = (Z'*(A+B*F)*Z, Z'*B, F*Z, I)\nprovide stable right coprime factorization G = Q * R^(-1).\n\nUnstabilizable parts are automatically deflated.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  n (int): State dimension (order of A)\n  m (int): Number of inputs\n  p (int): Number of outputs\n  alpha (ndarray): [stability_degree, stability_margin]. For continuous:\n    eigenvalues outside alpha[1]-region get real parts = alpha[0] < 0.\n    For discrete: 0 <= alpha[i] < 1.\n  a (ndarray): N-by-N state matrix (F-order)\n  b (ndarray): N-by-M input matrix (F-order)\n  c (ndarray): P-by-N output matrix (F-order)\n  d (ndarray): P-by-M feedthrough matrix (F-order)\n  tol (float, optional): Tolerance for controllability test\n\nReturns:\n  (a, b, c, cr, dr, nq, nr, iwarn, info): Modified A,B,C in Schur form,\n    feedback matrix CR (M-by-N), identity DR (M-by-M),\n    order NQ, denominator order NR, warning count, exit code\n\nExamples:\n\n>>> from slicot import sb08fd\n>>> import numpy as np\n>>> n, m, p = 7, 2, 3\n>>> alpha = np.array([-1.0, -1.0], dtype=float, order='F')\n>>> tol = 1e-10\n>>> a = np.array([\n...     [-0.04165,  0.0000,  4.9200,  0.4920,  0.0000,   0.0000,  0.0000],\n...     [-5.2100, -12.500,  0.0000,  0.0000,  0.0000,   0.0000,  0.0000],\n...     [ 0.0000,  3.3300, -3.3300,  0.0000,  0.0000,   0.0000,  0.0000],\n...     [ 0.5450,  0.0000,  0.0000,  0.0000,  0.0545,   0.0000,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000, -0.4920,  0.004165, 0.0000,  4.9200],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.5210, -12.500,  0.0000],\n...     [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,   3.3300, -3.3300]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [ 0.0000,  0.0000],\n...     [12.500,   0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000,  0.0000],\n...     [ 0.0000, 12.500],\n...     [ 0.0000,  0.0000]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [1.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000, 0.0000],\n...     [0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 0.0000, 0.0000]\n...     ], dtype=float, order='F')\n>>> d = np.array([\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000],\n...     [0.0000, 0.0000]\n...     ], dtype=float, order='F')\n>>> aq, bq, cq, cr, dr, nq, nr, iwarn, info = sb08fd(\n...     'C', n, m, p, alpha, a, b, c, d, tol=tol\n...     )\n>>> eigs = np.linalg.eigvals(aq[:nq, :nq])\n...     lower_part = np.tril(aq[:nq, :nq], k=-2)\n>>> info\n0",
  "sb08gd": "State-space representation from left coprime factorization.\n\nConstructs the state-space representation G = (A,B,C,D) from factors\nQ = (AQR,BQ,CQR,DQ) and R = (AQR,BR,CQR,DR) of left coprime factorization\nG = R^{-1} * Q.\n\nFormulas:\n  A = AQR - BR * DR^{-1} * CQR\n  B = BQ  - BR * DR^{-1} * DQ\n  C = DR^{-1} * CQR\n  D = DR^{-1} * DQ\n\nParameters:\n  a (ndarray): N-by-N state matrix AQR (F-order, modified in-place)\n  b (ndarray): N-by-M input matrix BQ (F-order, modified in-place)\n  c (ndarray): P-by-N output matrix CQR (F-order, modified in-place)\n  d (ndarray): P-by-M feedthrough matrix DQ (F-order, modified in-place)\n  br (ndarray): N-by-P input matrix BR of system R (F-order)\n  dr (ndarray): P-by-P matrix DR (F-order, returns LU factorization)\n\nReturns:\n  (a, b, c, d, dr, rcond, info): Modified A,B,C,D matrices, LU of DR,\n    reciprocal condition number of DR, exit code\n    info=0: success, info=1: DR singular, info=2: DR numerically singular (warning)\n\nExamples:\n\n>>> from slicot import sb08gd\n>>> import numpy as np\n>>> n, m, p = 2, 1, 1\n>>> aqr = np.array([\n...     [-1.0, 0.5],\n...     [0.0, -2.0]\n...     ], order='F', dtype=float)\n>>> bq = np.array([\n...     [1.0],\n...     [0.5]\n...     ], order='F', dtype=float)\n>>> cqr = np.array([\n...     [1.0, 0.5]\n...     ], order='F', dtype=float)\n>>> dq = np.array([\n...     [0.5]\n...     ], order='F', dtype=float)\n>>> br = np.array([\n...     [0.2],\n...     [0.1]\n...     ], order='F', dtype=float)\n>>> dr = np.array([\n...     [2.0]\n...     ], order='F', dtype=float)\n>>> a = aqr.copy(order='F')\n>>> b = bq.copy(order='F')\n>>> c = cqr.copy(order='F')\n>>> d = dq.copy(order='F')\n>>> a_out, b_out, c_out, d_out, dr_lu, rcond, info = sb08gd(\n...     a, b, c, d, br, dr\n...     )\n>>> dr_inv_cqr = np.linalg.solve(dr, cqr)\n>>> dr_inv_dq = np.linalg.solve(dr, dq)\n>>> info\n0",
  "sb08hd": "State-space representation from right coprime factorization.\n\nConstructs the state-space representation G = (A,B,C,D) from factors\nQ = (AQR,BQR,CQ,DQ) and R = (AQR,BQR,CR,DR) of right coprime factorization\nG = Q * R^{-1}.\n\nFormulas:\n  A = AQR - BQR * DR^{-1} * CR\n  B = BQR * DR^{-1}\n  C = CQ  - DQ * DR^{-1} * CR\n  D = DQ * DR^{-1}\n\nParameters:\n  a (ndarray): N-by-N state matrix AQR (F-order, modified in-place)\n  b (ndarray): N-by-M input matrix BQR (F-order, modified in-place)\n  c (ndarray): P-by-N output matrix CQ (F-order, modified in-place)\n  d (ndarray): P-by-M feedthrough matrix DQ (F-order, modified in-place)\n  cr (ndarray): M-by-N output matrix CR of system R (F-order)\n  dr (ndarray): M-by-M matrix DR (F-order, returns LU factorization)\n\nReturns:\n  (rcond, info): Reciprocal condition number of DR, exit code.\n    info=0: success, info=1: DR singular, info=2: DR numerically singular (warning)\n    Arrays a, b, c, d are modified in-place to contain G's matrices.\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb08hd\n>>> n, m, p = 3, 2, 2\n>>> dr = np.eye(m, dtype=float, order='F') + 0.1 * np.random.randn(m, m)\n>>> dr = np.asfortranarray(dr)\n>>> aqr = np.random.randn(n, n).astype(float, order='F')\n>>> bqr = np.random.randn(n, m).astype(float, order='F')\n>>> cq = np.random.randn(p, n).astype(float, order='F')\n>>> dq = np.random.randn(p, m).astype(float, order='F')\n>>> cr = np.random.randn(m, n).astype(float, order='F')\n>>> dr_inv = np.linalg.inv(dr)\n>>> a = aqr.copy(order='F')\n>>> b = bqr.copy(order='F')\n>>> c = cq.copy(order='F')\n>>> d = dq.copy(order='F')\n>>> dr_input = dr.copy(order='F')\n>>> rcond, info = sb08hd(a, b, c, d, cr, dr_input)\n>>> info\n0",
  "sb08md": "Spectral factorization of polynomials (continuous-time case).\n\nComputes a real polynomial E(s) such that:\n  (a) E(-s) * E(s) = A(-s) * A(s)\n  (b) E(s) is stable (all zeros have non-positive real parts)\n\nThe input polynomial may be supplied as A(s) or as B(s) = A(-s) * A(s).\n\nParameters:\n  acona (str): 'A' to supply A(s) coefficients, 'B' to supply B(s) coefficients\n  da (int): Degree of polynomials A(s) and E(s). DA >= 0.\n  a (ndarray): Coefficients in increasing powers of s (if acona='A') or s**2\n    (if acona='B'). Length DA+1.\n\nReturns:\n  (e, b, res, info):\n    e: Coefficients of spectral factor E(s) in increasing powers of s (length DA+1)\n    b: Coefficients of B(s) = A(-s)*A(s) in increasing powers of s**2 (length DA+1)\n    res: Accuracy estimate for E(s) coefficients\n    info: 0=success, 1=all A(i)=0, 2=invalid B(s) for ACONA='B',\n          3=no convergence in 30 iterations, 4=last iterate unstable\n\nExamples:\n\n>>> from slicot import sb08md\n>>> import numpy as np\n>>> da = 3\n>>> a = np.array([8.0, -6.0, -3.0, 1.0], dtype=float)\n>>> e, b, res, info = sb08md('A', da, a)\n>>> info\n0",
  "sb08my": "Compute B(s) = A(s) * A(-s) for spectral factorization.\n\nComputes coefficients of B(s) = A(s) * A(-s) where A(s) is a polynomial\ngiven in increasing powers of s. B(s) is returned in increasing powers\nof s**2. Also computes an accuracy norm.\n\nParameters:\n  a (ndarray): Coefficients of A(s) in increasing powers of s (length DA+1)\n  epsb (float): Machine precision (e.g., np.finfo(float).eps)\n\nReturns:\n  (b, epsb): Coefficients of B(s) in powers of s**2 (length DA+1),\n    updated accuracy norm (3 * max_abs_sum * epsb)\n\nExamples:\n\n>>> from slicot import sb08my\n>>> import numpy as np\n>>> a = np.array([2.0], dtype=float, order='F')\n>>> epsb = np.finfo(float).eps\n>>> b, epsb_out = sb08my(a, epsb)",
  "sb08nd": "Spectral factorization of polynomials (discrete-time case).\n\nComputes a real polynomial E(z) such that:\n  (a) E(1/z) * E(z) = A(1/z) * A(z)\n  (b) E(z) is stable (all zeros have modulus <= 1)\n\nThe input polynomial may be supplied as A(z) or as B(z) = A(1/z) * A(z).\n\nParameters:\n  acona (str): 'A' to supply A(z) coefficients, 'B' to supply B(z) coefficients\n  da (int): Degree of polynomials A(z) and E(z). DA >= 0.\n  a (ndarray): Coefficients in increasing powers of z. Length DA+1.\n\nReturns:\n  (e, b, res, info):\n    e: Coefficients of spectral factor E(z) in increasing powers of z (length DA+1)\n    b: Coefficients of B(z) = A(1/z)*A(z) as defined in equation (1) (length DA+1)\n    res: Accuracy estimate for E(z) coefficients\n    info: 0=success, 2=invalid B(z) for ACONA='B',\n          3=no convergence in 30 iterations, 4=last iterate unstable\n\nExamples:\n\n>>> from slicot import sb08nd\n>>> import numpy as np\n>>> da = 2\n>>> a = np.array([2.0, 4.5, 1.0], dtype=float)\n>>> e, b, res, info = sb08nd('A', da, a)\n>>> info\n0",
  "sb08ny": "Compute B(z) = A(1/z) * A(z) for discrete-time spectral factorization.\n\nComputes the coefficients of B(z) = A(1/z) * A(z) where A(z) is a\npolynomial given in increasing powers of z. The output B contains the\nautocorrelation coefficients of A: b[k] = sum_{j=0}^{da-k} a[j]*a[j+k].\n\nParameters:\n  a (ndarray): Coefficients of A(z) in increasing powers of z (length DA+1)\n\nReturns:\n  (b, epsb): Autocorrelation coefficients (length DA+1),\n    accuracy norm (3 * machine_eps * b[0])\n\nExamples:\n\n>>> from slicot import sb08ny\n>>> import numpy as np\n>>> a = np.array([3.0], dtype=float, order='F')\n>>> b, epsb = sb08ny(a)",
  "sb09md": "Evaluate closeness of two multivariable sequences.\n\nCompares M1(k) and M2(k) for k=1,...,N where each is NC-by-NB matrix.\n\nComputes:\n  SS(i,j) = sum_{k=1}^N M1(i,j,k)^2  (sum of squares)\n  SE(i,j) = sum_{k=1}^N (M1(i,j,k) - M2(i,j,k))^2  (quadratic error)\n  PRE(i,j) = 100 * sqrt(SE(i,j)/SS(i,j))  (percentage relative error)\n\nParameters:\n  n (int): Number of parameters (N >= 0)\n  nc (int): Number of rows in M1(k), M2(k) (NC >= 0)\n  nb (int): Number of columns in M1(k), M2(k) (NB >= 0)\n  h1 (ndarray): NC-by-(N*NB) array with M1(k) sequence (F-order)\n  h2 (ndarray): NC-by-(N*NB) array with M2(k) sequence (F-order)\n  tol (float): Tolerance for computation (if < eps, eps is used)\n\nReturns:\n  (ss, se, pre, info): Sum-of-squares matrix, quadratic error matrix,\n    percentage relative error matrix, and exit code\n\nExamples:\n\n>>> from slicot import sb09md\n>>> import numpy as np\n>>> n = 2\n>>> nc = 2\n>>> nb = 2\n>>> tol = 0.0\n>>> h1 = np.array([\n...     [1.3373, 0.6618, -0.4062, 0.9299],\n...     [0.1205, -0.3372, 1.6120, 0.7429]\n...     ], order='F', dtype=float)\n>>> h2 = np.array([\n...     [1.1480, 0.8843, -0.4616, 0.6028],\n...     [-0.1837, -0.4947, 1.4674, 0.9524]\n...     ], order='F', dtype=float)\n>>> ss, se, pre, info = sb09md(n, nc, nb, h1, h2, tol)\n>>> info\n0",
  "sb10ad": "H-infinity optimal n-state controller synthesis.\n\nComputes an H-infinity optimal n-state controller K = (AK, BK, CK, DK)\nusing modified Glover-Doyle 1988 formulas and the closed-loop system\nG = (AC, BC, CC, DC) for the plant P = (A, B, C, D).\n\nPlant partitioning:\n  | A  | B1  B2  |\n  |----|---------|  where B2 has NCON columns, C2 has NMEAS rows\n  | C1 | D11 D12 |\n  | C2 | D21 D22 |\n\nJOB modes:\n  1: Bisection for gamma reduction\n  2: Scan from gamma to 0\n  3: Bisection then scanning\n  4: Suboptimal controller only\n\nParameters:\n  job (int): Optimization mode (1-4)\n  n (int): State dimension\n  m (int): Number of inputs\n  np (int): Number of outputs\n  ncon (int): Number of control inputs (M2)\n  nmeas (int): Number of measurements (NP2)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  gamma (float): Initial H-infinity norm bound (gamma > 0)\n  gtol (float): Tolerance for gamma (<=0 uses sqrt(eps))\n  actol (float): Tolerance for stability (<=0 uses stability check)\n\nReturns:\n  (ak, bk, ck, dk, ac, bc, cc, dc, gamma, rcond, info):\n    Controller K, closed-loop G, achieved gamma, condition numbers, exit code\n\nExamples:\n\n>>> from slicot import sb10ad\n>>> import numpy as np\n>>> n = 2       # State dimension\n>>> m = 2       # Total inputs: m1=1 external + m2=1 control\n>>> np_ = 2     # Total outputs: np1=1 performance + np2=1 measurement\n>>> ncon = 1    # Control inputs (m2)\n>>> nmeas = 1   # Measurements (np2)\n>>> A = np.array([[-1.0, 1.0],\n...     [0.0, -2.0]], dtype=float, order='F')\n>>> B = np.array([[1.0, 1.0],\n...     [0.0, 1.0]], dtype=float, order='F')\n>>> C = np.array([[1.0, 0.0],\n...     [0.0, 1.0]], dtype=float, order='F')\n>>> D = np.array([[0.0, 1.0],\n...     [1.0, 0.0]], dtype=float, order='F')\n>>> gamma = 5.0\n>>> gtol = 1e-6\n>>> actol = 0.0\n>>> job = 4\n>>> result = slicot.sb10ad(job, n, m, np_, ncon, nmeas, A, B, C, D, gamma, gtol, actol)\n>>> ak, bk, ck, dk, ac, bc, cc, dc, gamma_out, rcond, info = result",
  "sb10dd": "H-infinity (sub)optimal controller for discrete-time system.\n\nComputes the matrices of an H-infinity controller K = [AK BK; CK DK]\nfor the discrete-time system P = [A B; C D] partitioned as\nP = [A B1 B2; C1 D11 D12; C2 D21 D22] where B2 has NCON columns\nand C2 has NMEAS rows.\n\nParameters:\n  n (int): Order of the system\n  m (int): Column size of B\n  np (int): Row size of C\n  ncon (int): Number of control inputs\n  nmeas (int): Number of measurements\n  gamma (float): H-infinity norm bound (gamma > 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  tol (float, optional): Tolerance for rank determination\n\nReturns:\n  (ak, bk, ck, dk, x, z, rcond, info): Controller matrices,\n    Riccati solutions, condition numbers, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb10dd\n>>> n = 6\n>>> m = 5\n>>> np_ = 5\n>>> ncon = 2\n>>> nmeas = 2\n>>> gamma = 111.294\n>>> tol = 1e-8\n>>> a = np.array([\n...     [-0.7,  0.0,  0.3,  0.0, -0.5, -0.1],\n...     [-0.6,  0.2, -0.4, -0.3,  0.0,  0.0],\n...     [-0.5,  0.7, -0.1,  0.0,  0.0, -0.8],\n...     [-0.7,  0.0,  0.0, -0.5, -1.0,  0.0],\n...     [ 0.0,  0.3,  0.6, -0.9,  0.1, -0.4],\n...     [ 0.5, -0.8,  0.0,  0.0,  0.2, -0.9]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [-1.0, -2.0, -2.0,  1.0,  0.0],\n...     [ 1.0,  0.0,  1.0, -2.0,  1.0],\n...     [-3.0, -4.0,  0.0,  2.0, -2.0],\n...     [ 1.0, -2.0,  1.0,  0.0, -1.0],\n...     [ 0.0,  1.0, -2.0,  0.0,  3.0],\n...     [ 1.0,  0.0,  3.0, -1.0, -2.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [ 1.0, -1.0,  2.0, -2.0,  0.0, -3.0],\n...     [-3.0,  0.0,  1.0, -1.0,  1.0,  0.0],\n...     [ 0.0,  2.0,  0.0, -4.0,  0.0, -2.0],\n...     [ 1.0, -3.0,  0.0,  0.0,  3.0,  1.0],\n...     [ 0.0,  1.0, -2.0,  1.0,  0.0, -2.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [ 1.0, -1.0, -2.0,  0.0,  0.0],\n...     [ 0.0,  1.0,  0.0,  1.0,  0.0],\n...     [ 2.0, -1.0, -3.0,  0.0,  1.0],\n...     [ 0.0,  1.0,  0.0,  1.0, -1.0],\n...     [ 0.0,  0.0,  1.0,  2.0,  1.0]\n...     ], order='F', dtype=float)\n>>> ak, bk, ck, dk, x, z, rcond, info = sb10dd(n, m, np_, ncon, nmeas, gamma, a, b, c, d, tol)\n>>> info\n0",
  "sb10ed": "H2 optimal n-state controller for discrete-time system.\n\nComputes the matrices of the H2 optimal controller K = [AK BK; CK DK]\nfor the discrete-time system P = [A B; C D] partitioned as\nP = [A B1 B2; C1 0 D12; C2 D21 D22] where B2 has NCON columns\nand C2 has NMEAS rows.\n\nAssumptions:\n  - (A,B2) is stabilizable and (C2,A) is detectable\n  - D12 is full column rank and D21 is full row rank\n  - Discrete-time invariant zeros conditions (A3, A4)\n\nParameters:\n  n (int): Order of the system (>= 0)\n  m (int): Column size of B (>= 0)\n  np (int): Row size of C (>= 0)\n  ncon (int): Number of control inputs M2 (0 <= ncon <= m, ncon <= np-nmeas)\n  nmeas (int): Number of measurements NP2 (0 <= nmeas <= np, nmeas <= m-ncon)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  tol (float, optional): Tolerance for transformations. Default sqrt(eps).\n\nReturns:\n  (ak, bk, ck, dk, rcond, info): Controller matrices, condition numbers, exit code\n  rcond has 7 elements:\n    [0]: control transformation TU\n    [1]: measurement transformation TY\n    [2]: Im2 + B2'*X2*B2\n    [3]: Ip2 + C2*Y2*C2'\n    [4]: X-Riccati equation\n    [5]: Y-Riccati equation\n    [6]: Im2 + DKHAT*D22\n  info: 0=success, 1-2=rank deficiency, 3-4=D12/D21 rank, 5=SVD,\n    6=X-Riccati, 7=B2'*X*B2 not PD, 8=Y-Riccati, 9=C2*Y*C2' not PD,\n    10=Im2+DKHAT*D22 singular\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb10ed\n>>> n = 6\n>>> m = 5\n>>> np_ = 5\n>>> ncon = 2\n>>> nmeas = 2\n>>> a = np.array([\n...     [-0.7,  0.0,  0.3,  0.0, -0.5, -0.1],\n...     [-0.6,  0.2, -0.4, -0.3,  0.0,  0.0],\n...     [-0.5,  0.7, -0.1,  0.0,  0.0, -0.8],\n...     [-0.7,  0.0,  0.0, -0.5, -1.0,  0.0],\n...     [ 0.0,  0.3,  0.6, -0.9,  0.1, -0.4],\n...     [ 0.5, -0.8,  0.0,  0.0,  0.2, -0.9]\n...     ], order='F', dtype=np.float64)\n>>> b = np.array([\n...     [-1.0, -2.0, -2.0,  1.0,  0.0],\n...     [ 1.0,  0.0,  1.0, -2.0,  1.0],\n...     [-3.0, -4.0,  0.0,  2.0, -2.0],\n...     [ 1.0, -2.0,  1.0,  0.0, -1.0],\n...     [ 0.0,  1.0, -2.0,  0.0,  3.0],\n...     [ 1.0,  0.0,  3.0, -1.0, -2.0]\n...     ], order='F', dtype=np.float64)\n>>> c = np.array([\n...     [ 1.0, -1.0,  2.0, -2.0,  0.0, -3.0],\n...     [-3.0,  0.0,  1.0, -1.0,  1.0,  0.0],\n...     [ 0.0,  2.0,  0.0, -4.0,  0.0, -2.0],\n...     [ 1.0, -3.0,  0.0,  0.0,  3.0,  1.0],\n...     [ 0.0,  1.0, -2.0,  1.0,  0.0, -2.0]\n...     ], order='F', dtype=np.float64)\n>>> d = np.array([\n...     [ 1.0, -1.0, -2.0,  0.0,  0.0],\n...     [ 0.0,  1.0,  0.0,  1.0,  0.0],\n...     [ 2.0, -1.0, -3.0,  0.0,  1.0],\n...     [ 0.0,  1.0,  0.0,  1.0, -1.0],\n...     [ 0.0,  0.0,  1.0,  2.0,  1.0]\n...     ], order='F', dtype=np.float64)\n>>> tol = 1e-8\n>>> ak, bk, ck, dk, rcond, info = sb10ed(\n...     n, m, np_, ncon, nmeas, a, b, c, d, tol\n...     )\n...     err_msg=\"AK values do not match HTML doc\")\n...     err_msg=\"BK values do not match HTML doc\")\n...     err_msg=\"CK values do not match HTML doc\")\n...     err_msg=\"DK values do not match HTML doc\")\n...     err_msg=\"RCOND(1) mismatch\")\n...     err_msg=\"RCOND(2) mismatch\")\n>>> info\n0",
  "sb10fd": "H-infinity (sub)optimal controller for continuous-time system.\n\nComputes the matrices of an H-infinity controller K = [AK BK; CK DK]\nfor the continuous-time system P = [A B; C D] partitioned as\nP = [A B1 B2; C1 D11 D12; C2 D21 D22] where B2 has NCON columns\nand C2 has NMEAS rows. Uses Glover-Doyle formulas for fixed gamma.\n\nParameters:\n  n (int): Order of the system\n  m (int): Column size of B\n  np (int): Row size of C\n  ncon (int): Number of control inputs\n  nmeas (int): Number of measurements\n  gamma (float): H-infinity norm bound (gamma > 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  tol (float, optional): Tolerance for transformations. Default sqrt(eps).\n\nReturns:\n  (ak, bk, ck, dk, rcond, info): Controller matrices, condition numbers, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb10fd\n>>> n = 6\n>>> m = 5\n>>> np_dim = 5\n>>> ncon = 2\n>>> nmeas = 2\n>>> gamma = 15.0\n>>> tol = 1e-8\n>>> a = np.array([\n...     [-1.0,  0.0,  4.0,  5.0, -3.0, -2.0],\n...     [-2.0,  4.0, -7.0, -2.0,  0.0,  3.0],\n...     [-6.0,  9.0, -5.0,  0.0,  2.0, -1.0],\n...     [-8.0,  4.0,  7.0, -1.0, -3.0,  0.0],\n...     [ 2.0,  5.0,  8.0, -9.0,  1.0, -4.0],\n...     [ 3.0, -5.0,  8.0,  0.0,  2.0, -6.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [-3.0, -4.0, -2.0,  1.0,  0.0],\n...     [ 2.0,  0.0,  1.0, -5.0,  2.0],\n...     [-5.0, -7.0,  0.0,  7.0, -2.0],\n...     [ 4.0, -6.0,  1.0,  1.0, -2.0],\n...     [-3.0,  9.0, -8.0,  0.0,  5.0],\n...     [ 1.0, -2.0,  3.0, -6.0, -2.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [ 1.0, -1.0,  2.0, -4.0,  0.0, -3.0],\n...     [-3.0,  0.0,  5.0, -1.0,  1.0,  1.0],\n...     [-7.0,  5.0,  0.0, -8.0,  2.0, -2.0],\n...     [ 9.0, -3.0,  4.0,  0.0,  3.0,  7.0],\n...     [ 0.0,  1.0, -2.0,  1.0, -6.0, -2.0]\n...     ], dtype=float, order='F')\n>>> d = np.array([\n...     [1.0, -2.0, -3.0,  0.0,  0.0],\n...     [0.0,  4.0,  0.0,  1.0,  0.0],\n...     [5.0, -3.0, -4.0,  0.0,  1.0],\n...     [0.0,  1.0,  0.0,  1.0, -3.0],\n...     [0.0,  0.0,  1.0,  7.0,  1.0]\n...     ], dtype=float, order='F')\n>>> ak, bk, ck, dk, rcond, info = sb10fd(n, m, np_dim, ncon, nmeas, gamma,\n...     a, b, c, d, tol)\n>>> info\n0",
  "sb10hd": "Compute H2 optimal n-state controller for continuous-time system.\n\nComputes controller K = (AK, BK, CK, DK) for a plant P = (A, B, C, D)\npartitioned as P = [A B1 B2; C1 0 D12; C2 D21 D22].\n\nAssumptions:\n  - (A,B2) is stabilizable and (C2,A) is detectable\n  - D11 = 0\n  - D12 is full column rank and D21 is full row rank\n\nParameters:\n  n (int): System order (>= 0)\n  m (int): Number of inputs (>= 0)\n  np (int): Number of outputs (>= 0)\n  ncon (int): Number of control inputs M2 (0 <= ncon <= m, ncon <= np-nmeas)\n  nmeas (int): Number of measurements NP2 (0 <= nmeas <= np, nmeas <= m-ncon)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  tol (float): Tolerance for rank tests. If <= 0, sqrt(eps) is used.\n\nReturns:\n  (ak, bk, ck, dk, rcond, info): Controller matrices, condition estimates, exit code\n  rcond has 4 elements: control/measurement transform rcond, X/Y Riccati rcond\n  info: 0=success, 1=D12 rank, 2=D21 rank, 3=SVD, 4=X-Riccati, 5=Y-Riccati\n\nExamples:\n\n>>> from slicot import sb10hd\n>>> import numpy as np\n>>> n = 6\n>>> m = 5\n>>> np_ = 5\n>>> ncon = 2\n>>> nmeas = 2\n>>> A = np.array([\n...     [-1.0,  0.0,  4.0,  5.0, -3.0, -2.0],\n...     [-2.0,  4.0, -7.0, -2.0,  0.0,  3.0],\n...     [-6.0,  9.0, -5.0,  0.0,  2.0, -1.0],\n...     [-8.0,  4.0,  7.0, -1.0, -3.0,  0.0],\n...     [ 2.0,  5.0,  8.0, -9.0,  1.0, -4.0],\n...     [ 3.0, -5.0,  8.0,  0.0,  2.0, -6.0]\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [-3.0, -4.0, -2.0,  1.0,  0.0],\n...     [ 2.0,  0.0,  1.0, -5.0,  2.0],\n...     [-5.0, -7.0,  0.0,  7.0, -2.0],\n...     [ 4.0, -6.0,  1.0,  1.0, -2.0],\n...     [-3.0,  9.0, -8.0,  0.0,  5.0],\n...     [ 1.0, -2.0,  3.0, -6.0, -2.0]\n...     ], order='F', dtype=float)\n>>> C = np.array([\n...     [ 1.0, -1.0,  2.0, -4.0,  0.0, -3.0],\n...     [-3.0,  0.0,  5.0, -1.0,  1.0,  1.0],\n...     [-7.0,  5.0,  0.0, -8.0,  2.0, -2.0],\n...     [ 9.0, -3.0,  4.0,  0.0,  3.0,  7.0],\n...     [ 0.0,  1.0, -2.0,  1.0, -6.0, -2.0]\n...     ], order='F', dtype=float)\n>>> D = np.array([\n...     [ 0.0,  0.0,  0.0, -4.0, -1.0],\n...     [ 0.0,  0.0,  0.0,  1.0,  0.0],\n...     [ 0.0,  0.0,  0.0,  0.0,  1.0],\n...     [ 3.0,  1.0,  0.0,  1.0, -3.0],\n...     [-2.0,  0.0,  1.0,  7.0,  1.0]\n...     ], order='F', dtype=float)\n>>> tol = 1e-8\n>>> AK, BK, CK, DK, rcond, info = sb10hd(n, m, np_, ncon, nmeas, A, B, C, D, tol)\n>>> info\n0",
  "sb10id": "Positive feedback controller for loop shaping design.\n\nComputes controller K = [AK BK; CK DK] for shaped plant G = [A B; C D]\nin the McFarlane/Glover Loop Shaping Design Procedure.\n\nParameters:\n  n (int): Order of the plant (>= 0)\n  m (int): Number of plant inputs (>= 0)\n  np (int): Number of plant outputs (>= 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  factor (float): =1 for optimal controller, >1 for suboptimal\n\nReturns:\n  (ak, bk, ck, dk, nk, rcond, info): Controller matrices, order, cond numbers, exit code\n  nk: Controller order (nk <= n)\n  rcond: [X-Riccati rcond, Z-Riccati rcond]\n  info: 0=success, 1=X-Riccati, 2=Z-Riccati, 3=iteration,\n        4=Ip-D*Dk singular, 5=Im-Dk*D singular, 6=unstable\n\nExamples:\n\n>>> from slicot import sb10id\n>>> import numpy as np\n>>> n, m, np_ = 6, 2, 3\n>>> factor = 1.0\n>>> a = np.array([\n...     [-1.0,  0.0,  4.0,  5.0, -3.0, -2.0],\n...     [-2.0,  4.0, -7.0, -2.0,  0.0,  3.0],\n...     [-6.0,  9.0, -5.0,  0.0,  2.0, -1.0],\n...     [-8.0,  4.0,  7.0, -1.0, -3.0,  0.0],\n...     [ 2.0,  5.0,  8.0, -9.0,  1.0, -4.0],\n...     [ 3.0, -5.0,  8.0,  0.0,  2.0, -6.0]\n...     ], order='F', dtype=np.float64)\n>>> b = np.array([\n...     [-3.0, -4.0],\n...     [ 2.0,  0.0],\n...     [-5.0, -7.0],\n...     [ 4.0, -6.0],\n...     [-3.0,  9.0],\n...     [ 1.0, -2.0]\n...     ], order='F', dtype=np.float64)\n>>> c = np.array([\n...     [ 1.0, -1.0,  2.0, -4.0,  0.0, -3.0],\n...     [-3.0,  0.0,  5.0, -1.0,  1.0,  1.0],\n...     [-7.0,  5.0,  0.0, -8.0,  2.0, -2.0]\n...     ], order='F', dtype=np.float64)\n>>> d = np.array([\n...     [1.0, -2.0],\n...     [0.0,  4.0],\n...     [5.0, -3.0]\n...     ], order='F', dtype=np.float64)\n>>> ak, bk, ck, dk, nk, rcond, info = sb10id(n, m, np_, a, b, c, d, factor)\n>>> info\n0",
  "sb10jd": "Convert descriptor state-space to regular state-space.\n\nConverts E*dx/dt = A*x + B*u to dx/dt = Ad*x + Bd*u using SVD.\n\nParameters:\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  e (ndarray): Descriptor matrix E (n x n, F-order)\n  n (int, optional): Order of descriptor system\n  m (int, optional): Number of inputs\n  np (int, optional): Number of outputs\n\nReturns:\n  (ad, bd, cd, dd, nsys, info): Converted matrices, reduced order, exit code\n\nExamples:\n\n>>> from slicot import sb10jd\n>>> import numpy as np\n>>> n, m, np_ = 3, 2, 2\n>>> a = np.array([\n...     [-1.0, 0.5, 0.2],\n...     [0.0, -2.0, 0.3],\n...     [0.0, 0.0, -3.0]\n...     ], order='F', dtype=np.float64)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.5, 1.0],\n...     [0.0, 0.5]\n...     ], order='F', dtype=np.float64)\n>>> c = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0]\n...     ], order='F', dtype=np.float64)\n>>> d = np.array([\n...     [0.0, 0.0],\n...     [0.0, 0.0]\n...     ], order='F', dtype=np.float64)\n>>> e = np.eye(n, order='F', dtype=np.float64)\n>>> ad, bd, cd, dd, nsys, info = sb10jd(a, b, c, d, e)\n>>> info\n0",
  "sb10kd": "Discrete-time loop shaping controller design.\n\nComputes the positive feedback controller K = [Ak, Bk; Ck, Dk]\nfor the shaped plant G = [A, B; C, 0] using the McFarlane-Glover\nmethod in discrete-time.\n\nParameters:\n  n (int): Order of the plant (N >= 0)\n  m (int): Column size of matrix B (M >= 0)\n  np (int): Row size of matrix C (NP >= 0)\n  a (ndarray): N-by-N system state matrix (F-order)\n  b (ndarray): N-by-M system input matrix (F-order)\n  c (ndarray): NP-by-N system output matrix (F-order)\n  factor (float): Performance factor (=1 optimal, >1 suboptimal)\n\nReturns:\n  (ak, bk, ck, dk, rcond, info): Controller matrices,\n    reciprocal condition numbers array(4), and exit code\n    info=0: success, 1: P-Riccati failed, 2: Q-Riccati failed,\n    3: X-Riccati failed, 4: eigenvalue computation failed,\n    5: singular matrix, 6: closed-loop unstable\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb10kd\n>>> n, m, np_ = 6, 2, 2\n>>> factor = 1.1\n>>> a = np.array([\n...     [0.2, 0.0, 0.3, 0.0, -0.3, -0.1],\n...     [-0.3, 0.2, -0.4, -0.3, 0.0, 0.0],\n...     [-0.1, 0.1, -0.1, 0.0, 0.0, -0.3],\n...     [0.1, 0.0, 0.0, -0.1, -0.1, 0.0],\n...     [0.0, 0.3, 0.6, 0.2, 0.1, -0.4],\n...     [0.2, -0.4, 0.0, 0.0, 0.2, -0.2],\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [-1.0, -2.0],\n...     [1.0, 3.0],\n...     [-3.0, -4.0],\n...     [1.0, -2.0],\n...     [0.0, 1.0],\n...     [1.0, 5.0],\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [1.0, -1.0, 2.0, -2.0, 0.0, -3.0],\n...     [-3.0, 0.0, 1.0, -1.0, 1.0, -1.0],\n...     ], dtype=float, order='F')\n>>> ak, bk, ck, dk, rcond, info = sb10kd(n, m, np_, a, b, c, factor)\n>>> info\n0",
  "sb10ld": "Compute closed-loop system matrices.\n\nComputes the closed-loop system G = (AC, BC, CC, DC) from the\nopen-loop plant P = (A, B, C, D) and controller K = (AK, BK, CK, DK).\n\nThe closed-loop has state dimension 2*n and computes:\n  u = u1 + u2 where u2 = K * y2 (controller output)\n  y = y1 + y2 where y2 is measured output\n\nParameters:\n  n (int): State dimension\n  m (int): Number of inputs\n  np (int): Number of outputs\n  ncon (int): Number of control inputs (M2)\n  nmeas (int): Number of measurements (NP2)\n  a (ndarray): Plant state matrix A (n x n, F-order)\n  b (ndarray): Plant input matrix B (n x m, F-order)\n  c (ndarray): Plant output matrix C (np x n, F-order)\n  d (ndarray): Plant feedthrough D (np x m, F-order)\n  ak (ndarray): Controller state matrix AK (n x n, F-order)\n  bk (ndarray): Controller input matrix BK (n x nmeas, F-order)\n  ck (ndarray): Controller output matrix CK (ncon x n, F-order)\n  dk (ndarray): Controller feedthrough DK (ncon x nmeas, F-order)\n\nReturns:\n  (ac, bc, cc, dc, info): Closed-loop matrices and exit code\n    info=0: success, 1: I-D22*DK singular, 2: I-DK*D22 singular\n\nExamples:\n\n>>> from slicot import sb10ld\n>>> import numpy as np\n>>> n = 2      # State dimension\n>>> m = 2      # Total inputs (m1=1 external, m2=1 control)\n>>> np_ = 2    # Total outputs (np1=1 performance, np2=1 measurement)\n>>> ncon = 1   # Control inputs (m2)\n>>> nmeas = 1  # Measurements (np2)\n>>> m1 = m - ncon      # 1 external input\n>>> np1 = np_ - nmeas  # 1 performance output\n>>> A = np.array([[-1.0, 0.5],\n...     [0.0, -2.0]], dtype=float, order='F')\n>>> B = np.array([[1.0, 0.5],\n...     [0.0, 1.0]], dtype=float, order='F')\n>>> C = np.array([[1.0, 0.0],\n...     [0.0, 1.0]], dtype=float, order='F')\n>>> D = np.array([[0.0, 0.0],\n...     [0.0, 0.1]], dtype=float, order='F')\n>>> AK = np.array([[-3.0, 1.0],\n...     [0.5, -4.0]], dtype=float, order='F')\n>>> BK = np.array([[2.0],\n...     [1.0]], dtype=float, order='F')\n>>> CK = np.array([[1.0, 0.5]], dtype=float, order='F')\n>>> DK = np.array([[0.2]], dtype=float, order='F')\n>>> result = slicot.sb10ld(n, m, np_, ncon, nmeas, A, B, C, D, AK, BK, CK, DK)\n>>> ac, bc, cc, dc, info = result\n>>> n2 = 2 * n",
  "sb10md": "D-step of D-K iteration for mu-synthesis (continuous-time).\n\nEstimates structured singular value mu(jw) at given frequencies and\noptionally fits state-space realizations of D-scaling matrices.\n\nParameters:\n  nc (int): State dimension of closed-loop system\n  mp (int): Number of rows in D11 block\n  lendat (int): Number of frequency points (>= 2 if QUTOL >= 0)\n  f (int): 1 = return D fitting function value, 0 = do not\n  ord (ndarray): Preferred orders for D-scaling systems (modified on exit)\n  nblock (ndarray): Block structure definition\n  itype (ndarray): Block types (1=real, 2=complex)\n  qutol (float): <0 = estimate mu only, >=0 = also fit D-scaling systems\n  a (ndarray): NC-by-NC closed-loop state matrix (F-order)\n  b (ndarray): NC-by-MP input matrix (F-order)\n  c (ndarray): MP-by-NC output matrix (F-order)\n  d (ndarray): MP-by-MP feedthrough matrix (F-order)\n  omega (ndarray): LENDAT frequency values (rad/s)\n\nReturns:\n  (totord, ad, bd, cd, dd, mju, f_value, info): Total order of D-scaling,\n    state-space realization matrices, mu estimates, fitting function value,\n    and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb10md\n>>> nc = 2\n>>> mp = 2\n>>> lendat = 10\n>>> f = 0\n>>> ord_max = 2\n>>> mnb = 2\n>>> nblock = np.array([1, 1], dtype=np.int32)\n>>> itype = np.array([2, 2], dtype=np.int32)\n>>> qutol = 2.0\n>>> a = np.array([[-1.0, 0.5],\n...     [0.0, -2.0]], order='F', dtype=float)\n>>> b = np.array([[1.0, 0.0],\n...     [0.0, 1.0]], order='F', dtype=float)\n>>> c = np.array([[1.0, 0.0],\n...     [0.0, 1.0]], order='F', dtype=float)\n>>> d = np.array([[0.0, 0.0],\n...     [0.0, 0.0]], order='F', dtype=float)\n>>> omega = np.logspace(-1, 1, lendat)\n>>> (a_out, b_out, c_out, d_out, totord, ad, bd, cd, dd, mju, info\n...     ) = sb10md(nc, mp, lendat, f, ord_max, mnb, nblock, itype, qutol,\n...     a, b, c, d, omega)",
  "sb10pd": "Normalize system for H-infinity controller design.\n\nReduces D12 and D21 to unit diagonal form and transforms B, C, D11.\n\nParameters:\n  n (int): System order\n  m (int): Number of inputs\n  np (int): Number of outputs\n  ncon (int): Number of control inputs (M2)\n  nmeas (int): Number of measurements (NP2)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  tu (ndarray): Control transform TU (ncon x ncon, F-order, output)\n  ty (ndarray): Measurement transform TY (nmeas x nmeas, F-order, output)\n  tol (float, optional): Tolerance for rank tests. Default sqrt(eps).\n\nReturns:\n  (b, c, d, tu, ty, rcond, info): Transformed matrices, transforms, cond numbers, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb10pd\n>>> n = 2\n>>> m = 4      # m1=2 (disturbance), m2=2 (control)\n>>> np_ = 5    # np1=3 (performance), np2=2 (measurement)\n>>> ncon = 2   # m2\n>>> nmeas = 2  # np2\n>>> m1 = m - ncon    # 2\n>>> m2 = ncon        # 2\n>>> np1 = np_ - nmeas  # 3\n>>> np2 = nmeas        # 2\n>>> a = np.array([\n...     [-1.0, 0.5],\n...     [0.0, -2.0]\n...     ], order='F', dtype=np.float64)\n>>> b = np.array([\n...     [1.0, 0.5, 0.3, 0.2],\n...     [0.0, 0.2, 0.6, 0.4]\n...     ], order='F', dtype=np.float64)\n>>> c = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [0.5, 0.5],\n...     [0.3, 0.7],\n...     [0.2, 0.8]\n...     ], order='F', dtype=np.float64)\n>>> d = np.array([\n...     [0.1, 0.2, 0.0, 0.0],\n...     [0.0, 0.1, 0.0, 1.0],\n...     [0.0, 0.0, 1.0, 0.0],\n...     [1.0, 0.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 0.0]\n...     ], order='F', dtype=np.float64)\n>>> tu = np.zeros((m2, m2), order='F', dtype=np.float64)\n>>> ty = np.zeros((np2, np2), order='F', dtype=np.float64)\n>>> b_out, c_out, d_out, tu_out, ty_out, rcond, info = sb10pd(\n...     n, m, np_, ncon, nmeas, a, b, c, d, tu, ty\n...     )\n>>> info\n0",
  "sb10rd": "Compute H-infinity controller from state feedback and output injection.\n\nComputes controller K = (AK, BK, CK, DK) from state feedback F and\noutput injection H.\n\nParameters:\n  n (int): System order\n  m (int): Number of inputs\n  np (int): Number of outputs\n  ncon (int): Number of control inputs (M2)\n  nmeas (int): Number of measurements (NP2)\n  gamma (float): H-infinity norm bound\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  f (ndarray): State feedback matrix F (m x n, F-order)\n  h (ndarray): Output injection matrix H (n x nmeas, F-order)\n  tu (ndarray): Control transform TU (ncon x ncon, F-order)\n  ty (ndarray): Measurement transform TY (nmeas x nmeas, F-order)\n  x (ndarray): X-Riccati solution (n x n, F-order)\n  y (ndarray): Y-Riccati solution (n x n, F-order)\n\nReturns:\n  (ak, bk, ck, dk, info): Controller matrices and exit code\n\nExamples:\n\n>>> from slicot import sb10rd\n>>> import numpy as np\n>>> n, m, np_, ncon, nmeas = 2, 3, 3, 1, 1\n>>> gamma = 10.0\n>>> a = np.array([[0.5, 0.1], [0.0, 0.4]], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [0.3, 0.2, 1.0],\n...     [0.1, 0.5, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 0.5, 1.0],\n...     [0.5, 0.5, 0.5]\n...     ], dtype=np.float64, order='F')\n>>> d = np.array([\n...     [0.0, 0.0, 0.1],\n...     [0.0, 0.0, 0.1],\n...     [0.1, 0.1, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> f = np.array([\n...     [-0.1, 0.0, 0.0],\n...     [0.0, -0.1, -0.2]\n...     ], dtype=np.float64, order='F')\n>>> h = np.array([\n...     [-0.1, 0.0],\n...     [0.0, -0.1]\n...     ], dtype=np.float64, order='F')\n>>> tu = np.array([[1.0]], dtype=np.float64, order='F')\n>>> ty = np.array([[1.0]], dtype=np.float64, order='F')\n>>> x = np.array([[0.1, 0.0], [0.0, 0.1]], dtype=np.float64, order='F')\n>>> y = np.array([[0.1, 0.0], [0.0, 0.1]], dtype=np.float64, order='F')\n>>> ak, bk, ck, dk, info = slicot.sb10rd(\n...     n, m, np_, ncon, nmeas, gamma,\n...     a, b, c, d, f, h, tu, ty, x, y\n...     )\n>>> info\n0",
  "sb10sd": "H2 optimal controller for normalized discrete-time systems.\n\nComputes the H2 optimal controller K = (AK, BK, CK, DK) for a normalized\ndiscrete-time system obtained from SB10PD. Solves two discrete Riccati\nequations with condition estimates.\n\nParameters:\n  n (int): System order\n  m (int): Number of inputs\n  np (int): Number of outputs\n  ncon (int): Number of control inputs (M2)\n  nmeas (int): Number of measurements (NP2)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  tol (float, optional): Tolerance for singularity tests. Default sqrt(eps).\n\nReturns:\n  (ak, bk, ck, dk, x, y, rcond, info): Controller matrices AK (n x n),\n    BK (n x nmeas), CK (ncon x n), DK (ncon x nmeas), Riccati solutions\n    X and Y (n x n), condition estimates rcond(4), exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb10sd\n>>> n = 2\n>>> m = 4\n>>> np_ = 5\n>>> ncon = 2\n>>> nmeas = 2\n>>> m1 = m - ncon      # 2\n>>> m2 = ncon          # 2\n>>> np1 = np_ - nmeas  # 3\n>>> np2 = nmeas        # 2\n>>> nd1 = np1 - m2     # 1\n>>> nd2 = m1 - np2     # 0\n>>> a = np.array([\n...     [0.5, 0.1],\n...     [0.0, 0.6]\n...     ], order='F', dtype=np.float64)\n>>> b = np.zeros((n, m), order='F', dtype=np.float64)\n>>> b[:, :m1] = np.array([[0.3, 0.1], [0.0, 0.2]])\n>>> b[:, m1:] = np.array([[0.4, 0.0], [0.0, 0.4]])\n>>> c = np.zeros((np_, n), order='F', dtype=np.float64)\n>>> c[:nd1, :] = np.array([[0.2, 0.3]])\n>>> c[nd1:np1, :] = np.array([[0, 0], [0, 0]])\n>>> c[np1:, :] = np.array([[0.5, 0.0], [0.0, 0.5]])\n>>> d = np.zeros((np_, m), order='F', dtype=np.float64)\n>>> d[:nd1, :m1] = np.array([[0.1, 0.05]])\n>>> d[nd1:np1, m1:] = np.array([[1, 0], [0, 1]])\n>>> d[np1:, :m1] = np.array([[1, 0], [0, 1]])\n>>> ak, bk, ck, dk, x, y, rcond, info = sb10sd(\n...     n, m, np_, ncon, nmeas, a, b, c, d\n...     )\n>>> info\n0",
  "sb10td": "Transform H2 controller from normalized to original system.\n\nComputes the H2 optimal discrete-time controller K = (AK, BK, CK, DK)\nfrom the controller for the normalized system (as determined by SB10SD).\n\nApplies the transformations:\n  BKHAT = BK * TY\n  CKHAT = TU * CK\n  DKHAT = TU * DK * TY\n  CK = inv(I + DKHAT*D22) * CKHAT\n  DK = inv(I + DKHAT*D22) * DKHAT\n  AK = AK - BKHAT*D22*CK\n  BK = BKHAT - BKHAT*D22*DK\n\nParameters:\n  n (int): System order\n  m (int): Number of inputs\n  np (int): Number of outputs\n  ncon (int): Number of control inputs (M2)\n  nmeas (int): Number of measurements (NP2)\n  d (ndarray): Feedthrough matrix D (np x m, F-order). Only D22 used.\n  tu (ndarray): Control transform TU (ncon x ncon, F-order)\n  ty (ndarray): Measurement transform TY (nmeas x nmeas, F-order)\n  ak (ndarray): Controller state matrix from SB10SD (n x n, F-order, in/out)\n  bk (ndarray): Controller input matrix from SB10SD (n x nmeas, F-order, in/out)\n  ck (ndarray): Controller output matrix from SB10SD (ncon x n, F-order, in/out)\n  dk (ndarray): Controller feedthrough from SB10SD (ncon x nmeas, F-order, in/out)\n  tol (float, optional): Tolerance for singularity test. Default sqrt(eps).\n\nReturns:\n  (ak, bk, ck, dk, rcond, info): Transformed controller matrices,\n    reciprocal condition number of (I + DKHAT*D22), exit code\n    info=0: success, 1: (I + DKHAT*D22) singular or ill-conditioned\n\nExamples:\n\n>>> from slicot import sb10td\n>>> import numpy as np\n>>> n, m, np_ = 2, 3, 3\n>>> ncon, nmeas = 1, 1\n>>> d = np.zeros((np_, m), dtype=np.float64, order='F')\n>>> d[np_ - nmeas:, m - ncon:] = 0.1\n>>> tu = np.eye(ncon, dtype=np.float64, order='F')\n>>> ty = np.eye(nmeas, dtype=np.float64, order='F')\n>>> ak_in = np.array([[0.5, 0.1], [0.0, 0.4]], dtype=np.float64, order='F')\n>>> bk_in = np.array([[0.2], [0.3]], dtype=np.float64, order='F')\n>>> ck_in = np.array([[0.1, 0.2]], dtype=np.float64, order='F')\n>>> dk_in = np.array([[0.05]], dtype=np.float64, order='F')\n>>> ak, bk, ck, dk, rcond, info = slicot.sb10td(\n...     n, m, np_, ncon, nmeas,\n...     d, tu, ty, ak_in, bk_in, ck_in, dk_in\n...     )\n>>> info\n0",
  "sb10vd": "Compute state feedback and output injection for H2 controller.\n\nSolves X-Riccati and Y-Riccati equations for H2 optimal control.\n\nParameters:\n  ncon (int): Number of control inputs (M2)\n  nmeas (int): Number of measurements (NP2)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n\nReturns:\n  (f, h, x, y, xcond, ycond, info): State feedback F, output injection H,\n    X-Riccati solution, Y-Riccati solution, condition estimates, exit code\n\nExamples:\n\n>>> from slicot import sb10vd\n>>> import numpy as np\n>>> n, m, np_, ncon, nmeas = 6, 5, 5, 2, 2\n>>> a = np.array([\n...     [-1.0, -2.0, -6.0, -8.0,  2.0,  3.0],\n...     [ 0.0,  4.0,  9.0,  4.0,  5.0, -5.0],\n...     [ 4.0, -7.0, -5.0,  7.0,  8.0,  8.0],\n...     [ 5.0, -2.0,  0.0, -1.0, -9.0,  0.0],\n...     [-3.0,  0.0,  2.0, -3.0,  1.0,  2.0],\n...     [-2.0,  3.0, -1.0,  0.0, -4.0, -6.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [-3.0,  2.0, -5.0,  4.0, -3.0,  1.0],\n...     [-4.0,  0.0, -7.0, -6.0,  9.0, -2.0],\n...     [-2.0,  1.0,  0.0,  1.0, -8.0,  3.0],\n...     [ 1.0, -5.0,  7.0,  1.0,  0.0, -6.0],\n...     [ 0.0,  2.0, -2.0, -2.0,  5.0, -2.0]\n...     ], dtype=np.float64, order='F').T\n>>> c = np.array([\n...     [ 1.0, -3.0, -7.0,  9.0,  0.0],\n...     [-1.0,  0.0,  5.0, -3.0,  1.0],\n...     [ 2.0,  5.0,  0.0,  4.0, -2.0],\n...     [-4.0, -1.0, -8.0,  0.0,  1.0],\n...     [ 0.0,  1.0,  2.0,  3.0, -6.0],\n...     [-3.0,  1.0, -2.0,  7.0, -2.0]\n...     ], dtype=np.float64, order='F').T\n>>> f, h, x, y, xcond, ycond, info = slicot.sb10vd(ncon, nmeas, a, b, c)\n>>> info\n0",
  "sb10wd": "Compute H2 optimal controller from state feedback and output injection.\n\nComputes controller K = (AK, BK, CK, DK) from state feedback F and\noutput injection H as determined by SB10VD.\n\nFormulas:\n  AK = A + H*C2 + B2*F + H*D22*F\n  BK = -H*TY\n  CK = TU*F\n  DK = 0\n\nParameters:\n  n (int): System order\n  m (int): Number of inputs\n  np (int): Number of outputs\n  ncon (int): Number of control inputs (M2)\n  nmeas (int): Number of measurements (NP2)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (np x n, F-order)\n  d (ndarray): Feedthrough matrix D (np x m, F-order)\n  f (ndarray): State feedback matrix F (ncon x n, F-order)\n  h (ndarray): Output injection matrix H (n x nmeas, F-order)\n  tu (ndarray): Control transform TU (ncon x ncon, F-order)\n  ty (ndarray): Measurement transform TY (nmeas x nmeas, F-order)\n\nReturns:\n  (ak, bk, ck, dk, info): Controller matrices and exit code\n\nExamples:\n\n>>> from slicot import sb10wd\n>>> import numpy as np\n>>> n = 2      # State order\n>>> m = 2      # Total inputs (M1 + M2)\n>>> np_ = 2    # Total outputs (NP1 + NP2)\n>>> ncon = 1   # Control inputs (M2)\n>>> nmeas = 1  # Measurements (NP2)\n>>> m1 = m - ncon      # = 1\n>>> m2 = ncon          # = 1\n>>> np1 = np_ - nmeas  # = 1\n>>> np2 = nmeas        # = 1\n>>> A = np.array([[-1.0, 0.5],\n...     [0.0, -2.0]], order='F', dtype=float)\n>>> B = np.array([[1.0, 0.5],\n...     [0.0, 1.0]], order='F', dtype=float)\n>>> C = np.array([[1.0, 0.0],\n...     [0.5, 1.0]], order='F', dtype=float)\n>>> D = np.array([[0.0, 0.1],\n...     [0.0, 0.2]], order='F', dtype=float)\n>>> F = np.array([[-0.5, -0.3]], order='F', dtype=float)\n>>> H = np.array([[0.4],\n...     [0.6]], order='F', dtype=float)\n>>> TU = np.array([[1.0]], order='F', dtype=float)\n>>> TY = np.array([[1.0]], order='F', dtype=float)\n>>> B2 = B[:, m1:m]\n>>> C2 = C[np1:np_, :]\n>>> D22 = D[np1:np_, m1:m]\n>>> AK, BK, CK, DK, info = sb10wd(\n...     n, m, np_, ncon, nmeas,\n...     A, B, C, D, F, H, TU, TY\n...     )\n>>> info\n0",
  "sb10yd": "SB10YD: Frequency response fitting\n\nExamples:\n\n>>> from slicot import sb10yd\n>>> import numpy as np\n>>> n_points = 100\n>>> omega = np.linspace(0.1, 10.0, n_points)\n>>> rfrdat = np.zeros(n_points, dtype=float)\n>>> ifrdat = np.zeros(n_points, dtype=float)\n...     w = omega[i]\n...     denom = 1.0 + w * w\n...     rfrdat[i] = 1.0 / denom\n...     ifrdat[i] = -w / denom\n>>> n = 1\n>>> discfl = 0  # Continuous\n>>> flag = 1    # Stable minimum phase\n>>> tol = 0.0\n>>> A, B, C, D, N_out, info = sb10yd(discfl, flag, n, rfrdat, ifrdat, omega, tol)\n>>> self.assertEqual(info, 0)\n>>> self.assertEqual(N_out, 1)\n>>> eig_a = np.linalg.eigvals(A)\n>>> self.assertTrue(np.all(np.real(eig_a) < 0), \"A should be stable (negative eigenvalues)\")\n...     s = 1j * w_test\n...     resolvent = np.linalg.inv(s * np.eye(N_out) - A)\n...     h_val = C @ resolvent @ B + D\n...     expected = 1.0 / (1.0 + 1j * w_test)\n>>> info\n0",
  "sb10zd": "Positive feedback controller for discrete-time system (D != 0).\n\nComputes the matrices of the positive feedback controller\nK = [Ak, Bk; Ck, Dk] for the shaped plant G = [A, B; C, D]\nin the Discrete-Time Loop Shaping Design Procedure.\n\nParameters:\n  n (int): Order of the plant (N >= 0)\n  m (int): Column size of matrix B (M >= 0)\n  np (int): Row size of matrix C (NP >= 0)\n  a (ndarray): N-by-N system state matrix (F-order)\n  b (ndarray): N-by-M system input matrix (F-order)\n  c (ndarray): NP-by-N system output matrix (F-order)\n  d (ndarray): NP-by-M feedthrough matrix (F-order)\n  factor (float): Performance factor (=1 optimal, >1 suboptimal)\n  tol (float): Tolerance for singularity tests (<=0 uses sqrt(eps))\n\nReturns:\n  (ak, bk, ck, dk, rcond, info): Controller matrices (N-by-N, N-by-NP,\n    M-by-N, M-by-NP), array of 6 reciprocal condition numbers, and exit code.\n    info: 0=success, 1-2=Riccati failed, 3=iteration failed,\n    4-9=singular matrices, 10=closed-loop unstable\n\nExamples:\n\n>>> from slicot import sb10zd\n>>> import numpy as np\n>>> n = 6\n>>> m = 2\n>>> np_ = 3\n>>> factor = 1.1\n>>> tol = 0.0\n>>> A = np.array([\n...     [ 0.2,  0.0,  3.0,  0.0, -0.3, -0.1],\n...     [-3.0,  0.2, -0.4, -0.3,  0.0,  0.0],\n...     [-0.1,  0.1, -1.0,  0.0,  0.0, -3.0],\n...     [ 1.0,  0.0,  0.0, -1.0, -1.0,  0.0],\n...     [ 0.0,  0.3,  0.6,  2.0,  0.1, -0.4],\n...     [ 0.2, -4.0,  0.0,  0.0,  0.2, -2.0]\n...     ], dtype=float, order='F')\n>>> B = np.array([\n...     [-1.0, -2.0],\n...     [ 1.0,  3.0],\n...     [-3.0, -4.0],\n...     [ 1.0, -2.0],\n...     [ 0.0,  1.0],\n...     [ 1.0,  5.0]\n...     ], dtype=float, order='F')\n>>> C = np.array([\n...     [ 1.0, -1.0,  2.0, -2.0,  0.0, -3.0],\n...     [-3.0,  0.0,  1.0, -1.0,  1.0, -1.0],\n...     [ 2.0,  4.0, -3.0,  0.0,  5.0,  1.0]\n...     ], dtype=float, order='F')\n>>> D = np.array([\n...     [10.0, -6.0],\n...     [-7.0,  8.0],\n...     [ 2.0, -4.0]\n...     ], dtype=float, order='F')\n>>> result = slicot.sb10zd(n, m, np_, A, B, C, D, factor, tol)\n>>> ak, bk, ck, dk, rcond, info = result",
  "sb10zp": "Transform SISO system to stable and minimum phase.\n\nComputes a stable and minimum phase SISO system (Ao,Bo,Co,Do) from\na given SISO system (A,B,C,D). Unstable poles and zeros in the\nright half-plane (continuous) or outside unit circle (discrete)\nare reflected to stable locations.\n\nParameters:\n  discfl (int): 0 = continuous-time, 1 = discrete-time\n  a (ndarray): N-by-N state matrix (F-order)\n  b (ndarray): N input vector (F-order)\n  c (ndarray): N output vector (F-order)\n  d (ndarray): Scalar feedthrough (1-element array)\n\nReturns:\n  (a, b, c, d, n, info): Transformed system matrices, final order,\n    and exit code (0=success, <0=param error, >0=algorithm error)\n\nExamples:\n\n>>> from slicot import sb10zp\n>>> import numpy as np\n>>> a = np.array([[2.0, 1.0], [0.0, -1.0]], order='F', dtype=float)\n>>> b = np.array([1.0, 0.0], order='F', dtype=float)\n>>> c = np.array([1.0, 1.0], order='F', dtype=float)\n>>> d = np.array([2.0], order='F', dtype=float)\n>>> discfl = 0\n>>> a_out, b_out, c_out, d_out, n_out, info = sb10zp(discfl, a, b, c, d)\n...     err_msg=\"D should be preserved\")\n...     eigs = np.linalg.eigvals(a_out[:n_out, :n_out])\n>>> info\n0",
  "sb16ad": "Frequency-weighted controller reduction via balancing.\n\nComputes a reduced order controller (Acr,Bcr,Ccr,Dcr) for an original\nstate-space controller (Ac,Bc,Cc,Dc) using frequency-weighted B&T or SPA.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  jobc (str): 'S' Enns', 'E' enhanced controllability Grammian\n  jobo (str): 'S' Enns', 'E' enhanced observability Grammian\n  jobmr (str): 'B' sqrt B&T, 'F' bal-free B&T, 'S' sqrt SPA, 'P' bal-free SPA\n  weight (str): 'N' none, 'O' output, 'I' input, 'P' performance weighting\n  equil (str): 'S' scale, 'N' no scaling\n  ordsel (str): 'F' fixed order NCR, 'A' automatic selection\n  n (int): Order of open-loop system (>= 0)\n  m (int): Number of inputs (>= 0)\n  p (int): Number of outputs (>= 0)\n  nc (int): Order of controller (>= 0)\n  ncr (int): Desired reduced order (ORDSEL='F')\n  alpha (float): Stability boundary\n  a (ndarray): N-by-N open-loop state matrix (F-order)\n  b (ndarray): N-by-M open-loop input matrix (F-order)\n  c (ndarray): P-by-N open-loop output matrix (F-order)\n  d (ndarray): P-by-M open-loop feedthrough matrix (F-order)\n  ac (ndarray): NC-by-NC controller state matrix (F-order)\n  bc (ndarray): NC-by-P controller input matrix (F-order)\n  cc (ndarray): M-by-NC controller output matrix (F-order)\n  dc (ndarray): M-by-P controller feedthrough matrix (F-order)\n  tol1 (float): Tolerance for order selection (ORDSEL='A')\n  tol2 (float): Tolerance for minimal realization\n\nReturns:\n  (acr, bcr, ccr, dcr, ncr_out, ncs, hsvc, iwarn, info): Reduced controller,\n    actual order, stable part order, Hankel SVs, warning, exit code.\n    info: 0=success, 1-7=algorithm errors\n\nExamples:\n\n>>> from slicot import sb16ad\n>>> import numpy as np\n>>> n, m, p = 3, 1, 1\n>>> a = np.array([\n...     [-1.0, 0.0, 4.0],\n...     [0.0, 2.0, 0.0],\n...     [0.0, 0.0, -3.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [1.0],\n...     [1.0],\n...     [1.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([[1.0, 1.0, 1.0]], dtype=float, order='F')\n>>> d = np.array([[0.0]], dtype=float, order='F')\n>>> nc = 3\n>>> ac = np.array([\n...     [-26.4000, 6.4023, 4.3868],\n...     [32.0000, 0.0, 0.0],\n...     [0.0, 8.0000, 0.0]\n...     ], dtype=float, order='F')\n>>> bc = np.array([\n...     [-16.0],\n...     [0.0],\n...     [0.0]\n...     ], dtype=float, order='F')\n>>> cc = np.array([[9.2994, 1.1624, 0.1090]], dtype=float, order='F')\n>>> dc = np.array([[0.0]], dtype=float, order='F')\n>>> ncr = 2\n>>> alpha = 0.0\n>>> tol1 = 0.1\n>>> tol2 = 0.0\n>>> (acr, bcr, ccr, dcr, ncr_out, ncs, hsvc, iwarn, info) = sb16ad(\n...     dico='C',\n...     jobc='S',\n...     jobo='S',\n...     jobmr='F',\n...     weight='I',\n...     equil='N',\n...     ordsel='F',\n...     n=n,\n...     m=m,\n...     p=p,\n...     nc=nc,\n...     ncr=ncr,\n...     alpha=alpha,\n...     a=a,\n...     b=b,\n...     c=c,\n...     d=d,\n...     ac=ac,\n...     bc=bc,\n...     cc=cc,\n...     dc=dc,\n...     tol1=tol1,\n...     tol2=tol2\n...     )",
  "sb16bd": "Coprime factorization based state feedback controller reduction.\n\nComputes a reduced order controller (Ac,Bc,Cc,Dc) for a given open-loop\nmodel (A,B,C,D) with state feedback gain F and observer gain G using\ncoprime factorization based model reduction methods (B&T or SPA).\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  jobd (str): 'D' D matrix present, 'Z' D is zero\n  jobmr (str): 'B' sqrt B&T, 'F' bal-free B&T, 'S' sqrt SPA, 'P' bal-free SPA\n  jobcf (str): 'L' left coprime, 'R' right coprime factorization\n  equil (str): 'S' perform scaling, 'N' no scaling\n  ordsel (str): 'F' fixed order NCR, 'A' automatic order selection\n  n (int): Order of open-loop system (>= 0)\n  m (int): Number of inputs (>= 0)\n  p (int): Number of outputs (>= 0)\n  ncr (int): Desired controller order (0 <= NCR <= N, for ORDSEL='F')\n  a (ndarray): N-by-N state matrix (F-order)\n  b (ndarray): N-by-M input matrix (F-order)\n  c (ndarray): P-by-N output matrix (F-order)\n  d (ndarray): P-by-M feedthrough matrix (F-order)\n  f (ndarray): M-by-N state feedback gain (F-order)\n  g (ndarray): N-by-P observer gain (F-order)\n  tol1 (float): Tolerance for order selection (ORDSEL='A'), 0 = default\n  tol2 (float): Tolerance for minimal realization, 0 = default\n\nReturns:\n  (ac, bc, cc, dc, hsv, ncr, iwarn, info): Reduced controller matrices,\n    Hankel singular values, actual controller order, warning flag, exit code.\n    info=0: success, 1: Schur of A+GC failed, 2: A+GC not stable,\n    3: HSV computation failed, 4: Schur of A+BF failed, 5: A+BF not stable.\n\nExamples:\n\n>>> from slicot import sb16bd\n>>> import numpy as np\n>>> n, m, p = 8, 1, 1\n>>> ncr_desired = 4\n>>> a = np.array([\n...     [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, -0.015, 0.765, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, -0.765, -0.015, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, -0.028, 1.41, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, -1.41, -0.028, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.04, 1.85],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.85, -0.04]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [0.026],\n...     [-0.251],\n...     [0.033],\n...     [-0.886],\n...     [-4.017],\n...     [0.145],\n...     [3.604],\n...     [0.28]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [-0.996, -0.105, 0.261, 0.009, -0.001, -0.043, 0.002, -0.026]\n...     ], dtype=float, order='F')\n>>> d = np.array([[0.0]], dtype=float, order='F')\n>>> f = np.array([\n...     [4.4721e-002, 6.6105e-001, 4.6986e-003, 3.6014e-001,\n...     1.0325e-001, -3.7541e-002, -4.2685e-002, 3.2873e-002]\n...     ], dtype=float, order='F')\n>>> g = np.array([\n...     [4.1089e-001],\n...     [8.6846e-002],\n...     [3.8523e-004],\n...     [-3.6194e-003],\n...     [-8.8037e-003],\n...     [8.4205e-003],\n...     [1.2349e-003],\n...     [4.2632e-003]\n...     ], dtype=float, order='F')\n>>> ac, bc, cc, dc, hsv, ncr_out, iwarn, info = sb16bd(\n...     'C', 'D', 'F', 'L', 'S', 'F', n, m, p, ncr_desired,\n...     a, b, c, d, f, g, 0.1, 0.0\n...     )\n>>> eig_actual = np.sort(np.linalg.eigvals(ac))\n>>> def transfer_function(ac_mat, bc_mat, cc_mat, dc_mat, s):\n...     n = ac_mat.shape[0]\n...     return cc_mat @ np.linalg.solve(s * np.eye(n) - ac_mat, bc_mat) + dc_mat\n...     s = 1j * omega\n...     tf_actual = transfer_function(ac, bc, cc, dc, s)\n>>> info\n0",
  "sb16cd": "Frequency-weighted coprime factorization controller reduction.\n\nComputes reduced order controller (Ac,Bc,Cc) for open-loop model (A,B,C,D)\nwith state feedback gain F and observer gain G using coprime factorization\nwith frequency-weighted B&T model reduction.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  jobd (str): 'D' D matrix present, 'Z' D is zero\n  jobmr (str): 'B' sqrt B&T, 'F' balancing-free sqrt B&T\n  jobcf (str): 'L' left coprime, 'R' right coprime factorization\n  ordsel (str): 'F' fixed order NCR, 'A' automatic order selection\n  a (ndarray): N-by-N state matrix (F-order)\n  b (ndarray): N-by-M input matrix (F-order)\n  c (ndarray): P-by-N output matrix (F-order)\n  d (ndarray): P-by-M feedthrough matrix (F-order)\n  f (ndarray): M-by-N state feedback gain (F-order)\n  g (ndarray): N-by-P observer gain (F-order)\n  ncr (int): Desired controller order (0 <= NCR <= N, for ORDSEL='F')\n  tol (float): Tolerance for order selection (ORDSEL='A'), <=0 = default\n\nReturns:\n  (ac, bc, cc, hsv, ncr, iwarn, info): Reduced controller matrices Ac, Bc, Cc\n    (in modified a, g, f), Hankel singular values, actual order, warning, exit code.\n    iwarn=1: NCR > minimal order, =2: repeated singular values at cutoff.\n    info=0: success, 1: eigenvalue failure, 2: A+GC unstable, 3: A+BF unstable,\n    4: obs Lyapunov singular, 5: ctrl Lyapunov singular, 6: HSV computation failed.\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sb16cd\n>>> n, m, p = 8, 1, 1\n>>> ncr_in = 2\n>>> tol = 0.1\n>>> a = np.array([\n...     [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, -0.015, 0.765, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, -0.765, -0.015, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, -0.028, 1.41, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, -1.41, -0.028, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.04, 1.85],\n...     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.85, -0.04]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.026],\n...     [-0.251],\n...     [0.033],\n...     [-0.886],\n...     [-4.017],\n...     [0.145],\n...     [3.604],\n...     [0.280]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [-0.996, -0.105, 0.261, 0.009, -0.001, -0.043, 0.002, -0.026]\n...     ], order='F', dtype=float)\n>>> d = np.array([[0.0]], order='F', dtype=float)\n>>> f = np.array([\n...     [4.472135954999638e-002, 6.610515358414598e-001,\n...     4.698598960657579e-003, 3.601363251422058e-001,\n...     1.032530880771415e-001, -3.754055214487997e-002,\n...     -4.268536964759344e-002, 3.287284547842979e-002]\n...     ], order='F', dtype=float)\n>>> g = np.array([\n...     [4.108939884667451e-001],\n...     [8.684600000000012e-002],\n...     [3.852317308197148e-004],\n...     [-3.619366874815911e-003],\n...     [-8.803722876359955e-003],\n...     [8.420521094001852e-003],\n...     [1.234944428038507e-003],\n...     [4.263205617645322e-003]\n...     ], order='F', dtype=float)\n>>> ac, bc, cc, hsv, ncr, iwarn, info = sb16cd(\n...     'C', 'D', 'F', 'R', 'F',\n...     a, b, c, d, f, g, ncr_in, tol\n...     )\n>>> info\n0",
  "sb16cy": "Cholesky factors of Grammians for coprime factors of controller.\n\nComputes Cholesky factors Su and Ru of controllability Grammian P=Su*Su'\nand observability Grammian Q=Ru'*Ru for frequency-weighted model reduction\nof coprime factors of state-feedback controller.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  jobcf (str): 'L' left coprime, 'R' right coprime factorization\n  n (int): Order of open-loop system (>= 0)\n  m (int): Number of inputs (>= 0)\n  p (int): Number of outputs (>= 0)\n  a (ndarray): N-by-N state matrix (F-order)\n  b (ndarray): N-by-M input matrix (F-order)\n  c (ndarray): P-by-N output matrix (F-order)\n  f (ndarray): M-by-N state feedback gain (F-order)\n  g (ndarray): N-by-P observer gain (F-order)\n\nReturns:\n  (s, r, scalec, scaleo, info): Cholesky factors S and R,\n    scaling factors, and exit code.\n    info=0: success, 1: eigenvalue computation failed,\n    2: A+GC not stable, 3: A+BF not stable,\n    4: observability Lyapunov singular, 5: controllability Lyapunov singular.\n\nExamples:\n\n>>> from slicot import sb16cy\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> A = np.array([\n...     [-2.0, 0.0, 0.0],\n...     [0.0, -3.0, 0.0],\n...     [0.0, 0.0, -4.0]\n...     ], order='F', dtype=float)\n>>> B = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> C = np.array([\n...     [1.0, 1.0, 0.0],\n...     [0.0, 1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> F = np.array([\n...     [-1.0, 0.5, 0.0],\n...     [0.0, -0.5, 0.3]\n...     ], order='F', dtype=float)\n>>> G = np.array([\n...     [0.5, -0.2],\n...     [-0.3, 0.4],\n...     [0.1, -0.1]\n...     ], order='F', dtype=float)\n>>> Acl_bf = A + B @ F\n>>> Acl_gc = A + G @ C\n>>> eig_bf = np.linalg.eigvals(Acl_bf)\n>>> eig_gc = np.linalg.eigvals(Acl_gc)\n>>> S, R, scalec, scaleo, info = sb16cy('C', 'L', n, m, p, A, B, C, F, G)\n>>> P = S @ S.T\n>>> Q = R.T @ R\n>>> res_P = Acl_bf @ P + P @ Acl_bf.T + scalec**2 * (B @ B.T)\n>>> res_Q = Acl_gc.T @ Q + Q @ Acl_gc + scaleo**2 * (F.T @ F)\n>>> info\n0",
  "sg02ad": "Solve generalized algebraic Riccati equation for descriptor systems.\n\nSolves for X either:\n  Continuous: Q + A'XE + E'XA - (L+E'XB)R^(-1)(L+E'XB)' = 0\n  Discrete:   E'XE = A'XA - (L+A'XB)(R+B'XB)^(-1)(L+A'XB)' + Q\n\nUses deflating subspaces with generalized Schur decomposition.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  jobb (str): 'B' matrices B,R given, 'G' matrix G given\n  fact (str): 'N' Q,R given, 'C' Q=C'C, 'D' R=D'D, 'B' both factored\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  jobl (str): 'Z' L is zero, 'N' L is nonzero\n  scal (str): 'G' use scaling, 'N' no scaling\n  sort (str): 'S' stable eigenvalues first, 'U' unstable first\n  acc (str): 'R' iterative refinement, 'N' no refinement\n  n (int): State dimension (>= 0)\n  m (int): Number of inputs (>= 0, for JOBB='B')\n  p (int): Number of outputs (for FACT='C','D','B')\n  a (ndarray): N-by-N state matrix A (F-order)\n  e (ndarray): N-by-N descriptor matrix E (F-order)\n  b (ndarray): N-by-M input matrix B (F-order)\n  q (ndarray): Weighting matrix Q or C (F-order)\n  r (ndarray): Weighting matrix R or D (F-order)\n  l (ndarray): Cross-weighting L (F-order)\n  tol (float): Tolerance (<=0 uses eps)\n\nReturns:\n  (x, rcondu, alfar, alfai, beta, s, t, u, iwarn, info)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sg02ad\n>>> n = 2\n>>> m = 1\n>>> p = 3\n>>> a = np.array([\n...     [0.0, 1.0],\n...     [0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0],\n...     [1.0]\n...     ], order='F', dtype=float)\n>>> q = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> r = np.array([\n...     [0.0],\n...     [0.0],\n...     [1.0]\n...     ], order='F', dtype=float)\n>>> l = np.zeros((n, m), order='F', dtype=float)\n>>> result = sg02ad(\n...     'C', 'B', 'B', 'U', 'Z', 'N', 'S', 'N',\n...     n, m, p,\n...     a.copy(order='F'),\n...     e.copy(order='F'),\n...     b.copy(order='F'),\n...     q.copy(order='F'),\n...     r.copy(order='F'),\n...     l.copy(order='F'),\n...     0.0\n...     )\n>>> x, rcondu, alfar, alfai, beta, s, t, u, iwarn, info = result",
  "sg02cv": "Compute residual matrix for Lyapunov equation.\n\nComputes residual matrix R for continuous or discrete-time Lyapunov equations:\n  Continuous (JOBE='I'): R = op(A)'*X + X*op(A) + Q\n  Continuous (JOBE='G'): R = op(A)'*X*op(E) + op(E)'*X*op(A) + Q\n  Discrete   (JOBE='I'): R = op(A)'*X*op(A) - X + Q\n  Discrete   (JOBE='G'): R = op(A)'*X*op(A) - op(E)'*X*op(E) + Q\n\nwhere X and Q are symmetric, A is upper real Schur, E is upper triangular.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  job (str): 'R' residual only, 'N' or 'B' residual and norms\n  jobe (str): 'G' general E, 'I' identity E (E not referenced)\n  uplo (str): 'U' upper triangular, 'L' lower triangular\n  trans (str): 'N' for op(W)=W, 'T' or 'C' for op(W)=W'\n  a (ndarray): N-by-N upper real Schur matrix (F-order)\n  e (ndarray or None): N-by-N upper triangular E (if jobe='G')\n  x (ndarray): N-by-N symmetric matrix X (F-order)\n  r (ndarray): N-by-N matrix Q on entry, R on exit (F-order)\n\nReturns:\n  (r, norms, info): Residual matrix R, Frobenius norms array, exit code.\n    norms[0] = ||op(A)'*X*op(A)|| or ||op(A)'*X*op(E)|| depending on equation.\n    norms[1] = ||op(E)'*X*op(E)|| (discrete, JOBE='G' only).\n    info=0: success, <0: parameter error.\n\nExamples:\n\n>>> from slicot import sg02cv\n>>> import numpy as np\n>>> n = 3\n>>> a = make_schur_form(n, 42)\n>>> x = make_symmetric(n, 43)\n>>> q = make_symmetric(n, 44)\n>>> r_in = np.triu(q.copy()).astype(float, order='F')\n>>> x_in = np.asfortranarray(x.copy())\n>>> r_out, norms, info = sg02cv('C', 'R', 'I', 'U', 'N', a, None, x_in, r_in)\n>>> info\n0",
  "sg02cw": "Compute residual matrix for Riccati equation with line search.\n\nEvaluates the residual matrix R for the generalized continuous-time or\ndiscrete-time algebraic Riccati equation with optional computation of the\nclosed-loop system matrix C and norms. Supports multiple matrix product forms.\n\nFor continuous-time (DICO='C'):\n  R = op(A)'*X*op(E) + op(E)'*X*op(A) +/- op(E)'*X*G*X*op(E) + Q\n\nFor discrete-time (DICO='D'):\n  R = op(A)'*X*op(A) - op(E)'*X*op(E) +/- op(E)'*X*G*X*op(E) + Q\n\nwhere X is symmetric and the +/- depends on FLAG parameter.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  job (str): 'R' residual only, 'A' residual and closed-loop C,\n             'N' norms only, 'B' residual and norms\n  jobe (str): 'G' general E, 'I' identity E\n  flag (str): 'M' minus sign, 'P' plus sign in X*G*X term\n  jobg (str): 'G' use G directly, 'D' G = B*R^(-1)*B',\n              'F' G = F'*R*F, 'H' G = (K-F)*R^(-1)*(K-F)',\n              'K' G = K'*R^(-1)*K\n  uplo (str): 'U' upper triangular, 'L' lower triangular\n  trans (str): 'N' for op(M)=M, 'T' or 'C' for op(M)=M'\n  n (int): State dimension (>= 0)\n  m (int): Number of control inputs (>= 0)\n  a (ndarray): N-by-N state matrix (F-order)\n  e (ndarray or None): N-by-N descriptor matrix (if jobe='G')\n  g (ndarray): N-by-N or N-by-M matrix G or B (F-order)\n  x (ndarray): N-by-N symmetric matrix X (F-order)\n  f (ndarray or None): M-by-N matrix F (if jobg='F')\n  k (ndarray or None): M-by-N matrix K (if jobg='H' or 'K')\n  xe (ndarray or None): N-by-N matrix X*E (discrete, jobe='G')\n  q (ndarray): N-by-N matrix Q on entry, R on exit (F-order)\n\nReturns:\n  (r, c, norms, info): Residual R, closed-loop C, norms array, exit code.\n    c[i,j] = (A - G*X)[i,j] for continuous, (A - G*X*E^(-1)*A)[i,j] for discrete.\n    norms[0] = ||R_low||_F / ||R_high||_F (residual / matrix norm).\n    norms[1] = ||op(A)'*X*op(E)|| for continuous.\n    info=0: success, <0: parameter error.\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sg02cw\n>>> n = 3\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0],\n...     [ 0.0, -2.0,  0.0],\n...     [ 0.0,  0.0, -3.0]\n...     ], order='F', dtype=float)\n>>> g = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> q = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> x = np.array([\n...     [np.sqrt(2) - 1, 0.0, 0.0],\n...     [0.0, np.sqrt(5) - 2, 0.0],\n...     [0.0, 0.0, np.sqrt(10) - 3]\n...     ], order='F', dtype=float)\n>>> r, c, norms, info = sg02cw(\n...     dico='C', job='A', jobe='I', flag='M', jobg='G',\n...     uplo='U', trans='N',\n...     n=n, m=0,\n...     a=a.copy(), e=None, g=g.copy(), x=x.copy(),\n...     f=None, k=None, xe=None, q=q.copy()\n...     )\n>>> r_full = np.triu(r) + np.triu(r, 1).T\n>>> info\n0",
  "sg02cx": "Find line search parameter minimizing Riccati residual norm.\n\nFinds alpha minimizing ||R(X + alpha*S)||_F where R(X) is the residual\nof a (generalized) continuous-time algebraic Riccati equation.\n\nThe function evaluates P(alpha) = ||(1-alpha)*R(X) +/- alpha^2*V||_F\nwhere V = op(E)'*S*G*S*op(E) and S is the Newton step.\n\nAlgorithm: Sets up a cubic polynomial P'(alpha) = 0 to find critical\npoints, then solves a 3x3 generalized eigenproblem via MC01XD.\n\nParameters:\n  jobe (str): 'G' general E matrix, 'I' identity E\n  flag (str): 'P' plus sign, 'M' minus sign in residual formula\n  jobg (str): 'G' G given, 'D' D given (G=D*D'),\n              'F' F given (V=F*F'), 'H' H,K given (V=H*K)\n  uplo (str): 'U' upper triangle, 'L' lower triangle stored\n  trans (str): 'N' op(W)=W, 'T'/'C' op(W)=W'\n  n (int): Order of matrices E, R, S (>= 0)\n  m (int): Columns in D/F/K' (>= 0 if jobg != 'G')\n  e (ndarray): N-by-N matrix E (if jobe='G' and jobg='G' or 'D')\n  r (ndarray): N-by-N symmetric residual R(X)\n  s (ndarray): Newton step S; N-by-N symmetric if jobg='G'/'D'\n  g (ndarray): Matrix G/D/F/H depending on jobg\n\nReturns:\n  (alpha, rnorm, iwarn, info): Optimal alpha in [0,2], residual norm,\n    warning code (2 = no optimum in [0,2]), exit code.\n    info=0: success, <0: parameter error, 1: eigenproblem failed.\n\nExamples:\n\n>>> from slicot import sg02cx\n>>> import numpy as np\n>>> n = 2\n>>> r = np.array([\n...     [1.0, 0.5],\n...     [0.5, 2.0]\n...     ], order='F', dtype=float)\n>>> s = np.array([\n...     [0.3, 0.1],\n...     [0.1, 0.4]\n...     ], order='F', dtype=float)\n>>> g = np.array([\n...     [0.5, 0.2],\n...     [0.2, 0.8]\n...     ], order='F', dtype=float)\n>>> alpha, rnorm, iwarn, info = sg02cx(\n...     jobe='I', flag='P', jobg='G', uplo='U', trans='N',\n...     n=n, m=0, e=np.empty((1, 1), order='F'), r=r, s=s, g=g\n...     )\n>>> info\n0",
  "sg02nd": "Compute optimal gain matrix for discrete/continuous Riccati problems.\n\nComputes the optimal gain matrix K for optimal control:\n\nDiscrete-time:   K = (R + B'XB)^{-1} (B'X*op(A) + L')\nContinuous-time: K = R^{-1} (B'X*op(E) + L')\n\nwhere X is the solution of the corresponding algebraic Riccati equation.\n\nR may be given in factored form. Optionally returns H = op(A)'XB + L\n(discrete) or H = op(E)'XB + L (continuous), or F where FC = H.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  jobe (str): 'G' general E matrix, 'I' identity E (only for DICO='C')\n  job (str): 'K' K only, 'H' H and K, 'F' F if possible else H and K,\n             'D'/'C' with pre-transformed B,L\n  jobx (str): 'C' compute X*E or X*A, 'N' do not compute\n  fact (str): 'N' R not factored, 'D' R=D'D, 'C' Cholesky, 'U' UdU'/LdL'\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  jobl (str): 'Z' L is zero, 'N' L is nonzero\n  trans (str): 'N' op(W)=W, 'T'/'C' op(W)=W'\n  n (int): Order of A and X (>= 0)\n  m (int): Order of R and columns of B,L (>= 0)\n  p (int): Rows of D (relevant for FACT='D')\n  a (ndarray): N-by-N state matrix A (for DICO='D')\n  e (ndarray): N-by-N matrix E (for DICO='C', JOBE='G')\n  b (ndarray): N-by-M input matrix B\n  r (ndarray): M-by-M matrix R (factored or not)\n  ipiv (ndarray): Pivot indices (for FACT='U')\n  l (ndarray): N-by-M cross-weighting L (for JOBL='N')\n  x (ndarray): N-by-N solution matrix X\n  rnorm (float): 1-norm of R (for FACT='U')\n\nReturns:\n  (k, h, xe, oufact, rcond, info): M-by-N gain K, N-by-M matrix H or F,\n    N-by-N product X*E or X*A, factorization info [2], reciprocal\n    condition number, exit code.\n    info=0: success, <0: parameter error, i: d[i]=0, m+1: singular,\n    m+2: eigenvalue failure, m+3: X indefinite.\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sg02nd\n>>> n = 2\n>>> m = 1\n>>> p = 3\n>>> a = np.array([\n...     [2.0, -1.0],\n...     [1.0,  0.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0],\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> r = np.array([\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> x = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> k, h, xe, oufact, rcond, info = sg02nd(\n...     dico='D', jobe='I', job='K', jobx='N', fact='N',\n...     uplo='U', jobl='Z', trans='N',\n...     n=n, m=m, p=p,\n...     a=a.copy(order='F'),\n...     e=np.zeros((1, 1), order='F', dtype=float),\n...     b=b.copy(order='F'),\n...     r=r.copy(order='F'),\n...     ipiv=np.zeros(m, dtype=np.int32),\n...     l=np.zeros((1, 1), order='F', dtype=float),\n...     x=x.copy(order='F'),\n...     rnorm=0.0\n...     )\n>>> info\n0",
  "sg03ad": "Solve generalized Lyapunov equation for descriptor systems.\n\nSolves for X either:\n  Continuous: op(A)'*X*op(E) + op(E)'*X*op(A) = scale*Y\n  Discrete:   op(A)'*X*op(A) - op(E)'*X*op(E) = scale*Y\n\nwhere op(M) = M or M^T and Y is symmetric.\n\nParameters:\n  dico (str): 'C' continuous-time, 'D' discrete-time\n  job (str): 'X' solution only, 'S' separation only, 'B' both\n  fact (str): 'N' factorization needed, 'F' factorization supplied\n  trans (str): 'N' op(M)=M, 'T' op(M)=M^T\n  uplo (str): 'U' upper triangle, 'L' lower triangle\n  n (int): Order of matrices (>= 0)\n  a (ndarray): N-by-N matrix A (F-order)\n  e (ndarray): N-by-N matrix E (F-order)\n  x (ndarray): N-by-N RHS matrix Y (F-order)\n  q (ndarray, optional): Orthogonal Q (if FACT='F')\n  z (ndarray, optional): Orthogonal Z (if FACT='F')\n\nReturns:\n  (x, scale, sep, ferr, alphar, alphai, beta, a, e, q, z, info)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sg03ad\n>>> n = 3\n>>> a = np.array([\n...     [3.0, 1.0, 1.0],\n...     [1.0, 3.0, 0.0],\n...     [1.0, 0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 3.0, 0.0],\n...     [3.0, 2.0, 1.0],\n...     [1.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> x = np.array([\n...     [-64.0, -73.0, -28.0],\n...     [  0.0, -70.0, -25.0],\n...     [  0.0,   0.0, -18.0]\n...     ], order='F', dtype=float)\n>>> result = sg03ad(\n...     'C', 'B', 'N', 'N', 'U', n,\n...     a.copy(order='F'),\n...     e.copy(order='F'),\n...     x.copy(order='F')\n...     )\n>>> x_out, scale, sep, ferr, alphar, alphai, beta, a_out, e_out, q, z, info = result",
  "sg03ax": "Solve reduced generalized discrete-time Lyapunov equation.\n\nSolves A'*X*A - E'*X*E = scale*Y (trans='N') or\n       A*X*A' - E*X*E' = scale*Y (trans='T').\n\nParameters:\n  trans (str): 'N' or 'T' - equation form\n  a (ndarray): Upper quasitriangular matrix (n x n, F-order)\n  e (ndarray): Upper triangular matrix (n x n, F-order)\n  x (ndarray): RHS matrix Y, overwritten with solution (n x n, F-order)\n\nReturns:\n  (X, scale, info): Solution X, scale factor, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sg03ax\n>>> a = np.array([\n...     [0.5, 0.0, 0.0],\n...     [0.0, 0.6, 0.0],\n...     [0.0, 0.0, 0.4]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> y = np.array([\n...     [1.0, 0.2, 0.1],\n...     [0.2, 2.0, 0.3],\n...     [0.1, 0.3, 1.5]\n...     ], order='F', dtype=float)\n>>> x, scale, info = sg03ax('N', a.copy(order='F'), e.copy(order='F'), y.copy(order='F'))\n>>> info\n0",
  "sg03ay": "Solve reduced generalized continuous-time Lyapunov equation.\n\nSolves A'*X*E + E'*X*A = scale*Y (trans='N') or\n       A*X*E' + E*X*A' = scale*Y (trans='T').\n\nParameters:\n  trans (str): 'N' or 'T' - equation form\n  a (ndarray): Upper quasitriangular matrix (n x n, F-order)\n  e (ndarray): Upper triangular matrix (n x n, F-order)\n  x (ndarray): RHS matrix Y, overwritten with solution (n x n, F-order)\n\nReturns:\n  (X, scale, info): Solution X, scale factor, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import sg03ay\n>>> n = 3\n>>> A = np.array([\n...     [2.0, 0.5, 0.1],\n...     [0.0, 1.5, 0.3],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> E = np.array([\n...     [1.0, 0.2, 0.1],\n...     [0.0, 1.0, 0.15],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> Y = np.array([\n...     [1.0, 0.3, 0.2],\n...     [0.3, 0.8, 0.1],\n...     [0.2, 0.1, 0.5]\n...     ], order='F', dtype=float)\n>>> X, scale, info = sg03ay('N', A, E, Y.copy())\n>>> X_sym = (X + X.T) / 2  # Make symmetric\n>>> residual = A.T @ X_sym @ E + E.T @ X_sym @ A - scale * Y\n>>> info\n0",
  "sg03bd": "Solve generalized Lyapunov equation for Cholesky factor.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  fact (str): 'N' to compute factorization, 'F' if factorization supplied\n  trans (str): 'N' for op(K)=K, 'T' for op(K)=K^T\n  n (int): Order of matrices A and E\n  m (int): Number of rows in op(B)\n  a (ndarray): Matrix A (n x n, F-order)\n  e (ndarray): Matrix E (n x n, F-order)\n  b (ndarray): Matrix B (size depends on trans, F-order)\n\nReturns:\n  (u, scale, alphar, alphai, beta, info): Cholesky factor, scale, eigenvalues, exit code\n\nExamples:\n\n>>> from slicot import sg03bd\n>>> import numpy as np\n>>> n = 3\n>>> m = 1\n>>> a = np.array([\n...     [-1.0,  3.0, -4.0],\n...     [ 0.0,  5.0, -2.0],\n...     [-4.0,  4.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [2.0, 1.0, 3.0],\n...     [2.0, 0.0, 1.0],\n...     [4.0, 5.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [2.0, -1.0, 7.0],\n...     [0.0,  0.0,  0.0],\n...     [0.0,  0.0,  0.0]\n...     ], dtype=np.float64, order='F')  # Shape (3, 3)\n>>> expected_u = np.array([\n...     [1.6003, -0.4418, -0.1523],\n...     [0.0000,  0.6795, -0.2499],\n...     [0.0000,  0.0000,  0.2041]\n...     ], dtype=np.float64, order='F')\n>>> expected_scale = 1.0\n>>> u, scale, alphar, alphai, beta, info = sg03bd('C', 'N', 'N', n, m, a, e, b)\n>>> x = u.T @ u\n>>> residual = np.linalg.norm(lhs - rhs) / max(np.linalg.norm(lhs), np.linalg.norm(rhs))\n>>> info\n0",
  "sg03br": "Compute complex Givens rotation in real arithmetic.\n\nParameters:\n  xr (float): Real part of X\n  xi (float): Imaginary part of X\n  yr (float): Real part of Y\n  yi (float): Imaginary part of Y\n\nReturns:\n  (c, sr, si, zr, zi): Givens rotation parameters and result\n\nExamples:\n\n>>> from slicot import sg03br\n>>> import numpy as np\n>>> xr, xi = 3.0, 4.0  # X = 3 + 4i\n>>> yr, yi = 1.0, 2.0  # Y = 1 + 2i\n>>> c, sr, si, zr, zi = sg03br(xr, xi, yr, yi)\n>>> zr_computed = c * xr + sr * yr - si * yi\n>>> zi_computed = c * xi + si * yr + sr * yi\n>>> result_r = -sr * xr - si * xi + c * yr\n>>> result_i = si * xr - sr * xi + c * yi\n>>> norm = c**2 + sr**2 + si**2",
  "sg03bs": "Solve generalized discrete-time Lyapunov equation (complex Hammarling).\n\nComputes Cholesky factor U of X = U^H*U or X = U*U^H for:\n  TRANS='N': A^H * X * A - E^H * X * E = -SCALE^2 * B^H * B\n  TRANS='C': A * X * A^H - E * X * E^H = -SCALE^2 * B * B^H\n\nwhere A, E, B are complex upper triangular matrices.\nThe pencil A-lambda*E must be d-stable (eigenvalues inside unit circle).\n\nParameters:\n  trans (str): 'N' for equation (1), 'C' for equation (2)\n  a (ndarray): Complex upper triangular A (n x n, F-order)\n  e (ndarray): Complex upper triangular E (n x n, F-order)\n  b (ndarray): Complex upper triangular B (n x n, F-order)\n\nReturns:\n  (u, scale, info): Cholesky factor U, scale factor, exit code\n  info=0: success, info=3: not d-stable, info=4: ZSTEIN failed\n\nExamples:\n\n>>> from slicot import sg03bs\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([\n...     [0.3+0.1j, 0.1+0.05j, 0.05+0.02j],\n...     [0.0, 0.2-0.1j, 0.08+0.03j],\n...     [0.0, 0.0, 0.15+0.05j]\n...     ], dtype=complex, order='F')\n>>> e = np.array([\n...     [1.0+0j, 0.1+0.02j, 0.05+0.01j],\n...     [0.0, 1.0+0j, 0.08+0.02j],\n...     [0.0, 0.0, 1.0+0j]\n...     ], dtype=complex, order='F')\n>>> b = np.array([\n...     [0.5, 0.2+0.1j, 0.1+0.05j],\n...     [0.0, 0.3, 0.15+0.08j],\n...     [0.0, 0.0, 0.25]\n...     ], dtype=complex, order='F')\n>>> u, scale, info = sg03bs('N', a, e, b)\n>>> x = u.conj().T @ u\n>>> residual = np.linalg.norm(lhs - rhs) / max(np.linalg.norm(lhs), np.linalg.norm(rhs))\n>>> info\n0",
  "sg03bt": "Solve generalized continuous-time Lyapunov equation (complex Hammarling).\n\nComputes Cholesky factor U of X = U^H*U or X = U*U^H for:\n  TRANS='N': A^H * X * E + E^H * X * A = -SCALE^2 * B^H * B\n  TRANS='C': A * X * E^H + E * X * A^H = -SCALE^2 * B * B^H\n\nwhere A, E, B are complex upper triangular matrices.\nThe pencil A-lambda*E must be c-stable (eigenvalues with negative real parts).\n\nParameters:\n  trans (str): 'N' for equation (1), 'C' for equation (2)\n  a (ndarray): Complex upper triangular A (n x n, F-order)\n  e (ndarray): Complex upper triangular E (n x n, F-order)\n  b (ndarray): Complex upper triangular B (n x n, F-order)\n\nReturns:\n  (u, scale, info): Cholesky factor U, scale factor, exit code\n  info=0: success, info=3: not c-stable\n\nExamples:\n\n>>> from slicot import sg03bt\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([\n...     [-0.5+0.1j, 0.1+0.05j, 0.05+0.02j],\n...     [0.0, -0.3-0.1j, 0.08+0.03j],\n...     [0.0, 0.0, -0.2+0.05j]\n...     ], dtype=complex, order='F')\n>>> e = np.array([\n...     [1.0+0j, 0.1+0.02j, 0.05+0.01j],\n...     [0.0, 1.0+0j, 0.08+0.02j],\n...     [0.0, 0.0, 1.0+0j]\n...     ], dtype=complex, order='F')\n>>> b = np.array([\n...     [0.5, 0.2+0.1j, 0.1+0.05j],\n...     [0.0, 0.3, 0.15+0.08j],\n...     [0.0, 0.0, 0.25]\n...     ], dtype=complex, order='F')\n>>> u, scale, info = sg03bt('N', a, e, b)\n>>> x = u.conj().T @ u\n>>> residual = np.linalg.norm(lhs - rhs) / max(np.linalg.norm(lhs), np.linalg.norm(rhs), 1e-15)\n>>> info\n0",
  "sg03bu": "Solve generalized discrete-time Lyapunov equation for Cholesky factor.\n\nParameters:\n  trans (str): 'N' for TRANS='N', 'T' for TRANS='T'\n  a (ndarray): Quasitriangular matrix A (n x n, F-order)\n  e (ndarray): Upper triangular matrix E (n x n, F-order)\n  b (ndarray): Upper triangular matrix B (n x n, F-order)\n\nReturns:\n  (u, scale, info): Cholesky factor U, scale factor, exit code\n\nExamples:\n\n>>> from slicot import sg03bu\n>>> import numpy as np\n>>> trans = 'N'\n>>> n = 1\n>>> a = np.array([[0.5]], dtype=np.float64, order='F')\n>>> e = np.array([[1.0]], dtype=np.float64, order='F')\n>>> b = np.array([[1.0]], dtype=np.float64, order='F')\n>>> u, scale, info = sg03bu(trans, a, e, b)\n>>> info\n0",
  "sg03bv": "Solve generalized continuous-time Lyapunov equation for Cholesky factor.\n\nParameters:\n  trans (str): 'N' for TRANS='N', 'T' for TRANS='T'\n  a (ndarray): Quasitriangular matrix A (n x n, F-order)\n  e (ndarray): Upper triangular matrix E (n x n, F-order)\n  b (ndarray): Upper triangular matrix B (n x n, F-order)\n\nReturns:\n  (u, scale, info): Cholesky factor U, scale factor, exit code\n\nExamples:\n\n>>> from slicot import sg03bv\n>>> import numpy as np\n>>> trans = 'N'\n>>> n = 1\n>>> a = np.array([[-1.0]], dtype=np.float64, order='F')\n>>> e = np.array([[1.0]], dtype=np.float64, order='F')\n>>> b = np.array([[1.0]], dtype=np.float64, order='F')\n>>> u, scale, info = sg03bv(trans, a, e, b)\n>>> info\n0",
  "sg03bw": "Solve generalized Sylvester equation for small systems.\n\nParameters:\n  trans (str): 'N' or 'T' - equation form\n  a (ndarray): Upper quasitriangular matrix (m x m, F-order)\n  e (ndarray): Upper triangular matrix (m x m, F-order)\n  c (ndarray): Matrix C (n x n, F-order)\n  d (ndarray): Matrix D (n x n, F-order)\n  x (ndarray): Right-hand side Y, overwritten with solution (m x n, F-order)\n\nReturns:\n  (x, scale, info): Solution matrix, scale factor, and exit code\n\nExamples:\n\n>>> from slicot import sg03bw\n>>> import numpy as np\n>>> trans = 'N'\n>>> m, n = 2, 1\n>>> a = np.array([[2.0, 1.0],\n...     [0.0, 3.0]], dtype=np.float64, order='F')\n>>> e = np.array([[1.0, 0.5],\n...     [0.0, 1.0]], dtype=np.float64, order='F')\n>>> c = np.array([[4.0]], dtype=np.float64, order='F')\n>>> d = np.array([[2.0]], dtype=np.float64, order='F')\n>>> x = np.array([[1.0],\n...     [2.0]], dtype=np.float64, order='F')\n>>> x_out, scale, info = sg03bw(trans, a, e, c, d, x)\n>>> info\n0",
  "sg03bx": "Solve 2x2 generalized Lyapunov equation.\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  trans (str): 'N' for op(K)=K, 'T' for op(K)=K^T\n  a (ndarray): Matrix A (2 x 2, F-order)\n  e (ndarray): Upper triangular matrix E (2 x 2, F-order)\n  b (ndarray): Upper triangular matrix B (2 x 2, F-order)\n\nReturns:\n  (u, scale, m1, m2, info): Cholesky factor, scale, auxiliary matrices, exit code\n\nExamples:\n\n>>> from slicot import sg03bx\n>>> import numpy as np\n>>> dico = 'C'\n>>> trans = 'N'\n>>> a = np.array([\n...     [-1.0, 2.0],\n...     [-2.0, -1.0]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [1.0, 0.5],\n...     [0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0, 0.5],\n...     [0.0, 0.5]\n...     ], dtype=np.float64, order='F')\n>>> u, scale, m1, m2, info = sg03bx(dico, trans, a, e, b)\n>>> info\n0",
  "sg03by": "Compute complex Givens rotation in real arithmetic.\n\nComputes parameters for the complex Givens rotation:\n\n    (  CR-CI*I   SR-SI*I )   ( XR+XI*I )   ( Z )\n    (                    ) * (         ) = (   )\n    ( -SR-SI*I   CR+CI*I )   ( YR+YI*I )   ( 0 )\n\nwhere CR, CI, SR, SI, XR, XI, YR, YI are real numbers and I is the\nimaginary unit. Z is a non-negative real number.\n\nThe routine avoids overflow using max-norm scaling.\n\nParameters:\n  xr (float): Real part of first complex input\n  xi (float): Imaginary part of first complex input\n  yr (float): Real part of second complex input\n  yi (float): Imaginary part of second complex input\n\nReturns:\n  (cr, ci, sr, si, z): Givens rotation parameters and result norm\n\nExamples:\n\n>>> from slicot import sg03by\n>>> import numpy as np\n>>> xr, xi = 3.0, 0.0\n>>> yr, yi = 4.0, 0.0\n>>> cr, ci, sr, si, z = sg03by(xr, xi, yr, yi)\n>>> expected_z = np.sqrt(xr**2 + yr**2)\n>>> result_z, result_zero = apply_givens_rotation(cr, ci, sr, si, xr, xi, yr, yi)",
  "sg03bz": "Solve stable generalized continuous/discrete-time Lyapunov equation (complex).\n\nComputes the Cholesky factor U of X = op(U)^H * op(U), where X solves:\n\nContinuous-time (DICO='C'):\n  op(A)^H * X * op(E) + op(E)^H * X * op(A) = -SCALE^2 * op(B)^H * op(B)\n\nDiscrete-time (DICO='D'):\n  op(A)^H * X * op(A) - op(E)^H * X * op(E) = -SCALE^2 * op(B)^H * op(B)\n\nwhere op(K) = K (TRANS='N') or op(K) = K^H (TRANS='C').\n\nThe pencil A - lambda*E must be c-stable (continuous, Re(eig) < 0) or\nd-stable (discrete, |eig| < 1).\n\nParameters:\n  dico (str): 'C' for continuous-time, 'D' for discrete-time\n  fact (str): 'N' compute Schur factorization, 'F' supplied\n  trans (str): 'N' for op(K)=K, 'C' for op(K)=K^H\n  a (ndarray): Complex matrix A (n x n, F-order)\n  e (ndarray): Complex matrix E (n x n, F-order)\n  q (ndarray): Unitary transformation Q (n x n, F-order)\n  z (ndarray): Unitary transformation Z (n x n, F-order)\n  b (ndarray): Input matrix B (m x n or n x m depending on TRANS)\n\nReturns:\n  (u, scale, alpha, beta, info): Cholesky factor U, scale factor,\n    eigenvalue numerators, eigenvalue denominators, exit code\n  info=0: success, info=4: ZGGES failed, info=5: not c-stable,\n  info=6: not d-stable, info=7: ZSTEIN failed\n\nExamples:\n\n>>> from slicot import sg03bz\n>>> import numpy as np\n>>> n = 3\n>>> a = np.array([\n...     [-0.5+0.1j, 0.2+0.05j, 0.1+0.02j],\n...     [0.1-0.05j, -0.4-0.1j, 0.15+0.03j],\n...     [0.05+0.02j, 0.08-0.04j, -0.3+0.05j]\n...     ], dtype=complex, order='F')\n>>> e = np.array([\n...     [1.0+0j, 0.1+0.02j, 0.05+0.01j],\n...     [0.0, 1.0+0j, 0.08+0.02j],\n...     [0.0, 0.0, 1.0+0j]\n...     ], dtype=complex, order='F')\n>>> b = np.array([\n...     [0.5, 0.2+0.1j, 0.1+0.05j],\n...     [0.0, 0.3, 0.15+0.08j]\n...     ], dtype=complex, order='F')\n>>> q = np.zeros((n, n), dtype=complex, order='F')\n>>> z = np.zeros((n, n), dtype=complex, order='F')\n>>> u, scale, _alpha, _beta, info = sg03bz('C', 'N', 'N', a, e, q, z, b)\n>>> x = u.conj().T @ u\n>>> residual = np.linalg.norm(lhs - rhs) / max(np.linalg.norm(lhs), np.linalg.norm(rhs), 1e-15)\n>>> info\n0",
  "tb01id": "Balance system matrices (A,B,C) using diagonal similarity.\n\nReduces 1-norm of system matrix S=[A B; C 0] by balancing.\n\nParameters:\n  job (str): 'A' all, 'B' B+A, 'C' C+A, 'N' A only\n  a (ndarray): N-by-N state matrix A (F-order)\n  b (ndarray): N-by-M input matrix B (F-order)\n  c (ndarray): P-by-N output matrix C (F-order)\n  maxred (float): Max reduction (<=0 uses 10.0)\n\nReturns:\n  (a, b, c, maxred, scale, info): Balanced matrices,\n    norm ratio, scale factors, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tb01id\n>>> n, m, p = 5, 2, 5\n>>> a = np.array([\n...     [0.0, 1.0, 0.0, 0.0, 0.0],\n...     [-1.58e6, -1.257e3, 0.0, 0.0, 0.0],\n...     [3.541e14, 0.0, -1.434e3, 0.0, -5.33e11],\n...     [0.0, 0.0, 0.0, 0.0, 1.0],\n...     [0.0, 0.0, 0.0, -1.863e4, -1.482]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0, 0.0],\n...     [1.103e2, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 8.333e-3]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 1.0, 0.0],\n...     [6.664e-1, 0.0, -6.2e-13, 0.0, 0.0],\n...     [0.0, 0.0, -1.0e-3, 1.896e6, 1.508e2]\n...     ], order='F', dtype=float)\n>>> maxred_in = 0.0  # Use default 10.0\n>>> a_out, b_out, c_out, maxred_out, scale, info = tb01id('A', a, b, c, maxred_in)\n>>> info\n0",
  "tb01iz": "Balance complex system matrices (A,B,C) using diagonal similarity.\n\nReduces 1-norm of system matrix S=[A B; C 0] by balancing.\n\nParameters:\n  job (str): 'A' all, 'B' B+A, 'C' C+A, 'N' A only\n  a (ndarray): N-by-N complex state matrix A (F-order)\n  b (ndarray): N-by-M complex input matrix B (F-order)\n  c (ndarray): P-by-N complex output matrix C (F-order)\n  maxred (float): Max reduction (<=0 uses 10.0)\n\nReturns:\n  (a, b, c, maxred, scale, info): Balanced matrices,\n    norm ratio, scale factors, exit code\n\nExamples:\n\n>>> from slicot import tb01iz\n>>> import numpy as np\n>>> n, m, p = 5, 2, 5\n>>> a = np.array([\n...     [0.0+0.0j, 1.0e3+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [-1.58e6+0.0j, -1.257e3+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [3.541e14+0.0j, 0.0+0.0j, -1.434e3+0.0j, 0.0+0.0j, -5.33e11+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 1.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j, -1.863e4+0.0j, -1.482+0.0j]\n...     ], order='F', dtype=complex)\n>>> b = np.array([\n...     [0.0+0.0j, 0.0+0.0j],\n...     [1.103e2+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 8.333e-3+0.0j]\n...     ], order='F', dtype=complex)\n>>> c = np.array([\n...     [1.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 1.0+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, 0.0+0.0j, 1.0+0.0j, 0.0+0.0j],\n...     [6.664e-1+0.0j, 0.0+0.0j, -6.2e-13+0.0j, 0.0+0.0j, 0.0+0.0j],\n...     [0.0+0.0j, 0.0+0.0j, -1.0e-3+0.0j, 1.896e6+0.0j, 1.508e2+0.0j]\n...     ], order='F', dtype=complex)\n>>> a_bal, b_bal, c_bal, maxred_out, scale, info = tb01iz('A', a, b, c, 0.0)\n>>> d = np.diag(scale)\n>>> d_inv = np.diag(1.0 / scale)\n>>> a_reconstructed = d @ a_bal @ d_inv\n>>> b_reconstructed = d @ b_bal\n>>> c_reconstructed = c_bal @ d_inv\n>>> eig_bal = np.linalg.eigvals(a_bal)\n...     sorted(np.abs(eig_bal)),\n...     rtol=1e-10\n>>> )\n>>> info\n0",
  "tb01kd": "Stable/unstable decomposition of state-space system.\n\nReduces (A,B,C) to block-diagonal form with eigenvalues in specified domain in leading block.\n\nParameters:\n  dico (str): 'C' continuous, 'D' discrete\n  stdom (str): 'S' stable domain, 'U' unstable domain\n  joba (str): 'S' A is Schur, 'G' A is general\n  alpha (float): Domain boundary\n  a (ndarray): State matrix (n x n)\n  b (ndarray): Input matrix (n x m)\n  c (ndarray): Output matrix (p x n)\n\nReturns:\n  (a, b, c, ndim, u, wr, wi, info): Block-diagonal A, transformed B/C, counts, eigenvalues\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tb01kd\n>>> n, m, p = 5, 2, 3\n>>> alpha = -1.0\n>>> a = np.array([\n...     [-0.04165,  4.9200, -4.9200,       0,       0],\n...     [-1.387944, -3.3300,       0,       0,       0],\n...     [   0.5450,       0,       0, -0.5450,       0],\n...     [        0,       0,  4.9200, -0.04165, 4.9200],\n...     [        0,       0,       0, -1.387944, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0,    0.0],\n...     [3.3300, 0.0],\n...     [0.0,    0.0],\n...     [0.0,    0.0],\n...     [0.0, 3.3300]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1, 0, 0, 0, 0],\n...     [0, 0, 1, 0, 0],\n...     [0, 0, 0, 1, 0]\n...     ], order='F', dtype=float)\n>>> a_out, b_out, c_out, ndim, u, wr, wi, info = tb01kd(\n...     'C', 'U', 'G', alpha, a.copy(order='F'), b.copy(order='F'), c.copy(order='F')\n...     )\n>>> expected_wr = np.array([-0.7483, -0.7483, -1.6858, -1.6858, -1.8751])\n>>> expected_wi = np.array([2.9940, -2.9940, 2.0311, -2.0311, 0.0])\n>>> eig_computed = sorted(zip(wr, wi), key=lambda x: (x[0], -abs(x[1])))\n>>> info\n0",
  "tb01kx": "Block-diagonalize state-space system with Schur form input.\n\nComputes additive spectral decomposition by block-diagonalizing A (in real Schur form) via Sylvester equation. The leading NDIM eigenvalues must be distinct from trailing eigenvalues.\n\nTransformation: A <- V*A*U, B <- V*B, C <- C*U, where V = inv(U)\n\nParameters:\n  ndim (int): Dimension of leading block (0 <= ndim <= n)\n  a (ndarray): State matrix in Schur form (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  u (ndarray): Initial transformation matrix (n x n, F-order)\n\nReturns:\n  (a, b, c, u, v, info): Block-diagonal A, transformed B/C/U, inverse V, exit code\n  info=0: success, info=1: Sylvester equation failed (close eigenvalues)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tb01kx\n>>> n, m, p = 4, 2, 2\n>>> ndim = 2\n>>> a = np.array([\n...     [-1.0, 0.5, 0.3, 0.2],\n...     [ 0.0, -2.0, 0.4, 0.1],\n...     [ 0.0, 0.0, 1.0, 0.6],\n...     [ 0.0, 0.0, 0.0, 2.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.5],\n...     [0.5, 1.0],\n...     [0.3, 0.2],\n...     [0.2, 0.4]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, 0.5, 0.3],\n...     [0.0, 1.0, 0.2, 0.4]\n...     ], order='F', dtype=float)\n>>> u = np.eye(n, order='F', dtype=float)\n>>> a_out, b_out, c_out, u_out, v_out, info = tb01kx(\n...     ndim, a.copy(order='F'), b.copy(order='F'), c.copy(order='F'), u.copy(order='F')\n...     )\n>>> eig_after = np.sort(np.linalg.eigvals(a_out).real)\n>>> info\n0",
  "tb01ld": "Reduce state matrix to ordered Schur form.\n\nReduces (A,B,C) so leading block of A has eigenvalues in specified domain.\n\nParameters:\n  dico (str): 'C' continuous, 'D' discrete\n  stdom (str): 'S' stable domain, 'U' unstable domain\n  joba (str): 'S' A is Schur, 'G' A is general\n  alpha (float): Domain boundary\n  a (ndarray): State matrix (n x n)\n  b (ndarray): Input matrix (n x m)\n  c (ndarray): Output matrix (p x n)\n\nReturns:\n  (a, b, c, ndim, u, wr, wi, info): Transformed matrices, counts, eigenvalues\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tb01ld\n>>> n, m, p = 5, 2, 3\n>>> alpha = -1.0\n>>> a = np.array([\n...     [-0.04165,  4.9200, -4.9200,       0,       0],\n...     [-1.387944, -3.3300,       0,       0,       0],\n...     [   0.5450,       0,       0, -0.5450,       0],\n...     [        0,       0,  4.9200, -0.04165, 4.9200],\n...     [        0,       0,       0, -1.387944, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0,    0.0],\n...     [3.3300, 0.0],\n...     [0.0,    0.0],\n...     [0.0,    0.0],\n...     [0.0, 3.3300]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1, 0, 0, 0, 0],\n...     [0, 0, 1, 0, 0],\n...     [0, 0, 0, 1, 0]\n...     ], order='F', dtype=float)\n>>> a_out, b_out, c_out, ndim, u, wr, wi, info = tb01ld(\n...     'C', 'U', 'G', alpha, a.copy(order='F'), b.copy(order='F'), c.copy(order='F')\n...     )\n>>> expected_wr = np.array([-0.7483, -0.7483, -1.6858, -1.6858, -1.8751])\n>>> expected_wi = np.array([2.9940, -2.9940, 2.0311, -2.0311, 0.0])\n>>> eig_computed = sorted(zip(wr, wi), key=lambda x: (x[0], -abs(x[1])))\n>>> info\n0",
  "tb01md": "Reduce (B,A) to upper/lower controller Hessenberg form.\n\nComputes unitary transformation U to reduce (B,A) pair to controller\nHessenberg form. For UPLO='U', U'B is upper triangular and U'AU is\nupper Hessenberg. For UPLO='L', the structure is reversed.\n\nParameters:\n  jobu (str): 'N'=no U, 'I'=initialize U to identity, 'U'=update given U\n  uplo (str): 'U'=upper Hessenberg, 'L'=lower Hessenberg\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  u (ndarray, optional): Transformation matrix (n x n), required if jobu='U'\n\nReturns:\n  (a, b, u, info): Transformed A=U'AU, B=U'B, transformation U, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tb01md\n>>> a = np.array([\n...     [35.0,  1.0,  6.0, 26.0, 19.0, 24.0],\n...     [ 3.0, 32.0,  7.0, 21.0, 23.0, 25.0],\n...     [31.0,  9.0,  2.0, 22.0, 27.0, 20.0],\n...     [ 8.0, 28.0, 33.0, 17.0, 10.0, 15.0],\n...     [30.0,  5.0, 34.0, 12.0, 14.0, 16.0],\n...     [ 4.0, 36.0, 29.0, 13.0, 18.0, 11.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [  1.0,  5.0, 11.0],\n...     [ -1.0,  4.0, 11.0],\n...     [ -5.0,  1.0,  9.0],\n...     [-11.0, -4.0,  5.0],\n...     [-19.0,-11.0, -1.0],\n...     [-29.0,-20.0, -9.0]\n...     ], order='F', dtype=float)\n>>> n, m = 6, 3\n>>> a_out, b_out, u_out, info = tb01md('I', 'U', a, b)\n>>> eig_after = np.linalg.eigvals(a_out)\n>>> info\n0",
  "tb01nd": "Reduce (A,C) to upper/lower observer Hessenberg form.\n\nComputes unitary transformation U to reduce (A,C) pair to observer\nHessenberg form. For UPLO='U', CU is upper triangular and U'AU is\nupper Hessenberg. For UPLO='L', the structure is reversed.\n\nParameters:\n  jobu (str): 'N'=no U, 'I'=initialize U to identity, 'U'=update given U\n  uplo (str): 'U'=upper Hessenberg, 'L'=lower Hessenberg\n  a (ndarray): State matrix A (n x n, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  u (ndarray, optional): Transformation matrix (n x n), required if jobu='U'\n\nReturns:\n  (a, c, u, info): Transformed A=U'AU, C=CU, transformation U, exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tb01nd\n>>> a = np.array([\n...     [15.0, 20.0,  4.0,  5.0,  5.0],\n...     [21.0,  1.0,  1.0,  6.0, 11.0],\n...     [-3.0,  2.0,  7.0, 12.0, 17.0],\n...     [ 3.0,  8.0, 13.0, 13.0, -7.0],\n...     [ 9.0,  9.0, 14.0, -6.0, -1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [ 7.0, -1.0,  3.0, -6.0, -3.0],\n...     [ 4.0,  5.0,  6.0, -2.0, -3.0],\n...     [ 9.0,  8.0,  5.0,  2.0,  1.0]\n...     ], order='F', dtype=float)\n>>> n, p = 5, 3\n>>> a_out, c_out, u_out, info = tb01nd('N', 'U', a, c)\n>>> info\n0",
  "tb01pd": "Compute minimal realization of state-space system.\n\nReduces the linear time-invariant system (A,B,C) to a minimal\n(controllable and observable) or controllable/observable form.\n\nParameters:\n  job (str): 'M'=minimal, 'C'=controllable, 'O'=observable\n  equil (str): 'S'=scale first, 'N'=no balancing\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  tol (float): Tolerance for rank determination (0 for default)\n\nReturns:\n  (a, b, c, nr, nblk, info):\n    - a: Reduced state matrix (nr x nr block)\n    - b: Reduced input matrix\n    - c: Reduced output matrix\n    - nr: Order of reduced system\n    - nblk: Staircase block structure\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import tb01pd\n>>> import numpy as np\n>>> n, m, p = 3, 1, 2\n>>> tol = 0.0\n>>> a_out, b_out, c_out, nr, iwork_out, info = tb01pd('M', 'N', a, b, c, tol)\n>>> ar = a_out[:nr, :nr]\n>>> br = b_out[:nr, :]\n>>> cr = c_out[:, :nr]\n>>> d_red = np.zeros((p, m), dtype=float)\n...     h_red = d_red.copy()\n...     else:\n...     a_k_red = np.linalg.matrix_power(ar, k - 1)\n...     h_red = cr @ a_k_red @ br\n...     err_msg=f\"Markov param h({k}) mismatch\")\n>>> info\n0",
  "tb01px": "Compute minimal/controllable/observable realization (variant).\n\nFinds a reduced (controllable, observable, or minimal) state-space\nrepresentation (Ar,Br,Cr) with Ar in upper block Hessenberg staircase form.\n\nTwo-phase reduction:\n  Phase 1 (job='M' or 'C'): Remove uncontrollable part\n  Phase 2 (job='M' or 'O'): Remove unobservable part\n\nParameters:\n  job (str): 'M'=minimal, 'C'=controllable, 'O'=observable\n  equil (str): 'S'=balance (scale) first, 'N'=no balancing\n  n (int): Order of original system (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  a (ndarray): State matrix A (n x n, F-order)\n  b (ndarray): Input matrix B (n x m, F-order)\n  c (ndarray): Output matrix C (p x n, F-order)\n  tol (float, optional): Tolerance for rank determination (default: 0.0)\n\nReturns:\n  (a, b, c, nr, infred, iwork, info):\n    - a: Reduced state matrix (nr x nr block in upper block Hessenberg)\n    - b: Reduced input matrix (nr x m)\n    - c: Reduced output matrix (p x nr)\n    - nr: Order of reduced system\n    - infred: Reduction info (4-element array):\n        [0]: Order reduction in Phase 1 (>=0) or -1 if not performed\n        [1]: Order reduction in Phase 2 (>=0) or -1 if not performed\n        [2]: Number of nonzero subdiagonals of Ar\n        [3]: Number of blocks in staircase form\n    - iwork: Block dimensions (infred[3] elements)\n    - info: Exit code (0 = success)\n\nExamples:\n\n>>> from slicot import tb01px\n>>> import numpy as np\n>>> n, m, p = 3, 1, 2\n>>> a = np.array([\n...     [1.0,  2.0,  0.0],\n...     [4.0, -1.0,  0.0],\n...     [0.0,  0.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0],\n...     [0.0],\n...     [1.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [0.0,  1.0, -1.0],\n...     [0.0,  0.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> expected_nr = 3\n>>> expected_infred = [-1, -1, 2, 0]\n>>> expected_a = np.array([\n...     [1.0,  2.0,  0.0],\n...     [4.0, -1.0,  0.0],\n...     [0.0,  0.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> expected_b = np.array([\n...     [1.0],\n...     [0.0],\n...     [1.0]\n...     ], dtype=np.float64, order='F')\n>>> expected_c = np.array([\n...     [0.0,  1.0, -1.0],\n...     [0.0,  0.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> a_out, b_out, c_out, nr, infred, iwork, info = slicot.tb01px(\n...     'M', 'N', n, m, p, a, b, c, tol=0.0)\n...     f\"infred[{i}]={infred[i]}, expected {expected_infred[i]}\"\n...     a_out[:nr, :nr], expected_a, rtol=1e-3, atol=1e-4)\n...     b_out[:nr, :m], expected_b, rtol=1e-3, atol=1e-4)\n...     c_out[:p, :nr], expected_c, rtol=1e-3, atol=1e-4)\n>>> info\n0",
  "tb01td": "Balance state-space (A,B,C,D) by permutations and scalings.\n\nReduces (A,B,C,D) to balanced form using state permutations and\nstate/input/output scalings. Uses DGEBAL for A, then scales B,C,D.\n\nParameters:\n  n (int): Order of A (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  a (ndarray): State matrix (n x n, F-order), modified in-place\n  b (ndarray): Input matrix (n x m, F-order), modified in-place\n  c (ndarray): Output matrix (p x n, F-order), modified in-place\n  d (ndarray): Feedthrough matrix (p x m, F-order), modified in-place\n\nReturns:\n  (low, igh, scstat, scin, scout, info):\n    - low: Lower index of balanced submatrix (1-based)\n    - igh: Upper index of balanced submatrix (1-based)\n    - scstat: State transformation info (n elements)\n    - scin: Input scalings (m elements)\n    - scout: Output scalings (p elements)\n    - info: Exit code (0 = success, <0 = invalid parameter)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tb01td\n>>> n, m, p = 5, 2, 2\n>>> a = np.array([\n...     [  0.0,   0.0,   1.0,   4.0,   5.0],\n...     [ 50.0,  10.0,   1.0,   0.0,   0.0],\n...     [  0.0,   0.0,  90.0,  10.0,   0.0],\n...     [  0.0,   1.0,   1.0,   1.0,   1.0],\n...     [100.0,   0.0,   0.0,   0.0,  70.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [0.0,   0.0],\n...     [2.0,  20.0],\n...     [0.0, 100.0],\n...     [1.0,   1.0],\n...     [2.0,   0.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [1.0, 0.0, 0.0, 1.0, 0.0],\n...     [1.0, 1.0, 0.0, 2.0, 1.0]\n...     ], dtype=float, order='F')\n>>> d = np.array([\n...     [1.0, 1.0],\n...     [1.0, 1.0]\n...     ], dtype=float, order='F')\n>>> low, igh, scstat, scin, scout, info = tb01td(n, m, p, a, b, c, d)\n>>> eig_bal = np.linalg.eigvals(a)\n>>> I = np.eye(n)\n...     sI_minus_A_bal = s * I - a\n...     G_bal_raw = c @ np.linalg.solve(sI_minus_A_bal, b) + d\n...     G_reconstructed = np.diag(1.0 / scout) @ G_bal_raw @ np.diag(scin)\n>>> info\n0",
  "tb01ty": "Balance rows/columns of a matrix block using integer powers of BASE.\n\nScales each non-zero row (MODE=0) or column (MODE!=0) by BASE^IEXPT\nso the 1-norm is in range (SIZE/BASE, SIZE]. No rounding errors.\n\nParameters:\n  mode (int): 0 = balance rows, != 0 = balance columns\n  ioff (int): Row offset (0-based)\n  joff (int): Column offset (0-based)\n  nrow (int): Number of rows in block\n  ncol (int): Number of columns in block\n  size (float): Target 1-norm (absolute value used)\n  x (ndarray): Matrix to balance (F-order), modified in-place\n\nReturns:\n  (x, bvect, info): Balanced matrix, scale factors, exit code\n\nExamples:\n\n>>> from slicot import tb01ty\n>>> import numpy as np\n>>> nrow = 3\n>>> ncol = 2\n>>> ioff = 0\n>>> joff = 0\n>>> size = 1.0\n>>> mode = 1  # Column balance\n>>> x = np.array([\n...     [0.001, 100.0],\n...     [0.002, 200.0],\n...     [0.003, 300.0]\n...     ], dtype=float, order='F')\n>>> x_out, bvect, info = slicot.tb01ty(mode, ioff, joff, nrow, ncol, size, x)\n>>> base = 2.0\n...     sf = bvect[joff + j]\n...     log_sf = np.log(sf) / np.log(base)\n...     col_norm = np.sum(np.abs(x_out[:, joff + j]))\n>>> info\n0",
  "tb01ud": "Reduce state-space system to controllability staircase form.\n\nFinds controllable realization via orthogonal similarity transformations.\nThe transformed system has Acont in upper block Hessenberg form.\n\nParameters:\n  jobz (str): 'N'=no Z, 'F'=factored form, 'I'=identity initialized\n  n (int): Order of state matrix A\n  m (int): Number of inputs (columns of B)\n  p (int): Number of outputs (rows of C)\n  a (ndarray): State dynamics matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float, optional): Tolerance for rank determination (default: 0.0)\n\nReturns:\n  (a, b, c, ncont, indcon, nblk, z, tau, info): Transformed system and metadata\n\nExamples:\n\n>>> from slicot import tb01ud\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0],\n...     [-2.0, -2.0, -2.0],\n...     [-1.0,  0.0, -3.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 2.0],\n...     [0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [0.0, 2.0, 1.0],\n...     [1.0, 0.0, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> expected_ncont = 2\n>>> expected_indcon = 1\n>>> expected_nblk = [2]\n>>> expected_acont = np.array([\n...     [-3.0000,  2.2361],\n...     [ 0.0000, -1.0000]\n...     ], dtype=np.float64, order='F')\n>>> expected_bcont = np.array([\n...     [ 0.0000, -2.2361],\n...     [ 1.0000,  0.0000]\n...     ], dtype=np.float64, order='F')\n>>> expected_ccont = np.array([\n...     [-2.2361,  0.0000],\n...     [ 0.0000,  1.0000]\n...     ], dtype=np.float64, order='F')\n>>> expected_z = np.array([\n...     [ 0.0000,  1.0000,  0.0000],\n...     [-0.8944,  0.0000, -0.4472],\n...     [-0.4472,  0.0000,  0.8944]\n...     ], dtype=np.float64, order='F')\n>>> a_out, b_out, c_out, ncont, indcon, nblk, z, tau, info = slicot.tb01ud(\n...     'I', n, m, p, a, b, c, tol=0.0)\n...     a_out[:ncont, :ncont], expected_acont, rtol=1e-3, atol=1e-4)\n...     b_out[:ncont, :], expected_bcont, rtol=1e-3, atol=1e-4)\n...     c_out[:, :ncont], expected_ccont, rtol=1e-3, atol=1e-4)\n>>> info\n0",
  "tb01ux": "Reduce state-space system to observability staircase form.\n\nComputes orthogonal Z to decompose (A,B,C) into observable/unobservable parts:\n  Z'*A*Z = [Ano *; 0 Ao], Z'*B = [Bno; Bo], C*Z = [0 Co]\nwhere (Ao,Bo,Co) is observable with order NOBSV.\n\nParameters:\n  compz (str): 'N'=no Z, 'I'=identity initialized\n  n (int): Order of state matrix A\n  m (int): Number of inputs (columns of B)\n  p (int): Number of outputs (rows of C)\n  a (ndarray): State dynamics matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float, optional): Tolerance for rank determination (default: 0.0)\n\nReturns:\n  (a, b, c, nobsv, nlblck, ctau, z, info): Transformed system and metadata\n\nExamples:\n\n>>> from slicot import tb01ux\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> a = np.array([\n...     [0, 1, 0],\n...     [0, 0, 1],\n...     [-1, -2, -3]\n...     ], dtype=np.float64, order='F')\n>>> b = np.random.randn(n, m).astype(np.float64, order='F')\n>>> c = np.array([\n...     [1, 0, 0],\n...     [0, 1, 0]\n...     ], dtype=np.float64, order='F')\n>>> a_out, b_out, c_out, nobsv, nlblck, ctau, z, info = slicot.tb01ux(\n...     'I', n, m, p, a, b, c, tol=0.0)\n>>> info\n0",
  "tb01uy": "Controllable realization for M1+M2 input system.\n\nReduces system (A,[B1,B2],C) to controllability staircase form with\nalternating rank detection between B1 (M1 columns) and B2 (M2 columns).\nProduces orthogonal canonical form: Ac = Z'*A*Z, [Bc1,Bc2] = Z'*[B1,B2], Cc = C*Z.\n\nParameters:\n  jobz (str): 'N'=no Z, 'F'=factored form, 'I'=identity initialized\n  n (int): Order of state matrix A\n  m1 (int): Number of B1 columns (first input group)\n  m2 (int): Number of B2 columns (second input group)\n  p (int): Number of outputs (rows of C)\n  a (ndarray): State dynamics matrix (n x n, F-order)\n  b (ndarray): Compound input matrix [B1,B2] (n x (m1+m2), F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float, optional): Tolerance for rank determination (default: 0.0)\n\nReturns:\n  (a, b, c, ncont, indcon, nblk, z, tau, info): Transformed system and metadata\n    ncont: Controllable subsystem order\n    indcon: Controllability index (always even)\n    nblk: Block dimensions (2*n array, INDCON/2 odd+even pairs)\n\nExamples:\n\n>>> from slicot import tb01uy\n>>> import numpy as np\n>>> n, m1, m2, p = 3, 1, 1, 2\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0],\n...     [-2.0, -2.0, -2.0],\n...     [-1.0,  0.0, -3.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 2.0],\n...     [0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [0.0, 2.0, 1.0],\n...     [1.0, 0.0, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> expected_ncont = 2\n>>> expected_indcon = 2\n>>> expected_nblk = [1, 1]\n>>> expected_acont = np.array([\n...     [-1.0000,  0.0000],\n...     [ 2.2361, -3.0000]\n...     ], dtype=np.float64, order='F')\n>>> expected_bcont = np.array([\n...     [1.0000,  0.0000],\n...     [0.0000, -2.2361]\n...     ], dtype=np.float64, order='F')\n>>> expected_ccont = np.array([\n...     [0.0000, -2.2361],\n...     [1.0000,  0.0000]\n...     ], dtype=np.float64, order='F')\n>>> expected_z = np.array([\n...     [ 1.0000,  0.0000,  0.0000],\n...     [ 0.0000, -0.8944, -0.4472],\n...     [ 0.0000, -0.4472,  0.8944]\n...     ], dtype=np.float64, order='F')\n>>> a_out, b_out, c_out, ncont, indcon, nblk, z, tau, info = slicot.tb01uy(\n...     'I', n, m1, m2, p, a, b, c, tol=0.0)\n...     a_out[:ncont, :ncont], expected_acont, rtol=1e-3, atol=1e-4)\n...     b_out[:ncont, :], expected_bcont, rtol=1e-3, atol=1e-4)\n...     c_out[:, :ncont], expected_ccont, rtol=1e-3, atol=1e-4)\n>>> info\n0",
  "tb01vd": "Convert discrete-time system to output normal form.\n\nConverts a stable discrete-time system (A, B, C, D) with initial state x0\ninto the output normal form, producing parameter vector THETA.\n\nParameters:\n  n (int): System order\n  m (int): Number of inputs\n  l (int): Number of outputs\n  a (ndarray): State matrix (n x n, F-order), modified on exit\n  b (ndarray): Input matrix (n x m, F-order), modified on exit\n  c (ndarray): Output matrix (l x n, F-order), modified on exit\n  d (ndarray): Feedthrough matrix (l x m, F-order), not modified\n  x0 (ndarray): Initial state (n,), modified on exit\n  apply (str, optional): 'A' = apply bijective mapping, 'N' = no mapping (default)\n\nReturns:\n  (theta, a, b, c, scale, info): Parameter vector, transformed matrices, scale factor, exit code\n  info=0: success, info=1: Lyapunov scale=0, info=2: unstable A, info=3: QR failed\n\nExamples:\n\n>>> from slicot import tb01vd\n>>> import numpy as np\n>>> n, m, l = 2, 1, 1\n>>> a = np.array([\n...     [0.5, 0.1],\n...     [0.0, 0.3]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0],\n...     [0.5]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.5]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [0.0]\n...     ], order='F', dtype=float)\n>>> x0 = np.array([0.1, 0.2], dtype=float)\n>>> theta, a_out, b_out, c_out, scale, info = tb01vd(\n...     n, m, l, a, b, c, d, x0, apply='N'\n...     )\n>>> info\n0",
  "tb01vy": "Convert output normal form to state-space representation.\n\nParameters:\n  n (int): System order\n  m (int): Number of inputs\n  l (int): Number of outputs\n  theta (ndarray): Parameter vector (N*(L+M+1)+L*M, F-order)\n  apply (str, optional): 'A' = apply bijective mapping, 'N' = no mapping (default)\n\nReturns:\n  (a, b, c, d, x0, info): State-space matrices, initial state, exit code\n\nExamples:\n\n>>> from slicot import tb01vy\n>>> import numpy as np\n>>> n = 2\n>>> m = 1\n>>> l = 2\n>>> theta = np.array([\n...     0.1, 0.2, 0.3, 0.4,\n...     0.5, 0.6,\n...     0.7, 0.8,\n...     0.9, 1.0\n...     ], dtype=float, order='F')\n>>> a, b, c, d, x0, info = slicot.tb01vy(n, m, l, theta, apply='N')\n>>> eig_a = np.linalg.eigvals(a)\n>>> t = np.arange(10)\n>>> u_seq = np.zeros((len(t), m))\n>>> u_seq[0, 0] = 1.0  # Impulse at t=0\n>>> x_k = x0.copy()\n>>> y_out = np.zeros((len(t), l))\n...     y_out[k, :] = (c @ x_k + d @ u_seq[k, :]).flatten()\n...     x_k = a @ x_k + b @ u_seq[k, :]\n>>> info\n0",
  "tb01wd": "Reduce state matrix to real Schur form via orthogonal transformation.\n\nParameters:\n  n (int): Order of state matrix A\n  m (int): Number of inputs (columns of B)\n  p (int): Number of outputs (rows of C)\n  a (ndarray): State dynamics matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n\nReturns:\n  (a, b, c, u, wr, wi, info): Transformed system, Schur vectors, eigenvalues, exit code\n\nExamples:\n\n>>> from slicot import tb01wd\n>>> import numpy as np\n>>> n, m, p = 5, 2, 3\n>>> a = np.array([\n...     [-0.04165,    4.9200,   -4.9200,         0,         0],\n...     [-1.387944,   -3.3300,         0,         0,         0],\n...     [   0.5450,         0,         0,   -0.5450,         0],\n...     [        0,         0,    4.9200,  -0.04165,    4.9200],\n...     [        0,         0,         0, -1.387944,   -3.3300]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [       0,         0],\n...     [  3.3300,         0],\n...     [       0,         0],\n...     [       0,         0],\n...     [       0,    3.3300]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [1, 0, 0, 0, 0],\n...     [0, 0, 1, 0, 0],\n...     [0, 0, 0, 1, 0]\n...     ], dtype=np.float64, order='F')\n>>> expected_wr = np.array([-0.7483, -0.7483, -1.6858, -1.6858, -1.8751])\n>>> expected_wi = np.array([2.9940, -2.9940, 2.0311, -2.0311, 0.0])\n>>> expected_a = np.array([\n...     [-0.7483,  -8.6406,   0.0000,   0.0000,   1.1745],\n...     [ 1.0374,  -0.7483,   0.0000,   0.0000,  -2.1164],\n...     [ 0.0000,   0.0000,  -1.6858,   5.5669,   0.0000],\n...     [ 0.0000,   0.0000,  -0.7411,  -1.6858,   0.0000],\n...     [ 0.0000,   0.0000,   0.0000,   0.0000,  -1.8751]\n...     ], dtype=np.float64, order='F')\n>>> expected_b = np.array([\n...     [-0.5543,   0.5543],\n...     [-1.6786,   1.6786],\n...     [-0.8621,  -0.8621],\n...     [ 2.1912,   2.1912],\n...     [-1.5555,   1.5555]\n...     ], dtype=np.float64, order='F')\n>>> expected_c = np.array([\n...     [ 0.6864,  -0.0987,   0.6580,   0.2589,  -0.1381],\n...     [-0.0471,   0.6873,   0.0000,   0.0000,  -0.7249],\n...     [-0.6864,   0.0987,   0.6580,   0.2589,   0.1381]\n...     ], dtype=np.float64, order='F')\n>>> expected_u = np.array([\n...     [ 0.6864,  -0.0987,   0.6580,   0.2589,  -0.1381],\n...     [-0.1665,  -0.5041,  -0.2589,   0.6580,  -0.4671],\n...     [-0.0471,   0.6873,   0.0000,   0.0000,  -0.7249],\n...     [-0.6864,   0.0987,   0.6580,   0.2589,   0.1381],\n...     [ 0.1665,   0.5041,  -0.2589,   0.6580,   0.4671]\n...     ], dtype=np.float64, order='F')\n>>> a_out, b_out, c_out, u, wr, wi, info = slicot.tb01wd(n, m, p, a, b, c)\n>>> u_orth = u.T @ u\n>>> info\n0",
  "tb01wx": "Reduce state matrix to upper Hessenberg form via orthogonal similarity.\n\nReduces: A <- U'*A*U (Hessenberg), B <- U'*B, C <- C*U\n\nParameters:\n  compu (str): 'N' = no U, 'I' = initialize U to identity, 'U' = update given U1\n  n (int): Order of state matrix A\n  m (int): Number of inputs (columns of B)\n  p (int): Number of outputs (rows of C)\n  a (ndarray): State dynamics matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  u (ndarray, optional): For COMPU='U', orthogonal matrix to update (n x n, F-order)\n  ldwork (int, optional): Workspace size (-1 for query, default: automatic)\n\nReturns:\n  (a, b, c, u, dwork, info): Hessenberg A, transformed B and C, transformation U, workspace, exit code\n\nExamples:\n\n>>> from slicot import tb01wx\n>>> import numpy as np\n>>> n, m, p = 5, 2, 3\n>>> a = np.array([\n...     [-0.04165,  4.9200, -4.9200,  0.0000,  0.0000],\n...     [-1.387944, -3.3300,  0.0000,  0.0000,  0.0000],\n...     [ 0.5450,   0.0000,  0.0000, -0.5450,  0.0000],\n...     [ 0.0000,   0.0000,  4.9200, -0.04165,  4.9200],\n...     [ 0.0000,   0.0000,  0.0000, -1.387944, -3.3300]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0000,  0.0000],\n...     [3.3300,  0.0000],\n...     [0.0000,  0.0000],\n...     [0.0000,  0.0000],\n...     [0.0000,  3.3300]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 1.0, 0.0]\n...     ], order='F', dtype=float)\n>>> a_hess, b_trans, c_trans, u, dwork, info = tb01wx('I', n, m, p, a, b, c)\n>>> info\n0",
  "tb01xd": "Special similarity transformation of dual state-space system.\n\nApplies: A <-- P*A'*P, B <-- P*C', C <-- B'*P, D <-- D' (optional)\nwhere P has 1s on secondary diagonal (anti-identity matrix).\n\nParameters:\n  jobd (str): 'D' if D is present, 'Z' if D is zero matrix\n  n (int): Order of state matrix A (n >= 0)\n  m (int): Number of columns of B (m >= 0)\n  p (int): Number of rows of C (p >= 0)\n  kl (int): Number of subdiagonals of A (0 <= kl <= max(0,n-1))\n  ku (int): Number of superdiagonals of A (0 <= ku <= max(0,n-1))\n  a (ndarray): State matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x max(m,p), F-order)\n  c (ndarray): Output matrix (max(m,p) x n, F-order)\n  d (ndarray): Feedthrough matrix (max(m,p) x max(m,p), F-order)\n\nReturns:\n  (a, b, c, d, info): Transformed matrices and exit code\n\nExamples:\n\n>>> from slicot import tb01xd\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> kl = n - 1\n>>> ku = n - 1\n>>> a_out, b_out, c_out, d_out, info = tb01xd('D', n, m, p, kl, ku, a, b, c, d)\n>>> P = create_permutation_matrix(n)\n>>> info\n0",
  "tb01xz": "Special similarity transformation of dual state-space system (complex).\n\nApplies: A <-- P*A'*P, B <-- P*C', C <-- B'*P, D <-- D' (optional)\nwhere P has 1s on secondary diagonal (anti-identity matrix).\nComplex version of tb01xd.\n\nParameters:\n  jobd (str): 'D' if D is present, 'Z' if D is zero matrix\n  n (int): Order of state matrix A (n >= 0)\n  m (int): Number of columns of B (m >= 0)\n  p (int): Number of rows of C (p >= 0)\n  kl (int): Number of subdiagonals of A (0 <= kl <= max(0,n-1))\n  ku (int): Number of superdiagonals of A (0 <= ku <= max(0,n-1))\n  a (ndarray): Complex state matrix (n x n, F-order, dtype=complex)\n  b (ndarray): Complex input matrix (n x max(m,p), F-order, dtype=complex)\n  c (ndarray): Complex output matrix (max(m,p) x n, F-order, dtype=complex)\n  d (ndarray): Complex feedthrough matrix (max(m,p) x max(m,p), F-order, dtype=complex)\n\nReturns:\n  (a, b, c, d, info): Transformed complex matrices and exit code\n\nExamples:\n\n>>> from slicot import tb01xz\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> kl = n - 1\n>>> ku = n - 1\n>>> a_out, b_out, c_out, d_out, info = tb01xz('D', n, m, p, kl, ku, a, b, c, d)\n>>> P = create_permutation_matrix(n)\n>>> info\n0",
  "tb01zd": "Controllable realization for single-input system.\n\nFinds controllable realization for the single-input system\ndX/dt = A*X + B*U, Y = C*X by reducing to orthogonal canonical form.\n\nParameters:\n  jobz (str): 'N'=no Z, 'F'=factored form, 'I'=identity initialized\n  n (int): Order of state matrix A\n  p (int): Number of outputs (rows of C)\n  a (ndarray): State dynamics matrix (n x n, F-order)\n  b (ndarray): Input vector (n, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float, optional): Tolerance for controllability (default: 0.0)\n\nReturns:\n  (a, b, c, ncont, z, tau, info): Transformed system and metadata\n\nExamples:\n\n>>> from slicot import tb01zd\n>>> import numpy as np\n>>> n, p = 3, 2\n>>> a = np.array([\n...     [0.0, 1.0, 0.0],\n...     [0.0, 0.0, 1.0],\n...     [-1.0, -2.0, -3.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([0.0, 0.0, 1.0], dtype=np.float64)\n>>> c = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> a_out, b_out, c_out, ncont, z, tau, info = slicot.tb01zd(\n...     'I', n, p, a, b, c, tol=0.0)\n>>> info\n0",
  "tb03ad": "Convert state-space to polynomial matrix fraction.\n\nComputes left inv(P(s))*Q(s) or right Q(s)*inv(P(s)) polynomial matrix\nrepresentation with same transfer function as state-space (A,B,C,D).\n\nParameters:\n  leri (str): 'L' for left, 'R' for right fraction\n  equil (str): 'S' to balance (A,B,C), 'N' for no balancing\n  n (int): Order of state-space representation\n  m (int): Number of inputs\n  p (int): Number of outputs\n  a (ndarray): State matrix (n, n) F-order\n  b (ndarray): Input matrix (n, max(m,p)) F-order\n  c (ndarray): Output matrix (max(m,p), n) F-order\n  d (ndarray): Feedthrough matrix (max(m,p), max(m,p)) F-order\n  tol (float): Tolerance for rank decisions (default 0.0)\n\nReturns:\n  (a, b, c, nr, index, pcoeff, qcoeff, vcoeff, iwork, info)\n\nExamples:\n\n>>> from slicot import tb03ad\n>>> import numpy as np\n>>> n, m, p = 3, 1, 2\n>>> a = np.array([\n...     [1.0, 2.0, 0.0],\n...     [4.0, -1.0, 0.0],\n...     [0.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0],\n...     [0.0],\n...     [1.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [0.0, 1.0, -1.0],\n...     [0.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> d = np.array([\n...     [0.0],\n...     [1.0]\n...     ], dtype=np.float64, order='F')\n>>> expected_nr = 3\n>>> expected_index = np.array([3], dtype=np.int32)\n>>> expected_amin = np.array([\n...     [1.0000, -1.4142, 0.0000],\n...     [-2.8284, -1.0000, 2.8284],\n...     [0.0000, 1.4142, 1.0000]\n...     ], dtype=np.float64, order='F')\n>>> expected_pcoeff = np.array([0.1768, -0.1768, -1.5910, 1.5910],\n...     dtype=np.float64)\n>>> expected_qcoeff_row1 = np.array([0.0000, -0.1768, 0.7071, 0.8839],\n...     dtype=np.float64)\n>>> expected_qcoeff_row2 = np.array([0.1768, 0.0000, -1.5910, 0.0000],\n...     dtype=np.float64)\n>>> result = slicot.tb03ad('R', 'N', n, m, p, a, b, c, d, tol=0.0)\n>>> a_out, b_out, c_out, nr, index, pcoeff, qcoeff, vcoeff, iwork, info = result\n>>> actual_eigs = np.sort(np.linalg.eigvals(a_out[:nr, :nr]).real)\n>>> expected_eigs = np.sort(np.linalg.eigvals(expected_amin).real)\n>>> kpcoef = max(index[:m]) + 1\n...     pcoeff[0, 0, :kpcoef], expected_pcoeff, rtol=1e-3, atol=1e-4)\n...     qcoeff[0, 0, :kpcoef], expected_qcoeff_row1, rtol=1e-3, atol=1e-4)\n...     qcoeff[1, 0, :kpcoef], expected_qcoeff_row2, rtol=1e-3, atol=1e-4)",
  "tb03ay": "Compute polynomial matrix V(s) block by block.\n\nInternal helper for TB03AD. Calculates V(s) one block at a time.\n\nParameters:\n  nr (int): Total state dimension\n  a (ndarray): State matrix in upper block Hessenberg form (F-order)\n  nblk (ndarray): Block sizes array (int32)\n  vcoeff (ndarray): V(s) coefficient array (ldvco1, ldvco2, indblk+1)\n  pcoeff (ndarray): P(s) coefficient array (workspace)\n\nReturns:\n  (vcoeff, pcoeff, info): Modified arrays and exit code\n\nExamples:\n\n>>> from slicot import tb03ay\n>>> import numpy as np\n>>> nr = 1\n>>> indblk = 1\n>>> nblk = np.array([1], dtype=np.int32)\n>>> a = np.array([\n...     [2.0, 1.0],\n...     [0.0, 3.0]\n...     ], dtype=float, order='F')\n>>> lda = 2\n>>> ldvco1 = 1\n>>> ldvco2 = nr\n>>> ldpco1 = 1\n>>> ldpco2 = 1\n>>> vcoeff = np.zeros((ldvco1, ldvco2, indblk + 1), dtype=float, order='F')\n>>> vcoeff[0, 0, indblk] = 1.0\n>>> pcoeff = np.zeros((ldpco1, ldpco2, indblk + 1), dtype=float, order='F')\n>>> vcoeff_out, pcoeff_out, info = tb03ay(\n...     nr, a, nblk, vcoeff, pcoeff\n...     )\n>>> info\n0",
  "tb04ad": "Convert state-space to transfer function representation.\n\nComputes the transfer function matrix T(s) as rows over common\ndenominators or columns over common denominators.\n\nT(s) = C * (sI - A)^(-1) * B + D\n\nParameters:\n  rowcol (str): 'R' rows over denominators, 'C' columns over denominators\n  a (ndarray): N-by-N state matrix A (F-order)\n  b (ndarray): N-by-M input matrix B (F-order)\n  c (ndarray): P-by-N output matrix C (F-order)\n  d (ndarray): P-by-M feedthrough matrix D (F-order)\n  tol1 (float): Tolerance for rank determination (default 0.0)\n  tol2 (float): Tolerance for controllability (default 0.0)\n\nReturns:\n  (nr, index, dcoeff, ucoeff, info):\n    nr: Order of controllable part\n    index: Degrees of denominator polynomials\n    dcoeff: Denominator polynomial coefficients\n    ucoeff: Numerator polynomial coefficients\n    info: 0=success\n\nExamples:\n\n>>> from slicot import tb04ad\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0],\n...     [ 0.0, -2.0,  0.0],\n...     [ 0.0,  0.0, -3.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [ 0.0,  1.0],\n...     [ 1.0,  1.0],\n...     [-1.0,  0.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [0.0, 1.0, 1.0],\n...     [1.0, 1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a_out, b_out, c_out, d_out, nr, index, dcoeff, ucoeff, info = tb04ad('R', a, b, c, d)\n...     s = 1j * omega\n...     eye = np.eye(n)\n...     t_direct = c @ np.linalg.solve(s * eye - a, b) + d\n...     t_poly = np.zeros((p, m), dtype=complex)\n...     deg = index[i]\n...     den_val = sum(dcoeff[i, k] * s**(deg - k) for k in range(deg + 1))\n...     num_val = sum(ucoeff[i, j, k] * s**(deg - k) for k in range(deg + 1))\n...     t_poly[i, j] = num_val / den_val\n>>> info\n0",
  "tb04bd": "Transfer function matrix via pole-zero method.\n\nComputes the transfer function matrix G of a state-space representation\n(A,B,C,D) using the pole-zeros method. Each element is returned in\nminimal form with numerator and denominator polynomials.\n\nParameters:\n  jobd (str): 'D' if D matrix present, 'Z' if D is zero\n  order (str): 'I' increasing powers, 'D' decreasing powers\n  equil (str): 'S' equilibrate (A,B,C), 'N' no equilibration\n  n (int): System order (n >= 0)\n  m (int): Number of inputs (m >= 0)\n  p (int): Number of outputs (p >= 0)\n  md (int): Max polynomial degree + 1 (md >= 1, upper bound n+1)\n  a (ndarray): State matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order), destroyed on exit\n  c (ndarray): Output matrix (p x n, F-order)\n  d (ndarray): Feedthrough matrix (p x m, F-order)\n  tol (float): Controllability tolerance (default 0.0)\n\nReturns:\n  (ign, igd, gn, gd, info):\n    ign: Numerator degrees (p x m, int32)\n    igd: Denominator degrees (p x m, int32)\n    gn: Numerator coefficients (p*m*md,)\n    gd: Denominator coefficients (p*m*md,)\n    info: 0=success, 1=QR failed for zeros, 2=QR failed for poles\n\nExamples:\n\n>>> from slicot import tb04bd\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> md = n + 1\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0],\n...     [ 0.0, -2.0,  0.0],\n...     [ 0.0,  0.0, -3.0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [0.0, 1.0],\n...     [1.0, 1.0],\n...     [-1.0, 0.0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [0.0, 1.0, 1.0],\n...     [1.0, 1.0, 1.0]\n...     ], dtype=float, order='F')\n>>> d = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], dtype=float, order='F')\n>>> ign, igd, gn, gd, info = tb04bd('D', 'I', 'N', n, m, p, md, a, b, c, d, tol=1e-10)\n>>> idx = 0  # (i=0, j=0) -> index = ((0)*p + 0)*md = 0\n>>> idx = 1 * md  # (i=1, j=0) -> index = ((0)*p + 1)*md = md\n>>> idx = p * md  # (i=0, j=1) -> index = ((1)*p + 0)*md = p*md\n>>> idx = (p + 1) * md  # (i=1, j=1) -> index = ((1)*p + 1)*md = (p+1)*md\n>>> info\n0",
  "tb04bv": "Separate strictly proper part from constant part of transfer function matrix.\n\nSeparates proper P-by-M transfer function G into G = G0 + D where\nG0 is strictly proper (deg(num) < deg(den)) and D is constant.\n\nParameters:\n  order (str): 'I' increasing, 'D' decreasing polynomial order\n  p (int): Number of outputs (p >= 0)\n  m (int): Number of inputs (m >= 0)\n  md (int): Max polynomial degree + 1\n  ign (ndarray): Numerator degrees (p x m, int32, F-order), modified\n  igd (ndarray): Denominator degrees (p x m, int32, F-order)\n  gn (ndarray): Numerator coefficients (p*m*md,), modified\n  gd (ndarray): Denominator coefficients (p*m*md,)\n  tol (float): Tolerance for negligible coefficients (default 0.0)\n\nReturns:\n  (ign, gn, d, info):\n    ign: Updated numerator degrees of G0\n    gn: Updated numerator coefficients of G0\n    d: Feedthrough matrix D (p x m)\n    info: 0=success, 1=not proper, 2=null denominator\n\nExamples:\n\n>>> from slicot import tb04bv\n>>> import numpy as np\n>>> p, m, md = 1, 1, 2\n>>> ign = np.array([[1]], order='F', dtype=np.int32)\n>>> igd = np.array([[1]], order='F', dtype=np.int32)\n>>> gn = np.array([5.0, 1.0], order='F', dtype=float)\n>>> gd = np.array([3.0, 1.0], order='F', dtype=float)\n>>> ign_out, gn_out, d, info = tb04bv('I', p, m, md, ign, igd, gn, gd)\n>>> info\n0",
  "tb04bw": "Add real matrix D to rational matrix G (G + D).\n\nComputes the sum G + D where G is a P-by-M rational matrix (polynomial\nratios) and D is a P-by-M real matrix. The result replaces G in-place.\n\nIf g(i,j) = 0 (both degrees zero and numerator zero), its denominator is\nassumed to be 1.\n\nParameters:\n  order (str): 'I' increasing, 'D' decreasing polynomial order\n  p (int): Number of outputs (p >= 0)\n  m (int): Number of inputs (m >= 0)\n  md (int): Max polynomial degree + 1\n  ign (ndarray): Numerator degrees (p x m, int32, F-order), modified\n  igd (ndarray): Denominator degrees (p x m, int32, F-order)\n  gn (ndarray): Numerator coefficients (p*m*md,), modified\n  gd (ndarray): Denominator coefficients (p*m*md,)\n  d (ndarray): Real matrix D (p x m, F-order)\n\nReturns:\n  (ign, gn, info):\n    ign: Updated numerator degrees of G + D\n    gn: Updated numerator coefficients of G + D\n    info: 0=success, -i=parameter i invalid\n\nExamples:\n\n>>> from slicot import tb04bw\n>>> import numpy as np\n>>> p, m, md = 1, 1, 2\n>>> ign = np.array([[1]], dtype=np.int32, order='F')\n>>> igd = np.array([[1]], dtype=np.int32, order='F')\n>>> gn = np.array([1.0, 2.0], dtype=np.float64, order='F')\n>>> gd = np.array([1.0, 1.0], dtype=np.float64, order='F')\n>>> d = np.array([[3.0]], dtype=np.float64, order='F')\n>>> ign_out, gn_out, info = tb04bw('I', p, m, md, ign, igd, gn, gd, d)\n>>> info\n0",
  "tb04bx": "Compute gain of SISO system from state-space, poles, and zeros.\n\nComputes the gain of a single-input single-output linear system,\ngiven its state-space representation (A,b,c,d), and its poles and\nzeros. The matrix A must be in upper Hessenberg form.\n\nThe gain formula is:\n  g = (c*(S0*I - A)^(-1)*b + d) * prod(S0 - Pi) / prod(S0 - Zi)\n\nwhere Pi are poles, Zi are zeros, and S0 is chosen away from all\npoles and zeros.\n\nParameters:\n  ip (int): Number of system poles (ip >= 0)\n  iz (int): Number of system zeros (iz >= 0)\n  a (ndarray): IP-by-IP state matrix in upper Hessenberg form (F-order)\n  b (ndarray): System input vector (ip,)\n  c (ndarray): System output vector (ip,)\n  d (float): System feedthrough scalar\n  pr (ndarray): Real parts of poles (ip,)\n  pi (ndarray): Imaginary parts of poles (ip,)\n  zr (ndarray): Real parts of zeros (iz,)\n  zi (ndarray): Imaginary parts of zeros (iz,)\n\nReturns:\n  gain (float): Computed gain of the linear system\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tb04bx\n>>> ip = 1\n>>> iz = 0\n>>> a = np.array([[-1.0]], order='F', dtype=float)\n>>> b = np.array([1.0], dtype=float)\n>>> c = np.array([2.0], dtype=float)\n>>> d = 0.0\n>>> pr = np.array([-1.0], dtype=float)\n>>> pi = np.array([0.0], dtype=float)\n>>> zr = np.array([], dtype=float)\n>>> zi = np.array([], dtype=float)\n>>> gain = tb04bx(ip, iz, a, b, c, d, pr, pi, zr, zi)",
  "tb04cd": "State-space to minimal pole-zero-gain form.\n\nComputes the transfer function matrix G of a state-space representation\n(A,B,C,D) using the pole-zeros method. Each SISO channel is returned in\nminimal pole-zero-gain form.\n\nParameters:\n  jobd (str): 'D' if D matrix present, 'Z' if D is zero\n  equil (str): 'S' equilibrate (A,B,C), 'N' no equilibration\n  a (ndarray): State matrix (n x n, F-order), modified if equil='S'\n  b (ndarray): Input matrix (n x m, F-order), destroyed on exit\n  c (ndarray): Output matrix (p x n, F-order), modified if equil='S'\n  d (ndarray): Feedthrough matrix (p x m, F-order), not used if jobd='Z'\n  npz (int): Max poles/zeros per SISO channel (upper bound n)\n  tol (float): Controllability tolerance (default 0.0)\n\nReturns:\n  (nz, np, zerosr, zerosi, polesr, polesi, gains, info):\n    nz: Number of zeros per element (p x m, int32)\n    np: Number of poles per element (p x m, int32)\n    zerosr: Real parts of zeros (p*m*npz,)\n    zerosi: Imaginary parts of zeros (p*m*npz,)\n    polesr: Real parts of poles (p*m*npz,)\n    polesi: Imaginary parts of poles (p*m*npz,)\n    gains: Gain of each element (p x m)\n    info: 0=success, 1=QR failed for zeros, 2=QR failed for poles\n\nExamples:\n\n>>> from slicot import tb04cd\n>>> import numpy as np\n>>> n, m, p = 3, 2, 2\n>>> npz = n\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0],\n...     [ 0.0, -2.0,  0.0],\n...     [ 0.0,  0.0, -3.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [ 0.0,  1.0],\n...     [ 1.0,  1.0],\n...     [-1.0,  0.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [0.0, 1.0, 1.0],\n...     [1.0, 1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> nz, np_arr, zerosr, zerosi, polesr, polesi, gains, info = tb04cd(\n...     'D', 'N', a, b, c, d, npz, tol=0.0\n...     )\n>>> idx_11 = 0  # ((1-1)*2 + 1-1)*3 = 0\n>>> zeros_11 = np.sort(zerosr[idx_11:idx_11+nz[0, 0]])\n>>> zeros_11_imag = np.sort(np.abs(zerosi[idx_11:idx_11+nz[0, 0]]))\n>>> poles_11 = np.sort(polesr[idx_11:idx_11+np_arr[0, 0]])\n>>> info\n0",
  "tb05ad": "Frequency response matrix of state-space system.\n\nComputes G(freq) = C * (freq*I - A)^(-1) * B.\n\nParameters:\n  baleig (str): 'N' no balance, 'C' condition est, 'B'/'E' balance+eig, 'A' all\n  inita (str): 'G' general matrix, 'H' Hessenberg form\n  a (ndarray): N-by-N state matrix A (F-order)\n  b (ndarray): N-by-M input matrix B (F-order)\n  c (ndarray): P-by-N output matrix C (F-order)\n  freq (complex): Evaluation frequency\n\nReturns:\n  (g, rcond, evre, evim, hinvb, info): Frequency response G(freq),\n    condition estimate, eigenvalues (real/imag), H^(-1)*B, exit code\n\nExamples:\n\n>>> from slicot import tb05ad\n>>> import numpy as np\n>>> n, m, p = 3, 1, 2\n>>> a = np.array([\n...     [1.0, 2.0, 0.0],\n...     [4.0, -1.0, 0.0],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0],\n...     [0.0],\n...     [1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, -1.0],\n...     [0.0, 0.0, 1.0]\n...     ], order='F', dtype=float)\n>>> freq = 0.0 + 0.5j\n>>> g, rcond, evre, evim, hinvb, info = tb05ad(\n...     'A', 'G', a, b, c, freq\n...     )\n>>> eig_computed = evre + 1j * evim\n...     sorted(eig_computed.real),\n...     rtol=1e-13\n>>> )\n>>> info\n0",
  "tc01od": "Find dual polynomial matrix representation.\n\nFinds the dual right (left) polynomial matrix representation of a given\nleft (right) polynomial matrix representation by transposing both the\nnumerator Q(s) and denominator P(s) polynomial matrices.\n\nParameters:\n  leri (str): 'L' for left matrix fraction, 'R' for right matrix fraction\n  m (int): Number of system inputs\n  p (int): Number of system outputs\n  pcoeff (ndarray): Denominator polynomial coefficients (porm x porm x indlim, F-order)\n  qcoeff (ndarray): Numerator polynomial coefficients (max(m,p) x max(m,p) x indlim, F-order)\n\nReturns:\n  (pcoeff, qcoeff, info): Transposed coefficient matrices, exit code\n\nExamples:\n\n>>> from slicot import tc01od\n>>> import numpy as np\n>>> m = 2\n>>> p = 2\n>>> indlim = 3\n>>> pcoeff = np.zeros((p, p, indlim), dtype=float, order='F')\n>>> pcoeff[0, 0, :] = [2.0, 3.0, 1.0]\n>>> pcoeff[0, 1, :] = [4.0, -1.0, -1.0]\n>>> pcoeff[1, 0, :] = [5.0, 7.0, -6.0]\n>>> pcoeff[1, 1, :] = [3.0, 2.0, 2.0]\n>>> qcoeff = np.zeros((p, m, indlim), dtype=float, order='F')\n>>> qcoeff[0, 0, :] = [6.0, -1.0, 5.0]\n>>> qcoeff[0, 1, :] = [1.0, 7.0, 5.0]\n>>> qcoeff[1, 0, :] = [1.0, 1.0, 1.0]\n>>> qcoeff[1, 1, :] = [4.0, 1.0, -1.0]\n>>> pcoeff_out, qcoeff_out, info = tc01od('L', m, p, pcoeff, qcoeff)\n>>> info\n0",
  "tc04ad": "Convert polynomial matrix representation to state-space.\n\nFinds a state-space representation (A,B,C,D) with the same transfer\nmatrix T(s) as a given left or right polynomial matrix representation:\n  T(s) = inv(P(s))*Q(s) for left,  T(s) = Q(s)*inv(P(s)) for right\n\nUses Wolovich's Observable Structure Theorem to construct observable\ncompanion form. For right matrix fractions, converts via duality.\n\nParameters:\n  leri (str): 'L' for left PMR inv(P(s))*Q(s), 'R' for right PMR Q(s)*inv(P(s))\n  m (int): Number of system inputs (m >= 0)\n  p (int): Number of system outputs (p >= 0)\n  index (ndarray): Row/column degrees of P(s), int32 array of length max(m,p)\n  pcoeff (ndarray): Denominator coefficients (porm x porm x kpcoef, F-order)\n  qcoeff (ndarray): Numerator coefficients (porm x porp x kpcoef, F-order)\n\nReturns:\n  (n, rcond, a, b, c, d, info): State order, condition number,\n    state-space matrices (A n-by-n, B n-by-m, C p-by-n, D p-by-m), exit code\n    info=1 means P(s) is not row/column proper\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tc04ad\n>>> m, p = 2, 2\n>>> index = np.array([2, 2], dtype=np.int32)\n>>> pcoeff = np.zeros((p, p, 3), order='F', dtype=float)\n>>> pcoeff[0, 0, :] = [2.0, 3.0, 1.0]\n>>> pcoeff[0, 1, :] = [4.0, -1.0, -1.0]\n>>> pcoeff[1, 0, :] = [5.0, 7.0, -6.0]\n>>> pcoeff[1, 1, :] = [3.0, 2.0, 2.0]\n>>> qcoeff = np.zeros((p, m, 3), order='F', dtype=float)\n>>> qcoeff[0, 0, :] = [6.0, -1.0, 5.0]\n>>> qcoeff[0, 1, :] = [1.0, 7.0, 5.0]\n>>> qcoeff[1, 0, :] = [1.0, 1.0, 1.0]\n>>> qcoeff[1, 1, :] = [4.0, 1.0, -1.0]\n>>> n, rcond, a, b, c, d, info = tc04ad('L', m, p, index, pcoeff, qcoeff)\n>>> info\n0",
  "tc05ad": "Evaluate transfer matrix at complex frequency.\n\nComputes the frequency response matrix T(s) of a left or right polynomial\nmatrix representation at a specified complex frequency s = SVAL:\n  T(s) = inv(P(s))*Q(s) for left PMR\n  T(s) = Q(s)*inv(P(s)) for right PMR\n\nFor standard frequency response, use SVAL = (0, omega) for frequency omega.\n\nParameters:\n  leri (str): 'L' for left PMR, 'R' for right PMR\n  m (int): Number of system inputs (m >= 0)\n  p (int): Number of system outputs (p >= 0)\n  sval (complex): Complex frequency at which to evaluate\n  index (ndarray): Polynomial degrees, int32 array of length max(m,p)\n  pcoeff (ndarray): Denominator coefficients (porm x porm x kpcoef, F-order)\n  qcoeff (ndarray): Numerator coefficients (porm x porp x kpcoef, F-order)\n\nReturns:\n  (rcond, cfreqr, info): Reciprocal condition of P(SVAL),\n    complex frequency response matrix (p x m), exit code.\n    info=1 means P(SVAL) is exactly or nearly singular.\n\nExamples:\n\n>>> from slicot import tc05ad\n>>> import numpy as np\n>>> m = 2\n>>> p = 2\n>>> sval = complex(0.0, 0.5)\n>>> index = np.array([2, 2], dtype=np.int32)\n>>> pcoeff = np.zeros((2, 2, 3), dtype=np.float64, order='F')\n>>> pcoeff[0, 0, :] = [2.0, 3.0, 1.0]\n>>> pcoeff[0, 1, :] = [4.0, -1.0, -1.0]\n>>> pcoeff[1, 0, :] = [5.0, 7.0, -6.0]\n>>> pcoeff[1, 1, :] = [3.0, 2.0, 2.0]\n>>> qcoeff = np.zeros((2, 2, 3), dtype=np.float64, order='F')\n>>> qcoeff[0, 0, :] = [6.0, -1.0, 5.0]\n>>> qcoeff[0, 1, :] = [1.0, 7.0, 5.0]\n>>> qcoeff[1, 0, :] = [1.0, 1.0, 1.0]\n>>> qcoeff[1, 1, :] = [4.0, 1.0, -1.0]\n>>> rcond, cfreqr, info = tc05ad('L', m, p, sval, index, pcoeff, qcoeff)\n>>> expected = np.array([\n...     [complex(-0.25, -0.33), complex(0.26, -0.45)],\n...     [complex(-1.48, 0.35), complex(-2.25, -1.11)]\n...     ], dtype=np.complex128, order='F')\n>>> info\n0",
  "td03ad": "Polynomial matrix representation for proper transfer matrix.\n\nFinds a relatively prime left or right polynomial matrix representation\nfor a proper transfer matrix T(s) given as row or column polynomial\nvectors over common denominator polynomials.\n\nFor LERI='L': T(s) = inv(P(s)) * Q(s)\nFor LERI='R': T(s) = Q(s) * inv(P(s))\n\nAlso computes minimal state-space representation (A,B,C,D) en route.\n\nParameters:\n  rowcol (str): 'R' = T(s) factorized by rows, 'C' = by columns\n  leri (str): 'L' = left PMR inv(P)*Q, 'R' = right PMR Q*inv(P)\n  equil (str): 'S' = perform balancing, 'N' = no balancing\n  m (int): Number of system inputs\n  p (int): Number of system outputs\n  indexd (ndarray): Degrees of denominator polynomials, int32 array\n  dcoeff (ndarray): Denominator coefficients (porm x kdcoef, F-order)\n  ucoeff (ndarray): Numerator coefficients (p x m x kdcoef, F-order)\n  tol (float): Tolerance for rank determination (0 = default)\n\nReturns:\n  (nr, a, b, c, d, indexp, pcoeff, qcoeff, vcoeff, iwork, info):\n    nr (int): Minimal order\n    a (ndarray): State matrix (lda x n)\n    b (ndarray): Input matrix (ldb x max(m,p))\n    c (ndarray): Output matrix (ldc x n)\n    d (ndarray): Feedthrough matrix (ldd x max(m,p))\n    indexp (ndarray): Degrees of P(s) polynomials\n    pcoeff (ndarray): Denominator matrix P(s) coefficients\n    qcoeff (ndarray): Numerator matrix Q(s) coefficients\n    vcoeff (ndarray): Intermediate matrix V(s) coefficients\n    iwork (ndarray): Diagonal block orders of A\n    info (int): Exit code, 0 = success\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import td03ad\n>>> m, p = 2, 2\n>>> rowcol = 'R'\n>>> leri = 'L'\n>>> equil = 'N'\n>>> tol = 0.0\n>>> indexd = np.array([3, 3], dtype=np.int32)\n>>> kdcoef = 4\n>>> dcoeff = np.array([\n...     [1.0, 6.0, 11.0, 6.0],\n...     [1.0, 6.0, 11.0, 6.0]\n...     ], order='F', dtype=float)\n>>> ucoeff = np.zeros((p, m, kdcoef), order='F', dtype=float)\n>>> ucoeff[0, 0, :] = [1.0, 6.0, 12.0, 7.0]\n>>> ucoeff[0, 1, :] = [0.0, 1.0, 4.0, 3.0]\n>>> ucoeff[1, 0, :] = [0.0, 0.0, 1.0, 1.0]\n>>> ucoeff[1, 1, :] = [1.0, 8.0, 20.0, 15.0]\n>>> (nr, a, b, c, d, indexp, pcoeff, qcoeff, vcoeff, iwork, info) = td03ad(\n...     rowcol, leri, equil, m, p, indexd, dcoeff, ucoeff, tol\n...     )",
  "td03ay": "Calculate state-space from polynomial row vectors over diagonal denominators.\n\nHelper for TD04AD. Calculates state-space (A,B,C,D) for transfer matrix\nT(s) = inv(D(s)) * U(s) where D(s) is diagonal.\n\nParameters:\n  mwork (int): Number of inputs\n  pwork (int): Number of outputs\n  index (ndarray): Degrees of diagonal D(s) elements, int32 array\n  dcoeff (ndarray): Denominator coefficients (pwork x kdcoef, F-order)\n  ucoeff (ndarray): Numerator coefficients (pwork x mwork x kdcoef, F-order)\n  n (int): State-space order = sum(index)\n\nReturns:\n  (a, b, c, d, info): State-space matrices, exit code.\n    info > 0 means row info has near-zero leading coefficient.\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import td03ay\n>>> mwork, pwork = 1, 1\n>>> n = 1\n>>> index = np.array([1], dtype=np.int32)\n>>> dcoeff = np.array([[1.0, 3.0]], order='F', dtype=float)\n>>> ucoeff = np.zeros((1, 1, 2), order='F', dtype=float)\n>>> ucoeff[0, 0, :] = [2.0, 1.0]\n>>> a, b, c, d, info = td03ay(mwork, pwork, index, dcoeff, ucoeff, n)\n>>> info\n0",
  "td04ad": "Minimal state-space representation from transfer function.\n\nFinds a minimal state-space representation (A,B,C,D) for a proper\ntransfer matrix T(s) given as polynomial vectors over denominators.\n\nFor ROWCOL='R': T(s) = inv(D(s)) * U(s)\nFor ROWCOL='C': T(s) = U(s) * inv(D(s))\n\nParameters:\n  rowcol (str): 'R' = rows over common denominators,\n                'C' = columns over common denominators\n  m (int): Number of system inputs\n  p (int): Number of system outputs\n  index (ndarray): Degrees of denominator polynomials, int32 array\n  dcoeff (ndarray): Denominator coefficients (porm x kdcoef, F-order)\n  ucoeff (ndarray): Numerator coefficients (p x m x kdcoef, F-order)\n  tol (float): Tolerance for rank determination (0 = default)\n\nReturns:\n  (nr, a, b, c, d, info): Minimal order, state-space matrices, exit code.\n    info > 0 means row info has near-zero leading coefficient.\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import td04ad\n>>> m, p = 2, 2\n>>> rowcol = 'R'\n>>> tol = 0.0\n>>> index = np.array([3, 3], dtype=np.int32)\n>>> kdcoef = 4\n>>> dcoeff = np.array([\n...     [1.0, 6.0, 11.0, 6.0],\n...     [1.0, 6.0, 11.0, 6.0]\n...     ], order='F', dtype=float)\n>>> ucoeff = np.zeros((p, m, kdcoef), order='F', dtype=float)\n>>> ucoeff[0, 0, :] = [1.0, 6.0, 12.0, 7.0]\n>>> ucoeff[0, 1, :] = [0.0, 1.0, 4.0, 3.0]\n>>> ucoeff[1, 0, :] = [0.0, 0.0, 1.0, 1.0]\n>>> ucoeff[1, 1, :] = [1.0, 8.0, 20.0, 15.0]\n>>> nr, a, b, c, d, info = td04ad(rowcol, m, p, index, dcoeff, ucoeff, tol)\n>>> info\n0",
  "td05ad": "Evaluate transfer function G(jW) at specified frequency.\n\nGiven a complex valued rational transfer function G(jW), calculates its\ncomplex value or magnitude/phase for a specified frequency W.\n\n        B(1)+B(2)*(jW)+B(3)*(jW)^2+...+B(MP1)*(jW)^(MP1-1)\nG(jW) = --------------------------------------------------\n        A(1)+A(2)*(jW)+A(3)*(jW)^2+...+A(NP1)*(jW)^(NP1-1)\n\nParameters:\n  unitf (str): 'R' = frequency in radians/second, 'H' = frequency in hertz\n  output (str): 'C' = Cartesian (real/imag), 'P' = Polar (dB/degrees)\n  np1 (int): Denominator order + 1 (>= 1)\n  mp1 (int): Numerator order + 1 (>= 1)\n  w (float): Frequency value\n  a (ndarray): Denominator coefficients, ascending powers of jW\n  b (ndarray): Numerator coefficients, ascending powers of jW\n\nReturns:\n  (valr, vali, info): Output values and exit code.\n    For OUTPUT='C': valr = Re(G), vali = Im(G)\n    For OUTPUT='P': valr = magnitude in dB, vali = phase in degrees\n    info=1 means W is a pole or all A coefficients are zero.\n\nExamples:\n\n>>> from slicot import td05ad\n>>> import numpy as np\n>>> np1 = 6  # Denominator order + 1\n>>> mp1 = 4  # Numerator order + 1\n>>> w = 1.0\n>>> a = np.array([1.0, 1.0, 0.0, 0.0, 2.0, 1.0], dtype=float)\n>>> b = np.array([6.0, 2.0, 3.0, 1.0], dtype=float)\n>>> valr, vali, info = td05ad('R', 'C', np1, mp1, w, a, b)\n>>> info\n0",
  "tf01md": "Output response sequence of discrete-time state-space system.\n\nSimulates: x(k+1) = A*x(k) + B*u(k), y(k) = C*x(k) + D*u(k)\n\nParameters:\n  a (ndarray): State matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  d (ndarray): Feedthrough matrix (p x m, F-order)\n  u (ndarray): Input sequence (m x ny, F-order)\n  x (ndarray): Initial state vector (n,), modified in-place\n\nReturns:\n  (y, x_final, info): Output sequence (p x ny), final state, exit code\n\nExamples:\n\n>>> from slicot import tf01md\n>>> import numpy as np\n>>> n, m, p, ny = 3, 2, 2, 10\n>>> a = np.array([\n...     [0.0000, 1.0000, 0.0000],\n...     [-0.0700, 0.8000, 0.0000],\n...     [0.0150, -0.1500, 0.5000]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0000, -1.0000],\n...     [2.0000, -0.1000],\n...     [1.0000, 1.0000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [0.0000, 0.0000, 1.0000],\n...     [1.0000, 0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [1.0000, 0.0000],\n...     [0.5000, 0.5000]\n...     ], order='F', dtype=float)\n>>> x0 = np.array([1.0000, 1.0000, 1.0000], dtype=float)\n>>> u = np.array([\n...     [-0.6922, 0.3081, 2.0039, -0.9942, -1.5734, 0.4118, -0.9344, 0.8988, -0.0701, 0.0],\n...     [-1.4934, -2.7726, 0.2614, 1.8957, 1.5639, -1.4893, 1.2506, 0.2951, -0.9160, 0.0]\n...     ], order='F', dtype=float)\n>>> u_flat = np.array([\n...     -0.6922, -1.4934, 0.3081, -2.7726, 2.0039,\n...     0.2614, -0.9160, -0.6030, 1.2556, 0.2951,\n...     -1.5734, 1.5639, -0.9942, 1.8957, 0.8988,\n...     0.4118, -1.4893, -0.9344, 1.2506, -0.0701\n...     ], dtype=float)\n>>> u = u_flat.reshape((m, ny), order='F')\n>>> y, x_final, info = tf01md(a, b, c, d, u, x0.copy())\n>>> info\n0",
  "tf01mx": "Output sequence of linear time-invariant open-loop system.\n\nParameters:\n  n (int): Order of matrix A\n  m (int): Number of system inputs\n  p (int): Number of system outputs\n  ny (int): Number of output vectors to compute\n  s (ndarray): System matrix [A B; C D] (n+p x n+m, F-order)\n  u (ndarray): Input sequence (ny x m, F-order)\n  x (ndarray): Initial state vector (n, F-order)\n\nReturns:\n  (y, x, info): Output sequence, final state, exit code\n\nExamples:\n\n>>> from slicot import tf01mx\n>>> import numpy as np\n>>> n = 2\n>>> m = 1\n>>> p = 1\n>>> ny = 3\n>>> s = np.array([\n...     [0.5, 0.1, 1.0],\n...     [0.0, 0.8, 0.5],\n...     [1.0, 0.0, 0.0]\n...     ], dtype=float, order='F')\n>>> a = s[:n, :n].copy(order='F')\n>>> b = s[:n, n:].copy(order='F')\n>>> c = s[n:, :n].copy(order='F')\n>>> d = s[n:, n:].copy(order='F')\n>>> u = np.array([\n...     [1.0],\n...     [0.5],\n...     [0.0]\n...     ], dtype=float, order='F')\n>>> x0 = np.array([1.0, 0.5], dtype=float, order='F')\n>>> x = x0.copy()\n>>> y, x_final, info = tf01mx(n, m, p, ny, s, u, x)\n>>> y_reference = np.array([[1.0], [1.55], [1.365]], dtype=float)\n>>> info\n0",
  "tf01my": "Output sequence of discrete-time state-space system (variant).\n\nSimulates: x(k+1) = A*x(k) + B*u(k), y(k) = C*x(k) + D*u(k)\n\nThis variant differs from TF01MD in that input/output trajectories\nare stored row-wise: U is NY-by-M (rows are u(k)'), Y is NY-by-P\n(rows are y(k)').\n\nParameters:\n  a (ndarray): State matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  d (ndarray): Feedthrough matrix (p x m, F-order)\n  u (ndarray): Input sequence (ny x m, F-order), rows are u(k)'\n  x (ndarray): Initial state vector (n,), modified in-place\n\nReturns:\n  (y, x_final, info): Output sequence (ny x p), final state, exit code\n\nExamples:\n\n>>> from slicot import tf01my\n>>> import numpy as np\n>>> n = 2\n>>> m = 1\n>>> p = 1\n>>> ny = 3\n>>> a = np.array([\n...     [0.5, 0.1],\n...     [0.0, 0.8]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [1.0],\n...     [0.5]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [1.0, 0.0]\n...     ], dtype=float, order='F')\n>>> d = np.array([\n...     [0.0]\n...     ], dtype=float, order='F')\n>>> u = np.array([\n...     [1.0],\n...     [0.5],\n...     [0.0]\n...     ], dtype=float, order='F')\n>>> x = np.array([1.0, 0.5], dtype=float, order='F')\n>>> y, x_out, info = tf01my(a, b, c, d, u, x)\n>>> info\n0",
  "tf01nd": "Output response sequence with Hessenberg state matrix.\n\nSimulates: x(k+1) = A*x(k) + B*u(k), y(k) = C*x(k) + D*u(k)\nwhere A is an upper or lower Hessenberg matrix.\n\nProcessing time is approximately half that of TF01MD due to\nexploiting the Hessenberg structure of A.\n\nParameters:\n  uplo (str): 'U' for upper Hessenberg A, 'L' for lower Hessenberg A\n  a (ndarray): Hessenberg state matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  d (ndarray): Feedthrough matrix (p x m, F-order)\n  u (ndarray): Input sequence (m x ny, F-order)\n  x (ndarray): Initial state vector (n,), modified in-place\n\nReturns:\n  (y, x_final, info): Output sequence (p x ny), final state, exit code\n\nExamples:\n\n>>> from slicot import tf01nd\n>>> import numpy as np\n>>> n, m, p, ny = 3, 2, 2, 10\n>>> a = np.array([\n...     [0.0000, 1.0000, 0.0000],\n...     [-0.0700, 0.8000, 0.0000],\n...     [0.0000, -0.1500, 0.5000]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0000, -1.0000],\n...     [2.0000, -0.1000],\n...     [1.0000, 1.0000]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [0.0000, 0.0000, 1.0000],\n...     [1.0000, 0.0000, 0.0000]\n...     ], order='F', dtype=float)\n>>> d = np.array([\n...     [1.0000, 0.0000],\n...     [0.5000, 0.5000]\n...     ], order='F', dtype=float)\n>>> x0 = np.array([1.0000, 1.0000, 1.0000], dtype=float)\n>>> u_flat = np.array([\n...     -0.6922, -1.4934, 0.3081, -2.7726, 2.0039,\n...     0.2614, -0.9160, -0.6030, 1.2556, 0.2951,\n...     -1.5734, 1.5639, -0.9942, 1.8957, 0.8988,\n...     0.4118, -1.4893, -0.9344, 1.2506, -0.0701\n...     ], dtype=float)\n>>> u = u_flat.reshape((m, ny), order='F')\n>>> y, x_final, info = tf01nd('U', a, b, c, d, u, x0.copy())\n>>> info\n0",
  "tf01od": "Block Hankel expansion of multivariable parameter sequence.\n\nConstructs block Hankel matrix T from sequence M(1),...,M(NR+NC-1):\n\n     | M(1)   M(2)   ...  M(NC)     |\n T = | M(2)   M(3)   ...  M(NC+1)   |\n     | ...                 ...      |\n     | M(NR)  M(NR+1)...  M(NR+NC-1)|\n\nParameters:\n  h (ndarray): Parameter sequence (NH1 x (NR+NC-1)*NH2, F-order).\n               M(k) stored in columns (k-1)*NH2+1 to k*NH2.\n  nr (int): Number of block rows in T (nr >= 0)\n  nc (int): Number of block columns in T (nc >= 0)\n\nReturns:\n  (t, info): Block Hankel matrix (NH1*NR x NH2*NC), exit code\n\nExamples:\n\n>>> from slicot import tf01od\n>>> import numpy as np\n>>> nh1, nh2, nr, nc = 2, 2, 3, 3\n>>> h_flat = np.array([\n...     1.0647, -0.4282, -0.4922, -1.2072,\n...     -0.3043, 0.6883, -0.0926, 0.7167,\n...     -0.1844, -0.8507, 0.4441, -0.0478,\n...     0.7195, 0.0500, -0.3955, 0.5674,\n...     1.3387, -0.2801, 0.1073, -0.5315\n...     ], dtype=float)\n>>> h = h_flat.reshape((nh1, (nr + nc - 1) * nh2), order='F')\n>>> t, info = tf01od(h, nr, nc)\n>>> info\n0",
  "tf01pd": "Block Toeplitz expansion of multivariable parameter sequence.\n\nConstructs block Toeplitz matrix T from sequence M(1),...,M(NR+NC-1):\n\n     | M(NC)     M(NC-1)   ...  M(1)      |\n T = | M(NC+1)   M(NC)     ...  M(2)      |\n     | ...                      ...       |\n     | M(NR+NC-1) M(NR+NC-2) ... M(NR)    |\n\nParameters:\n  h (ndarray): Parameter sequence (NH1 x (NR+NC-1)*NH2, F-order).\n               M(k) stored in columns (k-1)*NH2+1 to k*NH2.\n  nr (int): Number of block rows in T (nr >= 0)\n  nc (int): Number of block columns in T (nc >= 0)\n\nReturns:\n  (t, info): Block Toeplitz matrix (NH1*NR x NH2*NC), exit code\n\nExamples:\n\n>>> from slicot import tf01pd\n>>> import numpy as np\n>>> nh1, nh2, nr, nc = 2, 2, 3, 3\n>>> h_flat = np.array([\n...     1.0647, -0.4282, -0.4922, -1.2072,\n...     -0.3043, 0.6883, -0.0926, 0.7167,\n...     -0.1844, -0.8507, 0.4441, -0.0478,\n...     0.7195, 0.0500, -0.3955, 0.5674,\n...     1.3387, -0.2801, 0.1073, -0.5315\n...     ], dtype=float)\n>>> h = h_flat.reshape((nh1, (nr + nc - 1) * nh2), order='F')\n>>> t, info = tf01pd(h, nr, nc)\n>>> info\n0",
  "tf01qd": "Markov parameters from transfer function matrix.\n\nComputes N Markov parameters M(1), M(2), ..., M(N) from a multivariable\nsystem whose transfer function matrix G(z) is given in ARMA form.\n\nThe (i,j)-th element of G(z) has the form:\n         MA(1)z^{-1} + MA(2)z^{-2} + ... + MA(r)z^{-r}\n G_ij = ----------------------------------------------\n        1 + AR(1)z^{-1} + AR(2)z^{-2} + ... + AR(r)z^{-r}\n\nwhere r is the order of the element.\n\nParameters:\n  nc (int): Number of outputs (rows in G(z)), nc >= 0\n  nb (int): Number of inputs (columns in G(z)), nb >= 0\n  n (int): Number of Markov parameters to compute, n >= 0\n  iord (ndarray): Orders of transfer function elements (nc*nb,), int32\n  ar (ndarray): Denominator coefficients, float64\n  ma (ndarray): Numerator coefficients, float64\n\nReturns:\n  (h, info): Markov parameters (nc x n*nb), exit code\n\nExamples:\n\n>>> from slicot import tf01qd\n>>> import numpy as np\n>>> nc = 2  # outputs\n>>> nb = 2  # inputs\n>>> n = 8   # Markov parameters to compute\n>>> iord = np.array([2, 1, 3, 4], dtype=np.int32)\n>>> ma = np.array([1.0, -0.5, 1.0, 0.5, -0.4, 0.3, 1.0, 0.5, -0.5, 0.0],\n...     dtype=float)\n>>> ar = np.array([0.6, -0.2, -0.8, 0.8, 0.4, 0.1, -0.8, 0.6, 0.0, -0.2],\n...     dtype=float)\n>>> h, info = tf01qd(nc, nb, n, iord, ar, ma)\n>>> info\n0",
  "tf01rd": "Compute Markov parameters from state-space representation.\n\nComputes N Markov parameters M(1), M(2), ..., M(N) from system\nmatrices (A, B, C), where M(k) = C * A^(k-1) * B.\n\nParameters:\n  a (ndarray): State matrix (na x na, F-order)\n  b (ndarray): Input matrix (na x nb, F-order)\n  c (ndarray): Output matrix (nc x na, F-order)\n  n (int): Number of Markov parameters to compute\n\nReturns:\n  (h, info): Markov parameters (nc x n*nb), exit code\n\nExamples:\n\n>>> from slicot import tf01rd\n>>> import numpy as np\n>>> a = np.array([\n...     [0.0, 1.0, 0.0],\n...     [-0.07, 0.8, 0.0],\n...     [0.015, -0.15, 0.5]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [0.0, -1.0],\n...     [2.0, -0.1],\n...     [1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [0.0, 0.0, 1.0],\n...     [1.0, 0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> n = 5  # Number of Markov parameters\n>>> h, info = tf01rd(a, b, c, n)\n>>> nb = 2\n>>> info\n0",
  "tg01ad": "Balance the matrices of a descriptor system pencil.\n\nParameters:\n  job (str): 'A' all, 'B' B+A+E, 'C' C+A+E, 'N' A+E only\n  l (int): Number of rows of A, B, E\n  n (int): Number of columns of A, E, C\n  m (int): Number of columns of B\n  p (int): Number of rows of C\n  thresh (float): Threshold for small elements\n  a (ndarray): State dynamics matrix (l x n, F-order)\n  e (ndarray): Descriptor matrix (l x n, F-order)\n  b (ndarray): Input/state matrix (l x m, F-order)\n  c (ndarray): State/output matrix (p x n, F-order)\n\nReturns:\n  (a, e, b, c, lscale, rscale, info): Balanced system and scaling factors\n\nExamples:\n\n>>> from slicot import tg01ad\n>>> import numpy as np\n>>> l, n, m, p = 4, 4, 2, 2\n>>> job = 'A'\n>>> thresh = 0.0\n>>> a = np.array([\n...     [-1.0,    0.0,    0.0,   0.003],\n...     [ 0.0,    0.0,    0.1,   0.02 ],\n...     [100.0,  10.0,    0.0,   0.4  ],\n...     [ 0.0,    0.0,    0.0,   0.0  ]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [  1.0,  0.2,   0.0,  0.0 ],\n...     [  0.0,  1.0,   0.0,  0.01],\n...     [300.0, 90.0,   6.0,  0.3 ],\n...     [  0.0,  0.0,  20.0,  0.0 ]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [   10.0,     0.0],\n...     [    0.0,     0.0],\n...     [    0.0,  1000.0],\n...     [10000.0, 10000.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [-0.1,   0.0,   0.001,  0.0   ],\n...     [ 0.0,  0.01, -0.001,  0.0001]\n...     ], dtype=np.float64, order='F')\n>>> a_out, e_out, b_out, c_out, lscale, rscale, info = tg01ad(\n...     job, l, n, m, p, thresh, a, e, b, c\n...     )\n>>> info\n0",
  "tg01az": "Balance the matrices of a complex descriptor system pencil.\n\nComplex version of tg01ad. Balances system pencil via diagonal\nsimilarity transformations (Dl*A*Dr - lambda Dl*E*Dr, Dl*B, C*Dr).\nMagnitude is computed as |real| + |imag| for thresholding.\n\nParameters:\n  job (str): 'A' all, 'B' B+A+E, 'C' C+A+E, 'N' A+E only\n  l (int): Number of rows of A, B, E\n  n (int): Number of columns of A, E, C\n  m (int): Number of columns of B\n  p (int): Number of rows of C\n  thresh (float): Threshold for small elements\n  a (ndarray): Complex state dynamics matrix (l x n, F-order)\n  e (ndarray): Complex descriptor matrix (l x n, F-order)\n  b (ndarray): Complex input/state matrix (l x m, F-order)\n  c (ndarray): Complex state/output matrix (p x n, F-order)\n\nReturns:\n  (a, e, b, c, lscale, rscale, info): Balanced system and scaling factors\n\nExamples:\n\n>>> from slicot import tg01az\n>>> import numpy as np\n>>> l, n, m, p = 4, 4, 2, 2\n>>> job = 'A'\n>>> thresh = 0.0\n>>> a = np.array([\n...     [  -1.0+0j,    0.0+0j,    0.0+0j,  0.003+0j],\n...     [   0.0+0j,    0.0+0j,    0.1+0j,   0.02+0j],\n...     [ 100.0+0j,   10.0+0j,    0.0+0j,    0.4+0j],\n...     [   0.0+0j,    0.0+0j,    0.0+0j,    0.0+0j]\n...     ], dtype=np.complex128, order='F')\n>>> e = np.array([\n...     [   1.0+0j,   0.2+0j,    0.0+0j,   0.0+0j],\n...     [   0.0+0j,   1.0+0j,    0.0+0j,  0.01+0j],\n...     [ 300.0+0j,  90.0+0j,    6.0+0j,   0.3+0j],\n...     [   0.0+0j,   0.0+0j,   20.0+0j,   0.0+0j]\n...     ], dtype=np.complex128, order='F')\n>>> b = np.array([\n...     [    10.0+0j,      0.0+0j],\n...     [     0.0+0j,      0.0+0j],\n...     [     0.0+0j,   1000.0+0j],\n...     [ 10000.0+0j,  10000.0+0j]\n...     ], dtype=np.complex128, order='F')\n>>> c = np.array([\n...     [-0.1+0j,   0.0+0j,   0.001+0j,    0.0+0j],\n...     [ 0.0+0j,  0.01+0j,  -0.001+0j, 0.0001+0j]\n...     ], dtype=np.complex128, order='F')\n>>> a_out, e_out, b_out, c_out, lscale, rscale, info = tg01az(\n...     job, l, n, m, p, thresh, a, e, b, c\n...     )\n>>> info\n0",
  "tg01bd": "Reduce descriptor system to generalized Hessenberg form.\n\nParameters:\n  jobe (str): 'G' = E general, 'U' = E upper triangular\n  compq (str): 'N', 'I', or 'V' - Q computation mode\n  compz (str): 'N', 'I', or 'V' - Z computation mode\n  ilo (int): Lower active row/column index (1-based)\n  ihi (int): Upper active row/column index (1-based)\n  a (ndarray): State dynamics matrix (n x n, F-order)\n  e (ndarray): Descriptor matrix (n x n, F-order)\n  b (ndarray): Input/state matrix (n x m, F-order)\n  c (ndarray): State/output matrix (p x n, F-order)\n  q (ndarray): Orthogonal matrix Q (n x n, F-order)\n  z (ndarray): Orthogonal matrix Z (n x n, F-order)\n\nReturns:\n  (a, e, b, c, q, z, info): Transformed system in Hessenberg form\n\nExamples:\n\n>>> from slicot import tg01bd\n>>> import numpy as np\n>>> n, m, p = 4, 2, 2\n>>> a = np.random.randn(n, n).astype(float, order='F')\n>>> e = np.eye(n, order='F', dtype=float)\n>>> b = np.random.randn(n, m).astype(float, order='F')\n>>> c = np.random.randn(p, n).astype(float, order='F')\n>>> q = np.eye(n, order='F', dtype=float)\n>>> z = np.eye(n, order='F', dtype=float)\n>>> a_out, e_out, b_out, c_out, q_out, z_out, info = tg01bd(\n...     'G', 'I', 'I', 1, n, a, e, b, c, q, z\n...     )\n>>> info\n0",
  "tg01cd": "Reduce descriptor system pair (A-lambda E, B) to QR-coordinate form.\n\nComputes orthogonal matrix Q such that Q'*E is upper trapezoidal.\n\nParameters:\n  compq (str): 'N' no Q, 'I' init Q to I, 'U' update Q1*Q\n  a (ndarray): State dynamics matrix (l x n, F-order)\n  e (ndarray): Descriptor matrix (l x n, F-order)\n  b (ndarray): Input/state matrix (l x m, F-order)\n  q (ndarray, optional): Input Q for compq='U' (l x l, F-order)\n\nReturns:\n  (a, e, b, q, info): Transformed system with Q'*E upper trapezoidal\n\nExamples:\n\n>>> from slicot import tg01cd\n>>> import numpy as np\n>>> l, n, m = 4, 4, 2\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0,  3.0],\n...     [ 0.0,  0.0,  1.0,  2.0],\n...     [ 1.0,  1.0,  0.0,  4.0],\n...     [ 0.0,  0.0,  0.0,  0.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 2.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0],\n...     [3.0, 9.0, 6.0, 3.0],\n...     [0.0, 0.0, 2.0, 0.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 1.0],\n...     [1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> a_out, e_out, b_out, q_out, info = tg01cd('I', a, e, b)\n>>> info\n0",
  "tg01dd": "Orthogonal reduction of descriptor system (C,A-lambda E) to RQ-coordinate form.\n\nComputes orthogonal matrix Z such that E*Z is upper trapezoidal.\n\nParameters:\n  compz (str): 'N' no Z, 'I' init Z to I, 'U' update Z1*Z\n  a (ndarray): State dynamics matrix (l x n, F-order)\n  e (ndarray): Descriptor matrix (l x n, F-order)\n  c (ndarray): State/output matrix (p x n, F-order)\n  z (ndarray, optional): Input Z for compz='U' (n x n, F-order)\n\nReturns:\n  (a, e, c, z, info): Transformed system with E*Z upper trapezoidal\n\nExamples:\n\n>>> from slicot import tg01dd\n>>> import numpy as np\n>>> l, n, p = 4, 4, 2\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0,  3.0],\n...     [ 0.0,  0.0,  1.0,  2.0],\n...     [ 1.0,  1.0,  0.0,  4.0],\n...     [ 0.0,  0.0,  0.0,  0.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [ 1.0,  2.0,  0.0,  0.0],\n...     [ 0.0,  1.0,  0.0,  1.0],\n...     [ 3.0,  9.0,  6.0,  3.0],\n...     [ 0.0,  0.0,  2.0,  0.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [-1.0,  0.0,  1.0,  0.0],\n...     [ 0.0,  1.0, -1.0,  1.0]\n...     ], order='F', dtype=float)\n>>> a_out, e_out, c_out, z_out, info = tg01dd('I', a, e, c)\n>>> info\n0",
  "tg01ed": "Orthogonal reduction of descriptor system to SVD coordinate form.\n\nComputes orthogonal matrices Q and Z such that Q'*A*Z and Q'*E*Z are\nin SVD coordinate form, with E transformed to diagonal form containing\nits singular values.\n\nParameters:\n  joba (str): 'N' = no A22 reduction, 'R' = reduce A22 to SVD form\n  a (ndarray): State dynamics matrix (l x n, F-order)\n  e (ndarray): Descriptor matrix (l x n, F-order)\n  b (ndarray): Input/state matrix (l x m, F-order)\n  c (ndarray): State/output matrix (p x n, F-order)\n  tol (float): Tolerance for rank determination (< 1.0; 0 for default)\n\nReturns:\n  (a, e, b, c, q, z, ranke, rnka22, info):\n    Transformed matrices, orthogonal Q and Z, ranks of E and A22, exit code\n\nExamples:\n\n>>> from slicot import tg01ed\n>>> import numpy as np\n>>> l, n, m, p = 4, 4, 2, 2\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0,  3.0],\n...     [ 0.0,  0.0,  1.0,  2.0],\n...     [ 1.0,  1.0,  0.0,  4.0],\n...     [ 0.0,  0.0,  0.0,  0.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [ 1.0,  2.0,  0.0,  0.0],\n...     [ 0.0,  1.0,  0.0,  1.0],\n...     [ 3.0,  9.0,  6.0,  3.0],\n...     [ 0.0,  0.0,  2.0,  0.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [ 1.0,  0.0],\n...     [ 0.0,  0.0],\n...     [ 0.0,  1.0],\n...     [ 1.0,  1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [-1.0,  0.0,  1.0,  0.0],\n...     [ 0.0,  1.0, -1.0,  1.0]\n...     ], order='F', dtype=float)\n>>> a_out, e_out, b_out, c_out, q_out, z_out, ranke, rnka22, info = tg01ed(\n...     'R', a, e, b, c, 0.0\n...     )\n>>> info\n0",
  "tg01fd": "Orthogonal reduction of descriptor system to SVD-like form.\n\nParameters:\n  compq (str): 'N', 'I', or 'U' - Q computation mode\n  compz (str): 'N', 'I', or 'U' - Z computation mode\n  joba (str): 'N', 'R', or 'T' - A22 reduction mode\n  l (int): Number of rows of A, B, E\n  n (int): Number of columns of A, E, C\n  m (int): Number of columns of B\n  p (int): Number of rows of C\n  a (ndarray): State dynamics matrix (l x n, F-order)\n  e (ndarray): Descriptor matrix (l x n, F-order)\n  b (ndarray): Input/state matrix (l x m, F-order)\n  c (ndarray): State/output matrix (p x n, F-order)\n  tol (float): Tolerance for rank determination\n\nReturns:\n  (a, e, b, c, q, z, ranke, rnka22, info): Transformed system and ranks\n\nExamples:\n\n>>> from slicot import tg01fd\n>>> import numpy as np\n>>> l, n, m, p = 4, 4, 2, 2\n>>> tol = 0.0\n>>> compq = 'I'\n>>> compz = 'I'\n>>> joba = 'R'\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0,  3.0],\n...     [ 0.0,  0.0,  1.0,  2.0],\n...     [ 1.0,  1.0,  0.0,  4.0],\n...     [ 0.0,  0.0,  0.0,  0.0]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [1.0,  2.0,  0.0,  0.0],\n...     [0.0,  1.0,  0.0,  1.0],\n...     [3.0,  9.0,  6.0,  3.0],\n...     [0.0,  0.0,  2.0,  0.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0,  0.0],\n...     [0.0,  0.0],\n...     [0.0,  1.0],\n...     [1.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [-1.0,  0.0,  1.0,  0.0],\n...     [ 0.0,  1.0, -1.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> a_out, e_out, b_out, c_out, q, z, ranke, rnka22, info = tg01fd(\n...     compq, compz, joba, l, n, m, p, a, e, b, c, tol\n...     )\n>>> info\n0",
  "tg01fz": "Unitary reduction of complex descriptor system to SVD-like form.\n\nComputes unitary matrices Q and Z for the complex descriptor system\n(A-lambda*E,B,C) such that Q'*A*Z and Q'*E*Z are in SVD-like form.\nThis is the complex version of tg01fd.\n\nParameters:\n  compq (str): 'N', 'I', or 'U' - Q computation mode\n  compz (str): 'N', 'I', or 'U' - Z computation mode\n  joba (str): 'N', 'R', or 'T' - A22 reduction mode\n  l (int): Number of rows of A, B, E\n  n (int): Number of columns of A, E, C\n  m (int): Number of columns of B\n  p (int): Number of rows of C\n  a (ndarray): Complex state dynamics matrix (l x n, F-order)\n  e (ndarray): Complex descriptor matrix (l x n, F-order)\n  b (ndarray): Complex input/state matrix (l x m, F-order)\n  c (ndarray): Complex state/output matrix (p x n, F-order)\n  tol (float): Tolerance for rank determination\n\nReturns:\n  (a, e, b, c, q, z, ranke, rnka22, info): Transformed system and ranks\n\nExamples:\n\n>>> from slicot import tg01fz\n>>> import numpy as np\n>>> l, n, m, p = 4, 4, 2, 2\n>>> tol = 0.0\n>>> a = np.array([\n...     [-1+0j,  0+0j,  0+0j,  3+0j],\n...     [ 0+0j,  0+0j,  1+0j,  2+0j],\n...     [ 1+0j,  1+0j,  0+0j,  4+0j],\n...     [ 0+0j,  0+0j,  0+0j,  0+0j]\n...     ], dtype=np.complex128, order='F')\n>>> e = np.array([\n...     [1+0j, 2+0j, 0+0j, 0+0j],\n...     [0+0j, 1+0j, 0+0j, 1+0j],\n...     [3+0j, 9+0j, 6+0j, 3+0j],\n...     [0+0j, 0+0j, 2+0j, 0+0j]\n...     ], dtype=np.complex128, order='F')\n>>> b = np.array([\n...     [1+0j, 0+0j],\n...     [0+0j, 0+0j],\n...     [0+0j, 1+0j],\n...     [1+0j, 1+0j]\n...     ], dtype=np.complex128, order='F')\n>>> c = np.array([\n...     [-1+0j, 0+0j, 1+0j, 0+0j],\n...     [ 0+0j, 1+0j,-1+0j, 1+0j]\n...     ], dtype=np.complex128, order='F')\n>>> a_out, e_out, b_out, c_out, q, z, ranke, rnka22, info = tg01fz(\n...     'I', 'I', 'R', l, n, m, p, a, e, b, c, tol\n...     )\n>>> info\n0",
  "tg01gd": "Reduced descriptor representation without non-dynamic modes.\n\nFinds a reduced descriptor representation (Ar-lambda*Er,Br,Cr,Dr)\nwithout non-dynamic modes. Optionally transforms Er's leading\ndiagonal block to identity (standard form).\n\nParameters:\n  jobs (str): 'S' = make E11 identity, 'D' = keep E upper triangular\n  l (int): Number of rows of A, B, E\n  n (int): Number of columns of A, E, C\n  m (int): Number of columns of B\n  p (int): Number of rows of C\n  a (ndarray): State dynamics matrix (l x n, F-order)\n  e (ndarray): Descriptor matrix (l x n, F-order)\n  b (ndarray): Input/state matrix (l x m, F-order)\n  c (ndarray): State/output matrix (p x n, F-order)\n  d (ndarray): Feedthrough matrix (p x m, F-order)\n  tol (float): Tolerance for rank determination\n\nReturns:\n  (a, e, b, c, d, lr, nr, ranke, infred, info):\n    Reduced system (LR x NR), rank of E, reduction info, exit code\n\nExamples:\n\n>>> from slicot import tg01gd\n>>> import numpy as np\n>>> l, n, m, p = 4, 4, 2, 2\n>>> tol = 0.0\n>>> jobs = 'D'\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0,  3.0],\n...     [ 0.0,  0.0,  1.0,  2.0],\n...     [ 1.0,  1.0,  0.0,  4.0],\n...     [ 0.0,  0.0,  0.0,  0.0]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [1.0,  2.0,  0.0,  0.0],\n...     [0.0,  1.0,  0.0,  1.0],\n...     [3.0,  9.0,  6.0,  3.0],\n...     [0.0,  0.0,  2.0,  0.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0,  0.0],\n...     [0.0,  0.0],\n...     [0.0,  1.0],\n...     [1.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [-1.0,  0.0,  1.0,  0.0],\n...     [ 0.0,  1.0, -1.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> d = np.array([\n...     [1.0,  0.0],\n...     [1.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> a_out, e_out, b_out, c_out, d_out, lr, nr, ranke, infred, info = tg01gd(\n...     jobs, l, n, m, p, a, e, b, c, d, tol\n...     )\n>>> info\n0",
  "tg01hd": "Orthogonal reduction of descriptor system to controllability staircase form.\n\nComputes orthogonal transformations Q and Z to reduce descriptor system\n(A-lambda*E,B,C) to the form where controllable and uncontrollable parts\nare separated. JOBCON selects which uncontrollable eigenvalues to separate:\n'C' = both finite and infinite, 'F' = finite only, 'I' = infinite only.\n\nParameters:\n  jobcon (str): 'C', 'F', or 'I' - eigenvalue separation mode\n  compq (str): 'N', 'I', or 'U' - Q computation mode\n  compz (str): 'N', 'I', or 'U' - Z computation mode\n  n (int): Order of state matrices A and E\n  m (int): Number of inputs (columns of B)\n  p (int): Number of outputs (rows of C)\n  a (ndarray): State matrix (n x n, F-order)\n  e (ndarray): Descriptor matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float): Tolerance for rank determination (< 1.0; 0 for default)\n  q (ndarray, optional): Input Q for COMPQ='U' (n x n, F-order)\n  z (ndarray, optional): Input Z for COMPZ='U' (n x n, F-order)\n\nReturns:\n  (a, e, b, c, q, z, ncont, niucon, nrblck, rtau, info):\n    Transformed Q'*A*Z, Q'*E*Z, Q'*B, C*Z, orthogonal matrices Q and Z,\n    controllable order NCONT, uncontrollable infinite eigenvalue count NIUCON,\n    number of staircase blocks NRBLCK, block sizes RTAU, and exit code\n\nExamples:\n\n>>> from slicot import tg01hd\n>>> import numpy as np\n>>> n, m, p = 7, 3, 2\n>>> tol = 0.0\n>>> a = np.array([\n...     [2.0, 0.0, 2.0, 0.0, -1.0, 3.0, 1.0],\n...     [0.0, 1.0, 0.0, 0.0,  1.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 1.0,  0.0, 0.0, 1.0],\n...     [0.0, 0.0, 2.0, 0.0, -1.0, 3.0, 1.0],\n...     [0.0, 0.0, 0.0, 1.0,  0.0, 0.0, 1.0],\n...     [0.0, 1.0, 0.0, 0.0,  1.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 1.0,  0.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [0.0, 0.0, 1.0, 0.0,  0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0,  0.0, 1.0, 0.0],\n...     [0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 1.0],\n...     [0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 1.0],\n...     [0.0, 0.0, 0.0, 1.0,  0.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0],\n...     [1.0, 3.0, 0.0, 2.0,  0.0, 0.0, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [2.0, 1.0, 0.0],\n...     [0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0],\n...     [1.0, 2.0, 3.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [1.0,  0.0, 0.0, 1.0,  0.0, 0.0, 1.0],\n...     [0.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> result = tg01hd('C', 'I', 'I', n, m, p, a, e, b, c, tol)\n>>> a_out, e_out, b_out, c_out, q, z, ncont, niucon, nrblck, rtau, info = result\n...     err_msg=\"RTAU should be [2,1]\")\n>>> q_check = q.T @ q\n>>> z_check = z.T @ z\n...     err_msg=\"Q should be orthogonal\")\n...     err_msg=\"Z should be orthogonal\")\n>>> b_uncontrollable = b_out[ncont:, :]\n...     rtol=1e-10, atol=1e-10,\n...     err_msg=\"Uncontrollable part of B should be zero\")",
  "tg01hu": "Orthogonal reduction to multi-input controllability staircase form.\n\nReduces descriptor system (A-lambda*E,[B1,B2],C) with separate input\ngroups B1 (M1 columns) and B2 (M2 columns) to controllability staircase\nform, separating controllable and uncontrollable parts.\n\nParameters:\n  compq (str): 'N', 'I', or 'U' - Q computation mode\n  compz (str): 'N', 'I', or 'U' - Z computation mode\n  l (int): Number of rows of A, B, E\n  n (int): Number of columns of A, E, C\n  m1 (int): Number of columns of B1 (first input group)\n  m2 (int): Number of columns of B2 (second input group)\n  p (int): Number of rows of C\n  n1 (int): Order of subsystem to reduce (0 <= n1 <= min(l,n))\n  lbe (int): Number of sub-diagonals in E1 (0 <= lbe < n1)\n  a (ndarray): State matrix (l x n, F-order)\n  e (ndarray): Descriptor matrix (l x n, F-order)\n  b (ndarray): Input matrix [B1,B2] (l x (m1+m2), F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float): Tolerance for rank determination\n  q (ndarray, optional): Input Q for COMPQ='U' (l x l, F-order)\n  z (ndarray, optional): Input Z for COMPZ='U' (n x n, F-order)\n\nReturns:\n  (a, e, b, c, q, z, nr, nrblck, rtau, info):\n    Transformed system, orthogonal matrices Q and Z,\n    controllable order NR, number of staircase blocks,\n    block sizes RTAU, and exit code\n\nExamples:\n\n>>> from slicot import tg01hu\n>>> import numpy as np\n>>> l, n, m1, m2, p = 4, 4, 1, 1, 2\n>>> n1 = 4\n>>> lbe = 0\n>>> tol = 0.0\n>>> a = np.array([\n...     [1.0, 2.0, 3.0, 4.0],\n...     [0.5, 1.0, 2.5, 3.0],\n...     [0.0, 0.0, 2.0, 1.0],\n...     [0.0, 0.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [2.0, 0.0, 0.0, 0.0],\n...     [0.0, 3.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 0.0],\n...     [0.0, 0.0, 0.0, 2.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [1.0, 1.0],\n...     [0.0, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [1.0, 0.0, 1.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> a_out, e_out, b_out, c_out, q, z, nr, nrblck, rtau, info = tg01hu(\n...     'I', 'I', l, n, m1, m2, p, n1, lbe, a, e, b, c, tol\n...     )\n>>> q_check = q.T @ q\n>>> z_check = z.T @ z\n...     err_msg=\"Q should be orthogonal\")\n...     err_msg=\"Z should be orthogonal\")\n>>> info\n0",
  "tg01hx": "Orthogonal reduction to controllability staircase form.\n\nReduces descriptor system (A-lambda*E,B,C) to controllability\nstaircase form, separating controllable and uncontrollable parts.\n\nParameters:\n  compq (str): 'N', 'I', or 'U' - Q computation mode\n  compz (str): 'N', 'I', or 'U' - Z computation mode\n  l (int): Number of rows of A, B, E\n  n (int): Number of columns of A, E, C\n  m (int): Number of columns of B\n  p (int): Number of rows of C\n  n1 (int): Order of subsystem to reduce (0 <= n1 <= min(l,n))\n  lbe (int): Number of sub-diagonals in E1 (0 <= lbe < n1)\n  a (ndarray): State matrix (l x n, F-order)\n  e (ndarray): Descriptor matrix (l x n, F-order)\n  b (ndarray): Input matrix (l x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float): Tolerance for rank determination\n  q (ndarray, optional): Input Q for COMPQ='U' (l x l, F-order)\n\nReturns:\n  (a, e, b, c, q, z, nr, nrblck, rtau, info):\n    Transformed system, orthogonal matrices Q and Z,\n    controllable order NR, number of staircase blocks,\n    block sizes RTAU, and exit code\n\nExamples:\n\n>>> from slicot import tg01hx\n>>> import numpy as np\n>>> l, n, m, p = 4, 4, 2, 2\n>>> n1 = 4\n>>> lbe = 0\n>>> tol = 0.0\n>>> a = np.array([\n...     [1.0, 2.0, 3.0, 4.0],\n...     [0.5, 1.0, 2.5, 3.0],\n...     [0.0, 0.0, 2.0, 1.0],\n...     [0.0, 0.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [2.0, 0.0, 0.0, 0.0],\n...     [0.0, 3.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 0.0],\n...     [0.0, 0.0, 0.0, 2.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [1.0, 1.0],\n...     [0.0, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [1.0, 0.0, 1.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> a_out, e_out, b_out, c_out, q, z, nr, nrblck, rtau, info = tg01hx(\n...     'I', 'I', l, n, m, p, n1, lbe, a, e, b, c, tol\n...     )\n>>> q_check = q.T @ q\n>>> z_check = z.T @ z\n...     err_msg=\"Q should be orthogonal\")\n...     err_msg=\"Z should be orthogonal\")\n>>> info\n0",
  "tg01hy": "Blocked version of orthogonal reduction to controllability staircase form.\n\nReduces descriptor system (A-lambda*E,B,C) to controllability\nstaircase form using block algorithms for better performance on large systems.\nSeparates controllable and uncontrollable parts.\n\nParameters:\n  compq (str): 'N', 'I', or 'U' - Q computation mode\n  compz (str): 'N', 'I', or 'U' - Z computation mode\n  l (int): Number of rows of A, B, E\n  n (int): Number of columns of A, E, C\n  m (int): Number of columns of B\n  p (int): Number of rows of C\n  n1 (int): Order of subsystem to reduce (0 <= n1 <= min(l,n))\n  lbe (int): Number of sub-diagonals in E1 (0 <= lbe < n1)\n  a (ndarray): State matrix (l x n, F-order)\n  e (ndarray): Descriptor matrix (l x n, F-order)\n  b (ndarray): Input matrix (l x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float): Tolerance for rank determination\n  q (ndarray, optional): Input Q for COMPQ='U' (l x l, F-order)\n\nReturns:\n  (a, e, b, c, q, z, nr, nrblck, rtau, info):\n    Transformed system, orthogonal matrices Q and Z,\n    controllable order NR, number of staircase blocks,\n    block sizes RTAU, and exit code\n\nExamples:\n\n>>> from slicot import tg01hy\n>>> import numpy as np\n>>> l, n, m, p = 4, 4, 2, 2\n>>> n1 = 4\n>>> lbe = 0\n>>> tol = 0.0\n>>> a = np.array([\n...     [1.0, 2.0, 3.0, 4.0],\n...     [0.5, 1.0, 2.5, 3.0],\n...     [0.0, 0.0, 2.0, 1.0],\n...     [0.0, 0.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [2.0, 0.0, 0.0, 0.0],\n...     [0.0, 3.0, 0.0, 0.0],\n...     [0.0, 0.0, 1.0, 0.0],\n...     [0.0, 0.0, 0.0, 2.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [1.0, 1.0],\n...     [0.0, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [1.0, 0.0, 1.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> a_out, e_out, b_out, c_out, q, z, nr, nrblck, rtau, info = tg01hy(\n...     'I', 'I', l, n, m, p, n1, lbe, a, e, b, c, tol\n...     )\n>>> q_check = q.T @ q\n>>> z_check = z.T @ z\n...     err_msg=\"Q should be orthogonal\")\n...     err_msg=\"Z should be orthogonal\")\n>>> info\n0",
  "tg01id": "Orthogonal reduction of descriptor system to observability staircase form.\n\nComputes orthogonal transformation matrices Q and Z which reduce the\nN-th order descriptor system (A-lambda*E,B,C) to the form:\n  Q'*A*Z = (Ano, *; 0, Ao), Q'*E*Z = (Eno, *; 0, Eo),\n  Q'*B = (Bno; Bo), C*Z = (0, Co)\nwhere (Ao-lambda*Eo,Bo,Co) is finite and/or infinite observable.\n\nJOBOBS selects which unobservable eigenvalues to separate:\n  'O' = both finite and infinite\n  'F' = finite only\n  'I' = nonzero finite and infinite\n\nParameters:\n  jobobs (str): 'O', 'F', or 'I' - eigenvalue separation mode\n  compq (str): 'N', 'I', or 'U' - Q computation mode\n  compz (str): 'N', 'I', or 'U' - Z computation mode\n  a (ndarray): State matrix (n x n, F-order)\n  e (ndarray): Descriptor matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float): Tolerance for rank determination (< 1.0; 0 for default)\n\nReturns:\n  (a, e, b, c, q, z, nobsv, niuobs, nlblck, ctau, info):\n    Transformed Q'*A*Z, Q'*E*Z, Q'*B, C*Z, orthogonal matrices Q and Z,\n    observable order NOBSV, unobservable infinite eigenvalue count NIUOBS,\n    number of staircase blocks NLBLCK, block sizes CTAU, and exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01id\n>>> n, m, p = 7, 2, 3\n>>> a = np.array([\n...     [2, 0, 0, 0, 0, 0, 0],\n...     [0, 1, 0, 0, 0, 1, 0],\n...     [2, 0, 0, 2, 0, 0, 0],\n...     [0, 0, 1, 0, 1, 0, 1],\n...     [-1, 1, 0, -1, 0, 1, 0],\n...     [3, 0, 0, 3, 0, 0, 0],\n...     [1, 0, 1, 1, 1, 0, 1]\n...     ], dtype=float, order='F')\n>>> e = np.array([\n...     [0, 0, 0, 0, 0, 0, 1],\n...     [0, 0, 0, 0, 0, 0, 3],\n...     [1, 0, 0, 0, 0, 1, 0],\n...     [0, 0, 0, 0, 1, 0, 2],\n...     [0, 0, 0, 0, 0, -1, 0],\n...     [0, 1, 0, 0, 0, 0, 0],\n...     [0, 0, 1, 1, 0, 0, 0]\n...     ], dtype=float, order='F')\n>>> b = np.array([\n...     [1, 0],\n...     [0, -1],\n...     [0, 1],\n...     [1, 0],\n...     [0, -1],\n...     [0, 1],\n...     [1, 0]\n...     ], dtype=float, order='F')\n>>> c = np.array([\n...     [2, 0, 0, 0, 0, 0, 1],\n...     [1, 0, 0, 0, 0, 0, 2],\n...     [0, 0, 0, 0, 0, 0, 3]\n...     ], dtype=float, order='F')\n>>> a_out, e_out, b_out, c_out, q, z, nobsv, niuobs, nlblck, ctau, info = tg01id(\n...     'O', 'I', 'I', a, e, b, c, 0.0\n...     )\n>>> info\n0",
  "tg01jd": "Find irreducible descriptor representation.\n\nFinds a reduced (controllable, observable, or irreducible) descriptor\nrepresentation (Ar-lambda*Er,Br,Cr) for an original descriptor\nrepresentation (A-lambda*E,B,C). The pencil Ar-lambda*Er is in upper\nblock Hessenberg form with either Ar or Er upper triangular.\n\nThe reduction is performed in 4 phases:\n  Phase 1: Eliminate finite uncontrollable eigenvalues\n  Phase 2: Eliminate infinite and finite nonzero uncontrollable eigenvalues\n  Phase 3: Eliminate finite unobservable eigenvalues\n  Phase 4: Eliminate infinite and finite nonzero unobservable eigenvalues\n\nParameters:\n  job (str): 'I' = irreducible, 'C' = controllable, 'O' = observable\n  systyp (str): 'R' = rational, 'S' = proper/standard, 'P' = polynomial\n  equil (str): 'S' = scale system, 'N' = no scaling\n  a (ndarray): State matrix (n x n, F-order)\n  e (ndarray): Descriptor matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order; n x max(m,p) if job != 'C')\n  c (ndarray): Output matrix (p x n, F-order; max(m,p) x n if job != 'C')\n  tol (float): Tolerance for rank determination (< 1.0; <= 0 for default)\n\nReturns:\n  (a, e, b, c, nr, infred, iwork, info):\n    Reduced Ar, Er, Br, Cr matrices; reduced order NR;\n    INFRED array (phase reductions in [0-3], A/E sub-diagonals in [4-5],\n    block count in [6]); IWORK with block dimensions; exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01jd\n>>> n, m, p = 9, 2, 2\n>>> tol = 0.0\n>>> a = np.array([\n...     [-2, -3,  0,  0,  0,  0,  0,  0,  0],\n...     [ 1,  0,  0,  0,  0,  0,  0,  0,  0],\n...     [ 0,  0, -2, -3,  0,  0,  0,  0,  0],\n...     [ 0,  0,  1,  0,  0,  0,  0,  0,  0],\n...     [ 0,  0,  0,  0,  1,  0,  0,  0,  0],\n...     [ 0,  0,  0,  0,  0,  1,  0,  0,  0],\n...     [ 0,  0,  0,  0,  0,  0,  1,  0,  0],\n...     [ 0,  0,  0,  0,  0,  0,  0,  1,  0],\n...     [ 0,  0,  0,  0,  0,  0,  0,  0,  1],\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 1, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 1, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 1, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 1, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 1, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 1, 0],\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [ 1,  0],\n...     [ 0,  0],\n...     [ 0,  1],\n...     [ 0,  0],\n...     [-1,  0],\n...     [ 0,  0],\n...     [ 0, -1],\n...     [ 0,  0],\n...     [ 0,  0],\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1, 0, 1, -3, 0, 1, 0, 2, 0],\n...     [0, 1, 1,  3, 0, 1, 0, 0, 1],\n...     ], order='F', dtype=float)\n>>> result = tg01jd('I', 'R', 'N', a, e, b, c, tol)\n>>> a_r, e_r, b_r, c_r, nr, infred, iwork, info = result\n>>> a_red = a_r[:nr, :nr]\n>>> e_red = e_r[:nr, :nr]\n>>> b_red = b_r[:nr, :m]\n>>> c_red = c_r[:p, :nr]\n>>> test_freqs = [1.0, 2.0 + 1j, -0.5 + 2j, 0.1j, 5.0]\n...     try:\n...     except np.linalg.LinAlgError:\n...     continue\n...     try:\n...     G_red = c_red @ np.linalg.solve(s * e_red - a_red, b_red)\n...     except np.linalg.LinAlgError:\n...     continue\n...     err_msg=f\"Transfer function mismatch at s={s}\")",
  "tg01jy": "Find irreducible descriptor representation with singularity check.\n\nFinds a reduced (controllable, observable, or irreducible) descriptor\nrepresentation (Ar-lambda*Er,Br,Cr) for a regular descriptor system\n(A-lambda*E,B,C). Extended version of TG01JD with options for checking\npencil singularity and restoring original matrices for maximum accuracy.\n\nThe reduction is performed in 4 phases:\n  Phase 1: Eliminate finite uncontrollable eigenvalues\n  Phase 2: Eliminate infinite and finite nonzero uncontrollable eigenvalues\n  Phase 3: Eliminate finite unobservable eigenvalues\n  Phase 4: Eliminate infinite and finite nonzero unobservable eigenvalues\n\nParameters:\n  job (str): 'I' = irreducible, 'C' = controllable, 'O' = observable\n  systyp (str): 'R' = rational, 'S' = proper/standard, 'P' = polynomial\n  equil (str): 'S' = scale system, 'N' = no scaling\n  cksing (str): 'C' = check pencil singularity, 'N' = no check\n  restor (str): 'R' = restore original for max accuracy, 'N' = no restore\n  a (ndarray): State matrix (n x n, F-order)\n  e (ndarray): Descriptor matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order; n x max(m,p) if job != 'C')\n  c (ndarray): Output matrix (p x n, F-order; max(m,p) x n if job != 'C')\n  tol (ndarray, optional): Tolerance array (3 elements):\n    tol[0]: tolerance for controllability/observability\n    tol[1]: tolerance for pencil regularity check\n    tol[2]: threshold for pencil singularity check\n\nReturns:\n  (a, e, b, c, nr, infred, iwork, info):\n    Reduced Ar, Er, Br, Cr matrices; reduced order NR;\n    INFRED array (phase reductions in [0-3], A/E sub-diagonals in [4-5],\n    block count in [6]); IWORK with block dimensions; exit code\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01jy\n>>> n, m, p = 9, 2, 2\n>>> tol = np.array([0.0, 0.0, 0.0], dtype=float)\n>>> a = np.array([\n...     [-2, -3,  0,  0,  0,  0,  0,  0,  0],\n...     [ 1,  0,  0,  0,  0,  0,  0,  0,  0],\n...     [ 0,  0, -2, -3,  0,  0,  0,  0,  0],\n...     [ 0,  0,  1,  0,  0,  0,  0,  0,  0],\n...     [ 0,  0,  0,  0,  1,  0,  0,  0,  0],\n...     [ 0,  0,  0,  0,  0,  1,  0,  0,  0],\n...     [ 0,  0,  0,  0,  0,  0,  1,  0,  0],\n...     [ 0,  0,  0,  0,  0,  0,  0,  1,  0],\n...     [ 0,  0,  0,  0,  0,  0,  0,  0,  1],\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 1, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 1, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 1, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 1, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 1, 0, 0],\n...     [0, 0, 0, 0, 0, 0, 0, 1, 0],\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [ 1,  0],\n...     [ 0,  0],\n...     [ 0,  1],\n...     [ 0,  0],\n...     [-1,  0],\n...     [ 0,  0],\n...     [ 0, -1],\n...     [ 0,  0],\n...     [ 0,  0],\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1, 0, 1, -3, 0, 1, 0, 2, 0],\n...     [0, 1, 1,  3, 0, 1, 0, 0, 1],\n...     ], order='F', dtype=float)\n>>> result = tg01jy('I', 'R', 'N', 'N', 'N', a, e, b, c, tol)\n>>> a_r, e_r, b_r, c_r, nr, infred, iwork, info = result\n>>> a_red = a_r[:nr, :nr]\n>>> e_red = e_r[:nr, :nr]\n>>> b_red = b_r[:nr, :m]\n>>> c_red = c_r[:p, :nr]\n>>> test_freqs = [1.0, 2.0 + 1j, -0.5 + 2j, 0.1j, 5.0]\n...     try:\n...     except np.linalg.LinAlgError:\n...     continue\n...     try:\n...     G_red = c_red @ np.linalg.solve(s * e_red - a_red, b_red)\n...     except np.linalg.LinAlgError:\n...     continue\n...     err_msg=f\"Transfer function mismatch at s={s}\")",
  "tg01kd": "Orthogonal equivalence transformation of SISO descriptor system.\n\nFor a single-input single-output descriptor system (A, E, B, C) with E\nupper triangular, computes (Q'*A*Z, Q'*E*Z, Q'*B, C*Z) via orthogonal\nequivalence transformation so that Q'*B has only the first element\nnonzero and Q'*E*Z remains upper triangular.\n\nParameters:\n  jobe (str): 'U' = E is upper triangular, 'I' = E is identity\n  compc (str): 'C' = transform C, 'N' = do not transform C\n  compq (str): 'N', 'I', or 'U' - Q computation mode\n  compz (str): 'N', 'I', or 'U' - Z computation mode\n  a (ndarray): State matrix (n x n, F-order)\n  e (ndarray): Descriptor matrix (n x n, F-order, if JOBE='U')\n  b (ndarray): Input vector (n, F-order)\n  c (ndarray): Output vector (n, F-order)\n  q (ndarray, optional): Input Q for COMPQ='U' (n x n, F-order)\n  z (ndarray, optional): Input Z for COMPZ='U' (n x n, F-order)\n  incc (int, optional): Stride of C (default 1)\n\nReturns:\n  (a, e, b, c, q, z, info):\n    Transformed Q'*A*Z, Q'*E*Z, Q'*B, C*Z, orthogonal Q and Z, exit code\n\nExamples:\n\n>>> from slicot import tg01kd\n>>> import numpy as np\n>>> n = 4\n>>> e = np.triu(np.random.randn(n, n)).astype(np.float64, order='F')\n...     e[i, i] = abs(e[i, i]) + 1.0\n>>> a = np.random.randn(n, n).astype(np.float64, order='F')\n>>> b = np.random.randn(n).astype(np.float64, order='F')\n>>> c = np.random.randn(n).astype(np.float64, order='F')\n>>> a_out, e_out, b_out, c_out, q, z, info = tg01kd('U', 'C', 'I', 'I', a, e, b, c)\n...     err_msg=\"b_out should have zeros in elements 2..N\")\n...     f\"E_out[{i},{j}]={e_out[i,j]} should be zero (upper triangular)\"\n...     err_msg=\"Q should be orthogonal\")\n...     err_msg=\"Z should be orthogonal\")\n...     err_msg=\"A_out should equal Q'*A*Z\")\n...     err_msg=\"E_out should equal Q'*E*Z\")\n...     err_msg=\"b_out should equal Q'*b\")\n>>> info\n0",
  "tg01kz": "Complex unitary equivalence transformation of SISO descriptor system.\n\nFor a single-input single-output complex descriptor system (A, E, B, C)\nwith E upper triangular, computes (Q'*A*Z, Q'*E*Z, Q'*B, C*Z) via unitary\nequivalence transformation so that Q'*B has only the first element\nnonzero and Q'*E*Z remains upper triangular.\n\nUses Givens rotations to annihilate the last N-1 elements of B in\nreverse order while preserving the upper triangular form of E.\n\nParameters:\n  jobe (str): 'U' = E is upper triangular, 'I' = E is identity\n  compc (str): 'C' = transform C, 'N' = do not transform C\n  compq (str): 'N', 'I', or 'U' - Q computation mode\n  compz (str): 'N', 'I', or 'U' - Z computation mode\n  a (ndarray): Complex state matrix (n x n, F-order)\n  e (ndarray): Complex descriptor matrix (n x n, F-order, if JOBE='U')\n  b (ndarray): Complex input vector (n, F-order)\n  c (ndarray): Complex output vector (n, F-order)\n  q (ndarray, optional): Complex input Q for COMPQ='U' (n x n, F-order)\n  z (ndarray, optional): Complex input Z for COMPZ='U' (n x n, F-order)\n  incc (int, optional): Stride of C (default 1)\n\nReturns:\n  (a, e, b, c, q, z, info):\n    Transformed Q'*A*Z, Q'*E*Z, Q'*B, C*Z, unitary Q and Z, exit code\n\nExamples:\n\n>>> from slicot import tg01kz\n>>> import numpy as np\n>>> n = 4\n>>> a = (np.random.randn(n, n) + 1j * np.random.randn(n, n)).astype(np.complex128, order='F')\n>>> b = (np.random.randn(n) + 1j * np.random.randn(n)).astype(np.complex128, order='F')\n>>> c = (np.random.randn(n) + 1j * np.random.randn(n)).astype(np.complex128, order='F')\n>>> e = np.eye(n, dtype=np.complex128, order='F')\n>>> a_out, e_out, b_out, c_out, q_out, z_out, info = tg01kz(\n...     'I', 'C', 'I', 'I', a, e, b, c, incc=1\n...     )\n>>> q_unitary = q_out.conj().T @ q_out\n>>> z_unitary = z_out.conj().T @ z_out\n>>> info\n0",
  "tg01ld": "Finite-infinite decomposition of descriptor system.\n\nComputes orthogonal transformation matrices Q and Z which reduce the\nregular pole pencil A-lambda*E of the descriptor system (A-lambda*E,B,C)\nto finite-infinite separated form:\n  JOB='F': Q'*A*Z = (Af, *; 0, Ai), Q'*E*Z = (Ef, *; 0, Ei)\n  JOB='I': Q'*A*Z = (Ai, *; 0, Af), Q'*E*Z = (Ei, *; 0, Ef)\nwhere Af-lambda*Ef (Ef nonsingular) contains finite eigenvalues,\nand Ai-lambda*Ei (Ai nonsingular) contains infinite eigenvalues\nin staircase form.\n\nOptionally reduces Af to upper Hessenberg form (JOBA='H').\n\nParameters:\n  job (str): 'F' = finite-infinite, 'I' = infinite-finite separation\n  joba (str): 'H' = reduce Af to Hessenberg, 'N' = keep unreduced\n  compq (str): 'N' = no Q, 'I' = initialize Q to I, 'U' = update Q1*Q\n  compz (str): 'N' = no Z, 'I' = initialize Z to I, 'U' = update Z1*Z\n  n (int): Order of A and E (n >= 0)\n  m (int): Number of columns of B (m >= 0)\n  p (int): Number of rows of C (p >= 0)\n  a (ndarray): State matrix (n x n, F-order)\n  e (ndarray): Descriptor matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float): Tolerance for rank decisions (use <= 0 for default)\n\nReturns:\n  (a, e, b, c, q, z, nf, nd, niblck, iblck, info):\n    Transformed Q'*A*Z, Q'*E*Z, Q'*B, C*Z, orthogonal Q and Z,\n    NF = number of finite eigenvalues, ND = non-dynamic infinite count,\n    NIBLCK = number of infinite blocks minus one, IBLCK = block dimensions,\n    INFO = 0 success, 1 = pencil not regular\n\nExamples:\n\n>>> from slicot import tg01ld\n>>> import numpy as np\n>>> n, m, p = 4, 2, 2\n>>> tol = 0.0\n>>> job = 'F'\n>>> joba = 'N'\n>>> compq = 'I'\n>>> compz = 'I'\n>>> a = np.array([\n...     [-1.0,  0.0,  0.0,  3.0],\n...     [ 0.0,  0.0,  1.0,  2.0],\n...     [ 1.0,  1.0,  0.0,  4.0],\n...     [ 0.0,  0.0,  0.0,  0.0]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [1.0,  2.0,  0.0,  0.0],\n...     [0.0,  1.0,  0.0,  1.0],\n...     [3.0,  9.0,  6.0,  3.0],\n...     [0.0,  0.0,  2.0,  0.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0,  0.0],\n...     [0.0,  0.0],\n...     [0.0,  1.0],\n...     [1.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [-1.0,  0.0,  1.0,  0.0],\n...     [ 0.0,  1.0, -1.0,  1.0]\n...     ], dtype=np.float64, order='F')\n>>> a_out, e_out, b_out, c_out, q, z, nf, nd, niblck, iblck, info = tg01ld(\n...     job, joba, compq, compz, n, m, p, a, e, b, c, tol\n...     )\n>>> info\n0",
  "tg01ly": "Finite-infinite decomposition of structured descriptor system.\n\nReduces a regular pole pencil A-lambda*E of descriptor system (A-lambda*E,B,C)\nfrom structured form to finite-infinite separated form. Input matrices must\nhave special structure where E has rank RANKE with nonzero block in top-left.\n\nParameters:\n  compq (bool): True to accumulate Q transformations, False otherwise\n  compz (bool): True to accumulate Z transformations, False otherwise\n  ranke (int): Rank of E matrix (0 <= ranke <= n)\n  rnka22 (int): Rank of A22 block (0 <= rnka22 <= n - ranke)\n  a (ndarray): State matrix (n x n, F-order)\n  e (ndarray): Descriptor matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  q (ndarray): Left transformation matrix (n x n if compq, else 1 x 1)\n  z (ndarray): Right transformation matrix (n x n if compz, else 1 x 1)\n  tol (float, optional): Tolerance for rank decisions (default: n^2 * eps)\n  ldwork (int, optional): Workspace size (-1 for query)\n\nReturns:\n  (a, e, b, c, q, z, nf, niblck, iblck, info):\n    Transformed Q'*A*Z, Q'*E*Z, Q'*B, C*Z, orthogonal Q and Z,\n    NF = number of finite eigenvalues,\n    NIBLCK = number of infinite blocks,\n    IBLCK = block dimensions array,\n    INFO = 0 success, 1 = pencil not regular, <0 = param error\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01ly\n>>> n = 4\n>>> m = 2\n>>> p = 2\n>>> ranke = 2\n>>> rnka22 = 1\n>>> a = np.zeros((n, n), order='F', dtype=float)\n>>> a[0, 0] = 1.0\n>>> a[0, 1] = 2.0\n>>> a[0, 2] = 0.5\n>>> a[0, 3] = 0.3\n>>> a[1, 0] = 0.0\n>>> a[1, 1] = 3.0\n>>> a[1, 2] = 0.7\n>>> a[1, 3] = 0.2\n>>> a[2, 0] = 0.1\n>>> a[2, 1] = 0.0\n>>> a[2, 2] = 2.0\n>>> a[2, 3] = 0.4\n>>> a[3, 0] = 0.5\n>>> a[3, 1] = 0.0\n>>> a[3, 2] = 0.0\n>>> a[3, 3] = 0.0\n>>> e = np.zeros((n, n), order='F', dtype=float)\n>>> e[0, 0] = 1.0\n>>> e[0, 1] = 0.5\n>>> e[1, 1] = 2.0\n>>> b = np.array([\n...     [1.0, 0.5],\n...     [0.0, 1.0],\n...     [0.3, 0.2],\n...     [0.1, 0.4]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [1.0, 0.0, 0.5, 0.2],\n...     [0.0, 1.0, 0.3, 0.1]\n...     ], order='F', dtype=float)\n>>> compq = True\n>>> compz = True\n>>> q = np.eye(n, order='F', dtype=float)\n>>> z = np.eye(n, order='F', dtype=float)\n>>> result = tg01ly(compq, compz, ranke, rnka22, a, e, b, c, q, z)\n>>> a_out, e_out, b_out, c_out, q_out, z_out, nf, niblck, iblck, info = result\n>>> qtq = q_out.T @ q_out\n>>> ztz = z_out.T @ z_out",
  "tg01md": "Finite-infinite generalized real Schur form decomposition.\n\nComputes orthogonal transformation matrices Q and Z which reduce the\nregular pole pencil A-lambda*E of the descriptor system (A-lambda*E,B,C)\nto generalized real Schur form with finite-infinite separation:\n  JOB='F': Q'*A*Z = (Af, *; 0, Ai), Q'*E*Z = (Ef, *; 0, Ei)\n  JOB='I': Q'*A*Z = (Ai, *; 0, Af), Q'*E*Z = (Ei, *; 0, Ef)\nwhere (Af,Ef) is in generalized real Schur form with Ef nonsingular\nand upper triangular, Af in real Schur form. The subpencil\nAf-lambda*Ef contains the finite eigenvalues.\nThe pair (Ai,Ei) has both Ai and Ei upper triangular. The subpencil\nAi-lambda*Ei (Ai nonsingular, Ei nilpotent) contains infinite\neigenvalues in block staircase form.\n\nParameters:\n  job (str): 'F' = finite-infinite, 'I' = infinite-finite separation\n  n (int): Order of A and E (n >= 0)\n  m (int): Number of columns of B (m >= 0)\n  p (int): Number of rows of C (p >= 0)\n  a (ndarray): State matrix (n x n, F-order)\n  e (ndarray): Descriptor matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float): Tolerance for rank decisions (use <= 0 for default)\n\nReturns:\n  (a, e, b, c, alphar, alphai, beta, q, z, nf, nd, niblck, iblck, info):\n    Transformed Q'*A*Z, Q'*E*Z, Q'*B, C*Z;\n    ALPHAR, ALPHAI, BETA = generalized eigenvalue components\n      (eigenvalues = (ALPHAR + i*ALPHAI) / BETA);\n    Orthogonal Q and Z;\n    NF = number of finite eigenvalues;\n    ND = non-dynamic infinite eigenvalue count;\n    NIBLCK = number of infinite blocks minus one;\n    IBLCK = block dimensions;\n    INFO = 0 success, 1 = pencil not regular, 2 = QZ failed\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01md\n>>> n, m, p = 4, 2, 2\n>>> a = np.array([\n...     [-1.0, 0.0, 0.0, 3.0],\n...     [0.0, 0.0, 1.0, 2.0],\n...     [1.0, 1.0, 0.0, 4.0],\n...     [0.0, 0.0, 0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 2.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0],\n...     [3.0, 9.0, 6.0, 3.0],\n...     [0.0, 0.0, 2.0, 0.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 1.0],\n...     [1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [-1.0, 0.0, 1.0, 0.0],\n...     [0.0, 1.0, -1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> result = tg01md('F', n, m, p, a, e, b, c, 0.0)\n>>> a_out, e_out, b_out, c_out, alphar, alphai, beta, q, z, nf, nd, niblck, iblck, info = result\n>>> eig_computed = []\n...     eig_computed.append(complex(alphar[j], alphai[j]) / beta[j])\n>>> eig_computed = np.array([e.real for e in eig_computed])\n>>> eig_computed_sorted = np.sort(eig_computed)",
  "tg01nd": "Finite-infinite block-diagonal decomposition of descriptor system.\n\nComputes equivalence transformation matrices Q and Z which reduce the\nregular pole pencil A-lambda*E of the descriptor system (A-lambda*E,B,C)\nto fully block-diagonal form:\n  JOB='F': Q*A*Z = diag(Af, Ai), Q*E*Z = diag(Ef, Ei)\n  JOB='I': Q*A*Z = diag(Ai, Af), Q*E*Z = diag(Ei, Ef)\nwhere (Af,Ef) is in generalized real Schur form with Ef nonsingular\nand upper triangular, and Af in real Schur form. The subpencil\nAf-lambda*Ef contains the finite eigenvalues. The pair (Ai,Ei) is in\ngeneralized real Schur form with Ai nonsingular and Ei nilpotent\n(upper triangular in block staircase form).\n\nUnlike tg01md, this routine produces FULLY block-diagonal form by\nsolving generalized Sylvester equations to eliminate off-diagonal blocks.\n\nParameters:\n  job (str): 'F' = finite-infinite, 'I' = infinite-finite separation\n  jobt (str): 'D' = direct Q, Z; 'I' = inverse inv(Q), inv(Z)\n  n (int): Order of A and E (n >= 0)\n  m (int): Number of columns of B (m >= 0)\n  p (int): Number of rows of C (p >= 0)\n  a (ndarray): State matrix (n x n, F-order)\n  e (ndarray): Descriptor matrix (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  tol (float): Tolerance for rank decisions (use <= 0 for default)\n\nReturns:\n  (a, e, b, c, alphar, alphai, beta, q, z, nf, nd, niblck, iblck, info):\n    Block-diagonal Q*A*Z, Q*E*Z, transformed Q*B, C*Z;\n    ALPHAR, ALPHAI, BETA = generalized eigenvalue components\n      (eigenvalues = (ALPHAR + i*ALPHAI) / BETA);\n    Transformation matrices Q, Z (or inv(Q), inv(Z) if JOBT='I');\n    NF = number of finite eigenvalues;\n    ND = non-dynamic infinite eigenvalue count;\n    NIBLCK = number of infinite blocks minus one;\n    IBLCK = block dimensions;\n    INFO = 0 success, 1 = not regular, 2 = QZ failed, 3 = Sylvester failed\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01nd\n>>> n, m, p = 4, 2, 2\n>>> a = np.array([\n...     [-1.0, 0.0, 0.0, 3.0],\n...     [0.0, 0.0, 1.0, 2.0],\n...     [1.0, 1.0, 0.0, 4.0],\n...     [0.0, 0.0, 0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 2.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0],\n...     [3.0, 9.0, 6.0, 3.0],\n...     [0.0, 0.0, 2.0, 0.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 1.0],\n...     [1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [-1.0, 0.0, 1.0, 0.0],\n...     [0.0, 1.0, -1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> result = tg01nd('F', 'D', n, m, p, a, e, b, c, 0.0)\n>>> (a_out, e_out, b_out, c_out, alphar, alphai, beta,\n...     q, z, nf, nd, niblck, iblck, info) = result\n...     err_msg=\"A off-diagonal block should be zero\")\n...     err_msg=\"A off-diagonal block should be zero\")\n...     err_msg=\"E off-diagonal block should be zero\")\n...     err_msg=\"E off-diagonal block should be zero\")\n>>> eig_computed = []\n...     eig_computed.append(complex(alphar[j], alphai[j]) / beta[j])\n>>> eig_computed = np.array([e.real for e in eig_computed])\n>>> eig_computed_sorted = np.sort(eig_computed)",
  "tg01nx": "Block-diagonal decomposition of descriptor system in generalized Schur form.\n\nComputes equivalence transformation matrices Q and Z which reduce\nthe regular pole pencil A-lambda*E of the descriptor system (A-lambda*E,B,C),\nwith (A,E) in generalized real Schur form, to block-diagonal form:\n  Q*A*Z = diag(A1, A2),  Q*E*Z = diag(E1, E2)\nwhere (A1,E1) and (A2,E2) have no common generalized eigenvalues.\n\nParameters:\n  jobt (str): 'D' = compute Q, Z; 'I' = compute inv(Q), inv(Z)\n  n (int): Order of A, E; rows of B; columns of C\n  m (int): Number of columns of B\n  p (int): Number of rows of C\n  ndim (int): Dimension of leading diagonal blocks (0 <= ndim <= n)\n  a (ndarray): State matrix in Schur form (n x n, F-order)\n  e (ndarray): Descriptor matrix, upper triangular (n x n, F-order)\n  b (ndarray): Input matrix (n x m, F-order)\n  c (ndarray): Output matrix (p x n, F-order)\n  q (ndarray): Left transformation matrix Q1 (n x n, F-order)\n  z (ndarray): Right transformation matrix Z1 (n x n, F-order)\n\nReturns:\n  (a, e, b, c, q, z, info):\n    Block-diagonal A and E, transformed B and C, updated Q and Z, exit code\n\nExamples:\n\n>>> from slicot import tg01nx\n>>> import numpy as np\n>>> n, m, p = 4, 2, 2\n>>> ndim = 2\n>>> a = np.array([\n...     [1.0, 0.5, 0.3, 0.2],\n...     [0.0, 2.0, 0.4, 0.1],\n...     [0.0, 0.0, 3.0, 0.6],\n...     [0.0, 0.0, 0.0, 4.0]\n...     ], dtype=np.float64, order='F')\n>>> e = np.array([\n...     [1.0, 0.2, 0.1, 0.1],\n...     [0.0, 1.0, 0.2, 0.05],\n...     [0.0, 0.0, 1.0, 0.3],\n...     [0.0, 0.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 1.0],\n...     [0.5, 0.5],\n...     [0.0, 0.0]\n...     ], dtype=np.float64, order='F')\n>>> c = np.array([\n...     [1.0, 0.0, 1.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0]\n...     ], dtype=np.float64, order='F')\n>>> q = np.eye(n, dtype=np.float64, order='F')\n>>> z = np.eye(n, dtype=np.float64, order='F')\n>>> a_out, e_out, b_out, c_out, q_out, z_out, info = tg01nx(\n...     'D', n, m, p, ndim, a, e, b, c, q, z\n...     )\n>>> tol = 1e-14\n...     atol=tol, err_msg=\"A12 block should be zero\")\n...     atol=tol, err_msg=\"E12 block should be zero\")\n>>> info\n0",
  "tg01oa": "Orthogonal equivalence transformation of SISO descriptor system.\n\nFor a single-input single-output descriptor system given by the\nsystem matrix [D C; B A-s*E] with E upper triangular, computes a\ntransformed system (Q'*A*Z, Q'*E*Z, Q'*B, C*Z) via orthogonal\nequivalence transformation so that Q'*B has only the first element\nnonzero and Q'*E*Z remains upper triangular.\n\nUses Givens rotations to annihilate the last N-1 elements of B in\nreverse order while preserving the upper triangular form of E.\n\nParameters:\n  jobe (str): 'U' = E is upper triangular, 'I' = E is identity\n  dcba (ndarray): System matrix [D C; B A] ((n+1) x (n+1), F-order)\n  e (ndarray): Descriptor matrix E (n x n, F-order, if JOBE='U')\n\nReturns:\n  (dcba, e, info):\n    dcba: Transformed [D C*Z; Q'*B Q'*A*Z]\n    e: Transformed Q'*E*Z (if JOBE='U')\n    info: 0 = success, <0 = invalid parameter\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01oa\n>>> n = 3\n>>> d = 0.5\n>>> c = np.array([1.0, 2.0, 3.0], dtype=float)\n>>> b = np.array([1.0, 2.0, 3.0], dtype=float)\n>>> a = np.random.randn(n, n).astype(float, order='F')\n>>> dcba = np.zeros((n + 1, n + 1), dtype=float, order='F')\n>>> dcba[0, 0] = d\n>>> dcba[0, 1:] = c\n>>> dcba[1:, 0] = b\n>>> dcba[1:, 1:] = a\n>>> e = np.zeros((1, 1), dtype=float, order='F')\n>>> dcba_out, e_out, info = tg01oa('I', dcba, e)\n>>> b_transformed = dcba_out[1:, 0]\n>>> b_norm_trans = np.linalg.norm(b_transformed)\n>>> a_trans = dcba_out[1:, 1:]\n>>> eig_trans = np.sort(np.linalg.eigvals(a_trans))\n>>> info\n0",
  "tg01ob": "Complex SISO descriptor system unitary equivalence transformation.\n\nFor a single-input single-output complex descriptor system stored in\ncompact form [D C; B A] with E upper triangular, computes a transformed\nsystem via unitary equivalence transformation so that the transformed B\nhas only the first element nonzero and E remains upper triangular.\n\nUses Givens rotations to annihilate the last N-1 elements of B in\nreverse order while preserving the upper triangular form of E.\n\nParameters:\n  jobe (str): 'U' = E is upper triangular, 'I' = E is identity\n  dcba (ndarray): System matrix [(N+1) x (N+1), F-order] containing:\n    [D  C]  where D is scalar, C is 1xN, B is Nx1, A is NxN\n    [B  A]\n  e (ndarray): Complex descriptor matrix (N x N, F-order, if JOBE='U')\n\nReturns:\n  (dcba, e, info):\n    Transformed [D C*Z; Q'*B Q'*A*Z], transformed Q'*E*Z, exit code.\n    D is unchanged. Q'*B has only first element nonzero.\n\nExamples:\n\n>>> from slicot import tg01ob\n>>> import numpy as np\n>>> n = 4\n>>> n1 = n + 1\n>>> a = (np.random.randn(n, n) + 1j * np.random.randn(n, n)).astype(np.complex128, order='F')\n>>> b = (np.random.randn(n, 1) + 1j * np.random.randn(n, 1)).astype(np.complex128, order='F')\n>>> c = (np.random.randn(1, n) + 1j * np.random.randn(1, n)).astype(np.complex128, order='F')\n>>> d = (np.random.randn(1, 1) + 1j * np.random.randn(1, 1)).astype(np.complex128, order='F')\n>>> dcba = np.zeros((n1, n1), dtype=np.complex128, order='F')\n>>> dcba[0, 0] = d[0, 0]\n>>> dcba[0, 1:] = c[0, :]\n>>> dcba[1:, 0] = b[:, 0]\n>>> dcba[1:, 1:] = a\n>>> e = np.eye(n, dtype=np.complex128, order='F')\n>>> dcba_out, e_out, info = tg01ob('I', dcba, e)\n>>> b_out = dcba_out[1:, 0]\n...     err_msg=\"B should have only first element nonzero\")\n>>> info\n0",
  "tg01od": "Reduce SISO descriptor system so feedthrough has large magnitude.\n\nComputes for a single-input single-output descriptor system, given by\nthe system matrix:\n    [ D     C    ]\n    [ B  A - s*E ]\nwith E nonsingular, a reduced system matrix:\n    [ d     c    ]\n    [ b  a - s*e ]\nsuch that d has a \"sufficiently\" large magnitude.\n\nUses Householder transformations and Givens rotations. If E is a general\nmatrix, it is first triangularized using QR decomposition.\n\nParameters:\n  jobe (str): 'G' = E is general nonsingular, 'I' = E is identity\n  dcba (ndarray): System matrix [D C; B A] ((n+1) x (n+1), F-order)\n  e (ndarray): Descriptor matrix E (n x n, F-order, if JOBE='G')\n  tol (float, optional): Tolerance for d magnitude check (default: EPS^(3/4))\n\nReturns:\n  (dcba, e, nz, g, info):\n    dcba: Leading (nz+1) x (nz+1) contains reduced [d c; b a]\n    e: Leading nz x nz contains reduced e (if JOBE='G')\n    nz: Order of reduced system\n    g: Gain of reduced system\n    info: 0 = success, <0 = invalid parameter\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01od\n>>> n = 3\n>>> d = 1e-10\n>>> c = np.array([1.0, 2.0, 3.0], dtype=float)\n>>> b = np.array([1.0, 2.0, 3.0], dtype=float)\n>>> a = np.random.randn(n, n).astype(float, order='F')\n>>> dcba = np.zeros((n + 1, n + 1), dtype=float, order='F')\n>>> dcba[0, 0] = d\n>>> dcba[0, 1:] = c\n>>> dcba[1:, 0] = b\n>>> dcba[1:, 1:] = a\n>>> e = np.zeros((1, 1), dtype=float, order='F')\n>>> dcba_out, e_out, nz, g, info = tg01od('I', dcba, e, 0.0)\n>>> info\n0",
  "tg01oz": "Reduce complex SISO descriptor system so feedthrough has large magnitude.\n\nComputes for a single-input single-output complex descriptor system,\ngiven by the system matrix:\n    [ D     C    ]\n    [ B  A - s*E ]\nwith E nonsingular, a reduced system matrix:\n    [ d     c    ]\n    [ b  a - s*e ]\nsuch that d has a sufficiently large magnitude.\n\nUses Householder transformations and Givens rotations. If E is a general\nmatrix, it is first triangularized using QR decomposition.\n\nParameters:\n  jobe (str): 'G' = E is general nonsingular, 'I' = E is identity\n  dcba (ndarray): Complex system matrix [D C; B A] ((n+1) x (n+1), F-order)\n  e (ndarray): Complex descriptor matrix E (n x n, F-order, if JOBE='G')\n  tol (float, optional): Tolerance for d magnitude check (default: EPS^(3/4))\n\nReturns:\n  (dcba, e, nz, g, info):\n    dcba: Leading (nz+1) x (nz+1) contains reduced [d c; b a]\n    e: Leading nz x nz contains reduced e (if JOBE='G')\n    nz: Order of reduced system\n    g: Complex gain of reduced system\n    info: 0 = success, <0 = invalid parameter\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01oz\n>>> n = 4\n>>> n1 = n + 1\n>>> a = (np.random.randn(n, n) + 1j * np.random.randn(n, n)).astype(np.complex128, order='F')\n>>> b = (np.random.randn(n, 1) + 1j * np.random.randn(n, 1)).astype(np.complex128, order='F')\n>>> c = (np.random.randn(1, n) + 1j * np.random.randn(1, n)).astype(np.complex128, order='F')\n>>> d = 0.0 + 0.0j\n>>> dcba = np.zeros((n1, n1), dtype=np.complex128, order='F')\n>>> dcba[0, 0] = d\n>>> dcba[0, 1:] = c[0, :]\n>>> dcba[1:, 0] = b[:, 0]\n>>> dcba[1:, 1:] = a\n>>> e = np.eye(n, dtype=np.complex128, order='F')\n>>> dcba_out, e_out, nz, g, info = tg01oz('I', dcba, e, 0.0)\n>>> info\n0",
  "tg01pd": "Bi-domain spectral splitting of a subpencil of a descriptor system.\n\nComputes orthogonal transformation matrices Q and Z which reduce the\nregular pole pencil A-lambda*E of the descriptor system (A-lambda*E,B,C)\nto generalized real Schur form with ordered generalized eigenvalues.\nThe pair (A,E) is reduced so that eigenvalues in the domain of interest\nare in the leading diagonal blocks.\n\nFor continuous-time (DICO='C'):\n  Domain of interest: Re(lambda) < ALPHA (STDOM='S') or Re(lambda) > ALPHA (STDOM='U')\nFor discrete-time (DICO='D'):\n  Domain of interest: |lambda| < ALPHA (STDOM='S') or |lambda| > ALPHA (STDOM='U')\n\nParameters:\n  dico (str): 'C' = continuous-time, 'D' = discrete-time\n  stdom (str): 'S' = stability domain, 'U' = instability domain\n  jobae (str): 'G' = general (A,E), 'S' = (A,E) in Schur form\n  compq (str): 'I' = initialize Q to identity, 'U' = update existing Q (only if JOBAE='S')\n  compz (str): 'I' = initialize Z to identity, 'U' = update existing Z (only if JOBAE='S')\n  n (int): Order of matrices A and E\n  m (int): Number of columns of B\n  p (int): Number of rows of C\n  nlow (int): Lower boundary index (min(1,n) if JOBAE='G')\n  nsup (int): Upper boundary index (n if JOBAE='G')\n  alpha (float): Domain boundary (>= 0 for discrete-time)\n  a (ndarray): N-by-N state matrix (F-order)\n  e (ndarray): N-by-N descriptor matrix (F-order)\n  b (ndarray): N-by-M input matrix (F-order)\n  c (ndarray): P-by-N output matrix (F-order)\n  q (ndarray, optional): N-by-N orthogonal matrix (if COMPQ='U')\n  z (ndarray, optional): N-by-N orthogonal matrix (if COMPZ='U')\n\nReturns:\n  (a, e, b, c, q, z, ndim, alphar, alphai, beta, info):\n    a: Transformed Q'*A*Z in Schur form\n    e: Transformed Q'*E*Z upper triangular\n    b: Transformed Q'*B\n    c: Transformed C*Z\n    q: Left orthogonal transformation matrix\n    z: Right orthogonal transformation matrix\n    ndim: Number of eigenvalues in domain of interest\n    alphar: Real parts of generalized eigenvalues\n    alphai: Imaginary parts of generalized eigenvalues\n    beta: Denominators of generalized eigenvalues\n    info: 0 = success, <0 = invalid param, 1 = QZ failed, 2 = ordering failed\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01pd\n>>> n, m, p = 4, 2, 2\n>>> nlow, nsup = 1, 4\n>>> alpha = -1e-7\n>>> a = np.array([\n...     [-1,  0,  0,  3],\n...     [ 0,  0,  1,  2],\n...     [ 1,  1,  0,  4],\n...     [ 0,  0,  0,  0],\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1, 2, 0, 0],\n...     [0, 1, 0, 1],\n...     [3, 9, 6, 3],\n...     [0, 0, 2, 0],\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1, 0],\n...     [0, 0],\n...     [0, 1],\n...     [1, 1],\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [-1, 0,  1, 0],\n...     [ 0, 1, -1, 1],\n...     ], order='F', dtype=float)\n>>> result = tg01pd('C', 'S', 'G', 'I', 'I', n, m, p, nlow, nsup, alpha, a, e, b, c)\n>>> a_out, e_out, b_out, c_out, q, z, ndim, alphar, alphai, beta, info = result",
  "tg01qd": "Three-domain spectral splitting of a descriptor system.\n\nComputes orthogonal transformation matrices Q and Z which reduce the\nregular pole pencil A-lambda*E of the descriptor system (A-lambda*E,B,C)\nto generalized real Schur form with ordered generalized eigenvalues.\nThe pair (A,E) is reduced to three-block form:\n\n           ( A1  *   *  )             ( E1  *   *  )\n  Q'*A*Z = ( 0   A2  *  ) ,  Q'*E*Z = ( 0   E2  *  )\n           ( 0   0   A3 )             ( 0   0   E3 )\n\nIf JOBFI='F': (A1,E1) = finite in domain, (A2,E2) = finite outside, (A3,E3) = infinite\nIf JOBFI='I': (A1,E1) = infinite, (A2,E2) = finite in domain, (A3,E3) = finite outside\n\nFor continuous-time (DICO='C'):\n  Domain of interest: Re(lambda) < ALPHA (STDOM='S') or Re(lambda) > ALPHA (STDOM='U')\nFor discrete-time (DICO='D'):\n  Domain of interest: |lambda| < ALPHA (STDOM='S') or |lambda| > ALPHA (STDOM='U')\nFor STDOM='N': No spectral ordering of finite part.\n\nParameters:\n  dico (str): 'C' = continuous-time, 'D' = discrete-time\n  stdom (str): 'S' = stability domain, 'U' = instability domain, 'N' = no ordering\n  jobfi (str): 'F' = finite first, 'I' = infinite first\n  n (int): Order of matrices A and E\n  m (int): Number of columns of B\n  p (int): Number of rows of C\n  alpha (float): Domain boundary (>= 0 for discrete-time)\n  a (ndarray): N-by-N state matrix (F-order)\n  e (ndarray): N-by-N descriptor matrix (F-order)\n  b (ndarray): N-by-M input matrix (F-order)\n  c (ndarray): P-by-N output matrix (F-order)\n  tol (float): Tolerance for rank decisions (<= 0 for default)\n\nReturns:\n  (a, e, b, c, n1, n2, n3, nd, niblck, iblck, q, z, alphar, alphai, beta, info):\n    a: Transformed Q'*A*Z in Schur form\n    e: Transformed Q'*E*Z upper triangular\n    b: Transformed Q'*B\n    c: Transformed C*Z\n    n1, n2, n3: Eigenvalue counts in each block\n    nd: Number of non-dynamic infinite eigenvalues\n    niblck: Number of infinite blocks minus one\n    iblck: Block dimensions for infinite part\n    q, z: Orthogonal transformation matrices\n    alphar, alphai, beta: Generalized eigenvalues\n    info: 0 = success, <0 = invalid param, 1 = not regular, 2 = QZ failed, 3 = ordering failed\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01qd\n>>> n, m, p = 4, 2, 2\n>>> dico = 'C'\n>>> stdom = 'S'\n>>> jobfi = 'F'\n>>> alpha = -1.0e-7\n>>> tol = 0.0\n>>> a = np.array([\n...     [-1.0, 0.0, 0.0, 3.0],\n...     [0.0, 0.0, 1.0, 2.0],\n...     [1.0, 1.0, 0.0, 4.0],\n...     [0.0, 0.0, 0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> e = np.array([\n...     [1.0, 2.0, 0.0, 0.0],\n...     [0.0, 1.0, 0.0, 1.0],\n...     [3.0, 9.0, 6.0, 3.0],\n...     [0.0, 0.0, 2.0, 0.0]\n...     ], order='F', dtype=float)\n>>> b = np.array([\n...     [1.0, 0.0],\n...     [0.0, 0.0],\n...     [0.0, 1.0],\n...     [1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> c = np.array([\n...     [-1.0, 0.0, 1.0, 0.0],\n...     [0.0, 1.0, -1.0, 1.0]\n...     ], order='F', dtype=float)\n>>> result = tg01qd(dico, stdom, jobfi, n, m, p, alpha, a, e, b, c, tol)\n>>> a_out, e_out, b_out, c_out, n1, n2, n3, nd, niblck, iblck, \\\n...     q, z, alphar, alphai, beta, info = result\n>>> nf = n1 + n2\n>>> eig_computed = []\n...     eig_computed.append(complex(alphar[j], alphai[j]) / beta[j])\n>>> eig_computed_real = sorted([e.real for e in eig_computed if abs(e.imag) < 1e-6])",
  "tg01wd": "Reduce descriptor system to generalized real Schur form.\n\nReduces the pair (A,E) to a real generalized Schur form using an\northogonal equivalence transformation (A,E) <-- (Q'*A*Z, Q'*E*Z)\nand applies the transformation to matrices B and C:\nB <-- Q'*B and C <-- C*Z.\n\nAfter reduction:\n- A is in upper quasi-triangular form (elements below first subdiagonal = 0)\n- E is in upper triangular form\n\nThe generalized eigenvalues of (A,E) are returned as\n(ALPHAR(j) + i*ALPHAI(j)) / BETA(j), j=1,...,N.\n\nParameters:\n  n (int): Order of matrices A and E (N >= 0)\n  m (int): Number of columns of B (M >= 0)\n  p (int): Number of rows of C (P >= 0)\n  a (ndarray): N-by-N state dynamics matrix (F-order)\n  e (ndarray): N-by-N descriptor matrix (F-order)\n  b (ndarray): N-by-M input matrix (F-order)\n  c (ndarray): P-by-N output matrix (F-order)\n\nReturns:\n  (a, e, b, c, q, z, alphar, alphai, beta, info):\n    a: Transformed Q'*A*Z in upper quasi-triangular form\n    e: Transformed Q'*E*Z in upper triangular form\n    b: Transformed Q'*B\n    c: Transformed C*Z\n    q: N-by-N left orthogonal transformation matrix\n    z: N-by-N right orthogonal transformation matrix\n    alphar: Real parts of generalized eigenvalues (size N)\n    alphai: Imaginary parts of generalized eigenvalues (size N)\n    beta: Denominators of generalized eigenvalues (size N)\n    info: 0 = success, <0 = invalid param -i, >0 = QZ algorithm failed\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import tg01wd\n>>> n, m, p = 4, 2, 2\n>>> a = np.random.randn(n, n).astype(float, order='F')\n>>> e = np.eye(n, order='F', dtype=float) + 0.1 * np.random.randn(n, n)\n>>> e = e.astype(float, order='F')\n>>> b = np.random.randn(n, m).astype(float, order='F')\n>>> c = np.random.randn(p, n).astype(float, order='F')\n>>> a_out, e_out, b_out, c_out, q, z, alphar, alphai, beta, info = tg01wd(\n...     n, m, p, a, e, b, c\n...     )\n>>> info\n0",
  "ud01bd": "Read/copy coefficients of a matrix polynomial.\n\nCopies the coefficients of a matrix polynomial P(s) from input data array\nto a 3D output array. The polynomial is:\n    P(s) = P(0) + P(1)*s + ... + P(dp-1)*s^(dp-1) + P(dp)*s^dp\n\nEach coefficient P(k) is an MP-by-NP matrix. The input data contains\n(DP+1) matrices stored row by row (matching Fortran file read order).\n\nParameters:\n  mp (int): Number of rows of each coefficient matrix (mp >= 1)\n  np (int): Number of columns of each coefficient matrix (np >= 1)\n  dp (int): Degree of the polynomial (dp >= 0)\n  data (ndarray): Input data array of length mp*np*(dp+1) containing\n                  coefficient matrices P(0), P(1), ..., P(dp) stored\n                  row by row\n\nReturns:\n  (p, info):\n    p: 3D array (mp, np, dp+1) where p[:,:,k] = P(k), coefficient of s^k\n    info: Exit code (0=success, -1=mp<1, -2=np<1, -3=dp<0)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ud01bd\n>>> mp, np_dim, dp = 4, 3, 2\n>>> p0 = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 2.0, 4.0],\n...     [0.0, 4.0, 8.0],\n...     [0.0, 6.0, 12.0]\n...     ], order='F', dtype=float)\n>>> p1 = np.array([\n...     [0.0, 1.0, 2.0],\n...     [1.0, 0.0, 0.0],\n...     [2.0, 0.0, 0.0],\n...     [3.0, 0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> p2 = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0]\n...     ], order='F', dtype=float)\n>>> data = np.concatenate([\n...     p0.flatten(order='C'),  # row-by-row\n...     p1.flatten(order='C'),\n...     p2.flatten(order='C')\n...     ])\n>>> p, info = ud01bd(mp, np_dim, dp, data)\n>>> info\n0",
  "ud01cd": "Read sparse matrix polynomial coefficients.\n\nConstructs a matrix polynomial from sparse element specifications:\n    P(s) = P(0) + P(1)*s + ... + P(dp-1)*s^(dp-1) + P(dp)*s^dp\n\nEach nonzero polynomial element P_{i,j}(s) is specified by its row index,\ncolumn index, degree, and coefficients. All unspecified elements are zero.\n\nParameters:\n  mp (int): Number of rows of each coefficient matrix (mp >= 1)\n  np (int): Number of columns of each coefficient matrix (np >= 1)\n  dp (int): Maximum degree of the matrix polynomial (dp >= 0)\n  rows (ndarray): Array of row indices (1-based), shape (nelem,)\n  cols (ndarray): Array of column indices (1-based), shape (nelem,)\n  degrees (ndarray): Array of polynomial degrees for each element, shape (nelem,)\n  coeffs (ndarray): Concatenated coefficients for all elements.\n                    Element e has (degrees[e]+1) coefficients: c_0, c_1, ..., c_d\n                    representing P_{i,j}(s) = c_0 + c_1*s + ... + c_d*s^d\n\nReturns:\n  (p, info):\n    p: 3D array (mp, np, dp+1) where p[:,:,k] = P(k), coefficient of s^k\n    info: Exit code:\n          0 = success\n          -1 = mp < 1\n          -2 = np < 1\n          -3 = dp < 0\n          1 = warning: some indices/degrees out of bounds (skipped)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ud01cd\n>>> mp, np_dim, dp = 4, 3, 2\n>>> rows = np.array([1, 2, 3, 4], dtype=np.int32)\n>>> cols = np.array([1, 2, 3, 1], dtype=np.int32)\n>>> degrees = np.array([1, 2, 2, 0], dtype=np.int32)\n>>> coeffs = np.array([1.0, 1.0, 2.0, 0.0, 1.0, 0.0, 3.0, 1.0, 4.0], dtype=float)\n>>> p, info = ud01cd(mp, np_dim, dp, rows, cols, degrees, coeffs)\n>>> info\n0",
  "ud01dd": "Read/construct a sparse matrix from COO format.\n\nInitializes an M-by-N matrix to zero, then assigns nonzero elements\nfrom sparse COO (Coordinate) format input arrays.\n\nThe original Fortran routine reads from a file; this C implementation\naccepts sparse data directly as arrays of row indices, column indices,\nand values.\n\nParameters:\n  m (int): Number of rows of the matrix A (m >= 0)\n  n (int): Number of columns of the matrix A (n >= 0)\n  rows (ndarray): Array of row indices (1-based, Fortran convention)\n  cols (ndarray): Array of column indices (1-based, Fortran convention)\n  vals (ndarray): Array of values to assign\n\nReturns:\n  (a, info):\n    a: Output matrix (m, n) with sparse entries assigned\n    info: Exit code:\n          0 = success\n          -1 = m < 0\n          -2 = n < 0\n          1 = warning: some indices were out of bounds (skipped)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ud01dd\n>>> m, n = 6, 5\n>>> rows = np.array([1, 6, 2, 6, 3, 6, 4, 6, 5, 6], dtype=np.int32)\n>>> cols = np.array([1, 1, 2, 2, 3, 3, 4, 4, 5, 5], dtype=np.int32)\n>>> vals = np.array([-1.1, 1.5, -2.2, 2.5, -3.3, 3.5, -4.4, 4.5, -5.5, 5.5])\n>>> a, info = ud01dd(m, n, rows, cols, vals)\n>>> expected = np.array([\n...     [-1.1, 0.0, 0.0, 0.0, 0.0],\n...     [0.0, -2.2, 0.0, 0.0, 0.0],\n...     [0.0, 0.0, -3.3, 0.0, 0.0],\n...     [0.0, 0.0, 0.0, -4.4, 0.0],\n...     [0.0, 0.0, 0.0, 0.0, -5.5],\n...     [1.5, 2.5, 3.5, 4.5, 5.5]\n...     ], order='F', dtype=float)\n>>> info\n0",
  "ud01md": "Print an M-by-N real matrix row by row.\n\nPrints the elements of A to 7 significant figures with column headers.\nThe matrix is printed in blocks of L columns.\n\nParameters:\n  m (int): Number of rows of matrix A (m >= 1)\n  n (int): Number of columns of matrix A (n >= 1)\n  l (int): Number of elements per line (1 <= l <= 5)\n  a (ndarray): Array of dimension (m, n), the matrix to print\n  text (str): Title caption (up to 72 characters)\n\nReturns:\n  (result, info):\n    result: Formatted string representation of the matrix\n    info: Exit code:\n          0 = success\n          -1 = m < 1\n          -2 = n < 1\n          -3 = l < 1 or l > 5\n          -6 = lda < m\n          -100 = output buffer too small\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ud01md\n>>> m, n, l = 4, 4, 4\n>>> a = np.array([\n...     [1.0, 2.0, 3.0, 4.0],\n...     [5.0, 6.0, 7.0, 8.0],\n...     [9.0, 10.0, 11.0, 12.0],\n...     [13.0, 14.0, 15.0, 16.0]\n...     ], order='F', dtype=float)\n>>> text = 'Matrix A'\n>>> result, info = ud01md(m, n, l, a, text)\n>>> lines = result.strip().split('\\n')\n>>> info\n0",
  "ud01mz": "Print an M-by-N complex matrix row by row.\n\nPrints the elements of A to 7 significant figures with column headers.\nComplex numbers are displayed as real+imaginary pairs. The matrix is\nprinted in blocks of L columns (max 3 for complex due to wider format).\n\nParameters:\n  a (ndarray): Complex matrix of dimension (m, n) to print\n  text (str): Title caption (up to 72 characters)\n  l (int, optional): Number of elements per line (1 <= l <= 3, default=3)\n\nReturns:\n  (result, info):\n    result: Formatted string representation of the matrix\n    info: Exit code:\n          0 = success\n          -1 = m < 1\n          -2 = n < 1\n          -3 = l < 1 or l > 3\n          -5 = lda < m\n          -6 = output buffer too small\n\nExamples:\n\n>>> from slicot import ud01mz\n>>> import numpy as np\n>>> a = np.array([\n...     [1.0 + 2.0j, 3.0 + 4.0j],\n...     [5.0 - 1.0j, -2.0 + 0.5j]\n...     ], order='F', dtype=np.complex128)\n>>> text = \"Test Matrix A\"\n>>> result, info = ud01mz(a, text, l=1)\n>>> info\n0",
  "ud01nd": "Print the coefficient matrices of a matrix polynomial.\n\nPrints the MP-by-NP coefficient matrices of a matrix polynomial:\n    P(s) = P(0) + P(1)*s + ... + P(dp-1)*s^(dp-1) + P(dp)*s^dp\n\nThe elements are output to 7 significant figures. Each coefficient matrix\nis printed with a title showing the polynomial degree.\n\nParameters:\n  mp (int): Number of rows of each coefficient matrix (mp >= 1)\n  np (int): Number of columns of each coefficient matrix (np >= 1)\n  dp (int): Degree of the matrix polynomial (dp >= 0)\n  l (int): Number of elements per line (1 <= l <= 5)\n  p (ndarray): 3D array (mp, np, dp+1) containing polynomial coefficients.\n               p[:,:,k] = P(k), the coefficient matrix of s^k\n  text (str): Title caption (up to 72 characters).\n              If blank, coefficient matrices are separated by empty lines.\n\nReturns:\n  (result, info):\n    result: Formatted string representation of the polynomial\n    info: Exit code:\n          0 = success\n          -1 = mp < 1\n          -2 = np < 1\n          -3 = dp < 0\n          -4 = l < 1 or l > 5\n          -6 = ldp1 < mp\n          -7 = ldp2 < np\n          -100 = output buffer too small\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ud01nd\n>>> mp, np_dim, dp, l = 4, 3, 2, 5\n>>> p = np.zeros((mp, np_dim, dp + 1), order='F', dtype=float)\n>>> p[:, :, 0] = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 2.0, 4.0],\n...     [0.0, 4.0, 8.0],\n...     [0.0, 6.0, 12.0]\n...     ], order='F')\n>>> p[:, :, 1] = np.array([\n...     [0.0, 1.0, 2.0],\n...     [1.0, 0.0, 0.0],\n...     [2.0, 0.0, 0.0],\n...     [3.0, 0.0, 0.0]\n...     ], order='F')\n>>> p[:, :, 2] = np.array([\n...     [1.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0],\n...     [0.0, 0.0, 0.0]\n...     ], order='F')\n>>> text = 'P'\n>>> result, info = ud01nd(mp, np_dim, dp, l, p, text)\n>>> info\n0",
  "ue01md": "Get machine-specific parameters for SLICOT routines.\n\nProvides an extension of the LAPACK routine ILAENV to return\nmachine-specific parameters for SLICOT routines. The default values\naim to give good performance on a wide range of computers.\n\nParameters:\n  ispec (int): Specifies the parameter to be returned:\n               1 = optimal blocksize\n               2 = minimum block size for block routine\n               3 = crossover point (use unblocked for N < this)\n               4 = number of shifts (product eigenvalue routine)\n               8 = crossover point for multishift QR\n  name (str): Name of the calling subroutine (upper or lower case)\n  opts (str): Character options to the subroutine, concatenated\n  n1 (int): First problem dimension\n  n2 (int): Second problem dimension\n  n3 (int): Third problem dimension\n\nReturns:\n  result (int): The parameter value according to ISPEC, or -1 for invalid ISPEC\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import ue01md\n>>> ispec = 1\n>>> name = \"MB04SB\"\n>>> opts = \"\"\n>>> n1, n2, n3 = 100, 100, -1\n>>> result = ue01md(ispec, name, opts, n1, n2, n3)",
  "zgegs": "Compute generalized Schur form for complex matrix pair.\n\nThis routine is deprecated and replaced by ZGGES.\n\nComputes the generalized Schur factorization of a complex matrix pair (A,B):\n    A = Q * S * Z^H\n    B = Q * T * Z^H\n\nwhere Q and Z are unitary and S and T are upper triangular.\nThe generalized eigenvalues are alpha(j)/beta(j) where\nalpha = diag(S) and beta = diag(T).\n\nParameters:\n  jobvsl (str): 'N' = no left Schur vectors, 'V' = compute left Schur vectors Q\n  jobvsr (str): 'N' = no right Schur vectors, 'V' = compute right Schur vectors Z\n  a (ndarray): Complex matrix A (n x n, F-order), overwritten with S on exit\n  b (ndarray): Complex matrix B (n x n, F-order), overwritten with T on exit\n  lwork (int, optional): Workspace size (-1 for query, default auto)\n\nReturns:\n  (s, t, alpha, beta, vsl, vsr, info):\n    s: Upper triangular Schur form of A (n x n)\n    t: Upper triangular Schur form of B (n x n)\n    alpha: Eigenvalue numerators from diag(S) (n,)\n    beta: Eigenvalue denominators from diag(T) (n,)\n    vsl: Left Schur vectors Q (n x n) if jobvsl='V', else empty\n    vsr: Right Schur vectors Z (n x n) if jobvsr='V', else empty\n    info: Exit code (0=success, <0=param error, 1..N=QZ failed, >N=LAPACK error)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import zgegs\n>>> n = 2\n>>> a = (np.random.randn(n, n) + 1j * np.random.randn(n, n)).astype(\n...     np.complex128, order=\"F\"\n...     )\n>>> b = (np.random.randn(n, n) + 1j * np.random.randn(n, n)).astype(\n...     np.complex128, order=\"F\"\n...     )\n>>> s, t, alpha, beta, vsl, vsr, info = zgegs(\"V\", \"V\", a, b)\n>>> a_reconstructed = vsl @ s @ vsr.conj().T\n>>> b_reconstructed = vsl @ t @ vsr.conj().T\n>>> info\n0",
  "zgegv": "Compute generalized eigenvalues and eigenvectors for complex matrix pair.\n\nThis routine is deprecated and replaced by ZGGEV.\n\nComputes the eigenvalues and, optionally, the left and/or right eigenvectors\nof a complex matrix pair (A,B). Given A*x = lambda*B*x, returns alpha and beta\nsuch that lambda = alpha/beta.\n\nThe eigenvalues are returned as alpha(j)/beta(j) to handle cases where\nlambda may be infinite (when beta(j) = 0).\n\nParameters:\n  jobvl (str): 'N' = no left eigenvectors, 'V' = compute left eigenvectors\n  jobvr (str): 'N' = no right eigenvectors, 'V' = compute right eigenvectors\n  a (ndarray): Complex matrix A (n x n, F-order), overwritten on exit\n  b (ndarray): Complex matrix B (n x n, F-order), overwritten on exit\n  lwork (int, optional): Workspace size (-1 for query, default auto)\n\nReturns:\n  (alpha, beta, vl, vr, info):\n    alpha: Complex eigenvalue numerators (n,)\n    beta: Complex eigenvalue denominators (n,)\n    vl: Left eigenvectors (n x n) if jobvl='V', else empty\n    vr: Right eigenvectors (n x n) if jobvr='V', else empty\n    info: Exit code (0=success, <0=param error, 1..N=QZ failed, >N=LAPACK error)\n\nExamples:\n\n>>> import numpy as np\n>>> from slicot import zgegv\n>>> n = 2\n>>> a = (np.random.randn(n, n) + 1j * np.random.randn(n, n)).astype(\n...     np.complex128, order=\"F\"\n...     )\n>>> b = np.eye(n, dtype=np.complex128, order=\"F\")\n>>> alpha, beta, vl, vr, info = zgegv(\"N\", \"N\", a, b)\n>>> eigs_computed = []\n...     eigs_computed.append(alpha[i] / beta[i])\n>>> eigs_computed = np.array(sorted(eigs_computed, key=lambda x: (x.real, x.imag)))\n>>> info\n0"
}